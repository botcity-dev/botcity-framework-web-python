{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to BotCity's Framework Web Python package for RPA. Installation Latest release Using PyPI pip install botcity-framework-web Using conda-forge - Coming Soon conda install -c conda-forge botcity-framework-web Latest code pip install git + https : // github . com / botcity - dev / botcity - framework - web - python . git","title":"Home"},{"location":"#welcome","text":"Welcome to BotCity's Framework Web Python package for RPA.","title":"Welcome"},{"location":"#installation","text":"","title":"Installation"},{"location":"#latest-release","text":"","title":"Latest release"},{"location":"#using-pypi","text":"pip install botcity-framework-web","title":"Using PyPI"},{"location":"#using-conda-forge-coming-soon","text":"conda install -c conda-forge botcity-framework-web","title":"Using conda-forge - Coming Soon"},{"location":"#latest-code","text":"pip install git + https : // github . com / botcity - dev / botcity - framework - web - python . git","title":"Latest code"},{"location":"bot/","text":"Framework The botcity.web module contains specialized implementations aimed at Web automation such as WebBot which is described below. You are expected to implement the action method of the WebBot class in your Bot class. Here is a very brief example of a bot which opens the BotCity website using Google Chrome and the ChromeDriver WebDriver to remote control the browser. from botcity.web import WebBot class Bot ( WebBot ): def action ( self , execution = None # Configure whether or not to run on headless mode self . headless = False # Opens the BotCity website. self . browse ( \"https://botcity.dev/en\" ) # Wait for 10 seconds before closing everything self . sleep ( 10000 ) # Stop the browser and clean up self . stop_browser () if __name__ == '__main__' : Bot . main () botcity.web.bot.WebBot ( BaseBot ) Source code in web/bot.py class WebBot ( BaseBot ): KEYS = Keys \"\"\" Base class for Web Bots. Users must implement the `action` method in their classes. Attributes: state (State): The internal state of this bot. maestro (BotMaestroSDK): an instance to interact with the BotMaestro server. \"\"\" def __init__ ( self , headless = False ): self . state = State () self . maestro = BotMaestroSDK () if MAESTRO_AVAILABLE else None self . _browser = Browser . CHROME self . _options = None self . _capabilities = None self . _driver_path = None self . _driver = None self . _headless = headless self . _clipboard = \"\" # Stub mouse coordinates self . _html_elem = None self . _x = 0 self . _y = 0 # State for Key modifiers self . _shift_hold = False self . _dimensions = ( 1600 , 900 ) self . _download_folder_path = os . getcwd () @property def driver ( self ): \"\"\" The WebDriver driver instance. Returns: driver (WebDriver): The WebDriver driver instance. \"\"\" return self . _driver @property def driver_path ( self ): return self . _driver_path @driver_path . setter def driver_path ( self , driver_path ): \"\"\" The webdriver executable path. Args: driver_path (str): The full path to the proper webdriver path used for the selected browser. If set to None, the code will look into the PATH for the proper file when starting the browser. \"\"\" driver_path = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( driver_path ))) if driver_path and not os . path . isfile ( driver_path ): raise ValueError ( \"Invalid driver_path. The file does not exist.\" ) self . _driver_path = driver_path @property def browser ( self ): \"\"\" The web browser to be used. Returns: browser (Browser): The web browser to be used. \"\"\" return self . _browser @browser . setter def browser ( self , browser ): \"\"\" The web browser to be used. Args: browser (Browser): The name of web browser to be used from the Browser enum. \"\"\" self . _browser = browser @property def options ( self ): \"\"\" The options to be passed down to the WebDriver when starting the browser. Returns: options (Options): The browser specific options to be used. \"\"\" return self . _options @options . setter def options ( self , options ): \"\"\" The options to be passed down to the WebDriver when starting the browser. Args: options (Options): The browser specific options to be used. \"\"\" self . _options = options @property def capabilities ( self ): \"\"\" The capabilities to be passed down to the WebDriver when starting the browser. Returns: capabilities (Dict): The browser specific capabilities to be used. \"\"\" return self . _capabilities @capabilities . setter def capabilities ( self , capabilities ): \"\"\" The capabilities to be passed down to the WebDriver when starting the browser. Args: capabilities (Dict): The browser specific capabilities to be used. \"\"\" self . _capabilities = capabilities @property def download_folder_path ( self ): return self . _download_folder_path @download_folder_path . setter def download_folder_path ( self , folder_path ): \"\"\" The download folder path to be used. Set it up before starting the Browser or browsing a URL or restart the browser after changing it. Args: folder_path (str): The desired download folder path. \"\"\" self . _download_folder_path = folder_path @property def headless ( self ): \"\"\" Controls whether or not the bot will run headless. Returns: headless (bool): Whether or not to run the browser on headless mode. \"\"\" return self . _headless @headless . setter def headless ( self , headless ): \"\"\" Controls whether or not the bot will run headless. Args: headless (boolean): If set to True will make the bot run headless. \"\"\" if self . _driver : logger . warning ( \"Browser is running. Invoke stop_browser and start browser for changes to take effect.\" ) self . _headless = headless def start_browser ( self ): \"\"\" Starts the selected browser. \"\"\" def check_driver (): # Look for driver driver_name = BROWSER_CONFIGS . get ( self . browser ) . get ( \"driver\" ) location = shutil . which ( driver_name ) if not location : raise RuntimeError ( f \" { driver_name } was not found. Please make sure to have it on your PATH or set driver_path\" ) return location # Specific webdriver class for a given browser driver_class = BROWSER_CONFIGS . get ( self . browser ) . get ( \"class\" ) # Specific default options method for a given browser func_def_options = BROWSER_CONFIGS . get ( self . browser ) . get ( \"options\" ) # Specific capabilities method for a given browser func_def_capabilities = BROWSER_CONFIGS . get ( self . browser ) . get ( \"capabilities\" ) opt = self . options or func_def_options ( self . headless , self . _download_folder_path , None ) cap = self . capabilities or func_def_capabilities () self . options = opt self . capabilities = cap driver_path = self . driver_path or check_driver () self . driver_path = driver_path self . _driver = driver_class ( options = opt , desired_capabilities = cap , executable_path = driver_path ) self . set_screen_resolution () def stop_browser ( self ): \"\"\" Stops the Chrome browser and clean up the User Data Directory. \"\"\" if not self . _driver : return self . _driver . close () self . _driver . quit () self . _driver = None def set_screen_resolution ( self , width = None , height = None ): \"\"\" Configures the browser dimensions. Args: width (int): The desired width. height (int): The desired height. \"\"\" self . _dimensions = ( width or 1600 , height or 900 ) if self . headless : # When running headless the window size is the viewport size window_size = self . _dimensions else : # When running non-headless we need to account for the borders and etc # So the size must be bigger to have the same viewport size as before window_size = self . _driver . execute_script ( \"\"\" return [window.outerWidth - window.innerWidth + arguments[0], window.outerHeight - window.innerHeight + arguments[1]]; \"\"\" , * self . _dimensions ) self . _driver . set_window_size ( * window_size ) def _webdriver_command ( self , command , params = None , req_type = \"POST\" ): \"\"\" Execute a webdriver command. Args: command (str): The command URL after the session part params (dict): The payload to be serialized and sent to the webdriver. Defaults to None. req_type (str, optional): The type of request to be made. Defaults to \"POST\". Returns: str: The value of the response \"\"\" if not params : params = {} resource = f \"/session/ { self . driver . session_id } / { command } \" url = self . driver . command_executor . _url + resource body = json . dumps ( params ) response = self . driver . command_executor . _request ( req_type , url , body ) if not response : raise Exception ( response . get ( 'value' )) return response . get ( 'value' ) ########## # Display ########## def get_screen_image ( self , region = None ): \"\"\" Capture and returns a screenshot from the browser. Args: region (tuple): A tuple containing the left, top, width and height to crop the screen image. Returns: image (Image): The screenshot Image object. \"\"\" if not region : region = ( 0 , 0 , 0 , 0 ) x = region [ 0 ] or 0 y = region [ 1 ] or 0 width = region [ 2 ] or self . _dimensions [ 0 ] height = region [ 3 ] or self . _dimensions [ 1 ] data = self . _driver . get_screenshot_as_base64 () image_data = base64 . b64decode ( data ) img = Image . open ( io . BytesIO ( image_data )) img = img . crop (( x , y , x + width , y + height )) return img def get_viewport_size ( self ): \"\"\" Returns the browser current viewport size. Returns: width (int): The current viewport width. height (int): The current viewport height. \"\"\" # Access each dimension individually width = self . _driver . get_window_size () . get ( \"width\" ) height = self . _driver . get_window_size () . get ( \"height\" ) return width , height def add_image ( self , label , path ): \"\"\" Add an image into the state image map. Args: label (str): The image identifier path (str): The path for the image on disk \"\"\" self . state . map_images [ label ] = path def get_image_from_map ( self , label ): \"\"\" Return an image from teh state image map. Args: label (str): The image identifier Returns: Image: The Image object \"\"\" path = self . state . map_images . get ( label ) if not path : raise KeyError ( 'Invalid label for image map.' ) img = Image . open ( path ) return img def find_multiple ( self , labels , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find multiple elements defined by label on screen until a timeout happens. Args: labels (list): A list of image identifiers x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: results (dict): A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. \"\"\" def _to_dict ( lbs , elems ): return { k : v for k , v in zip ( lbs , elems )} screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) results = [ None ] * len ( labels ) paths = [ self . _search_image_file ( la ) for la in labels ] if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () n_cpus = multiprocessing . cpu_count () - 1 while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return _to_dict ( labels , results ) haystack = self . screenshot () helper = functools . partial ( self . _find_multiple_helper , haystack , region , matching , grayscale ) with multiprocessing . Pool ( processes = n_cpus ) as pool : results = pool . map ( helper , paths ) results = [ r for r in results ] if None in results : continue else : return _to_dict ( labels , results ) def _find_multiple_helper ( self , haystack , region , confidence , grayscale , needle ): ele = cv2find . locate_all_opencv ( needle , haystack , region = region , confidence = confidence , grayscale = grayscale ) try : ele = next ( ele ) except StopIteration : ele = None return ele def find ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label = label , x = x , y = y , width = width , height = height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = grayscale ) def find_until ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" self . state . element = None screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( element_path , haystack_image = haystack , region = region , confidence = matching , grayscale = grayscale ) try : ele = next ( it ) except StopIteration : ele = None if ele is not None : self . state . element = ele return ele def set_current_element ( self , element : cv2find . Box ): \"\"\" Changes the current screen element the bot will interact when using click(), move(), and similar methods. This method is equivalent to self.state.element = element. Args: element (Box): A screen element from self.state.element or the find_all(as_list=True) method. \"\"\" self . state . element = element def find_all ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , grayscale = False , as_list : bool = False ): \"\"\" Find all elements defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. as_list (bool, Optional): If True, returns a list of element coordinates instead of a generator. Use set_active_element() to be able to interact with the found elements. This parameter must be True if you intend to run multiple find_all() concurrently. Defaults to False. Returns: elements (collections.Iterable[NamedTuple]): A generator with all element coordinates found. None if not found. \"\"\" def deduplicate ( elems ): def find_same ( item , items ): x_start = item . left x_end = item . left + item . width y_start = item . top y_end = item . top + item . height similars = [] for itm in items : if itm == item : continue if ( itm . left >= x_start and itm . left < x_end ) \\ and ( itm . top >= y_start and itm . top < y_end ): similars . append ( itm ) continue return similars index = 0 while True : try : dups = find_same ( elems [ index ], elems [ index :]) for d in dups : elems . remove ( d ) index += 1 except IndexError : break return elems self . state . element = None screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( element_path , haystack_image = haystack , region = region , confidence = matching , grayscale = grayscale ) eles = [ ele for ele in it ] if not eles : continue eles = deduplicate ( list ( eles )) # As List if as_list : return eles # As Generator for ele in eles : if ele is not None : self . state . element = ele yield ele break def find_text ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label , x , y , width , height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = True ) def get_last_element ( self ): \"\"\" Return the last element found. Returns: element (NamedTuple): The element coordinates (left, top, width, height) \"\"\" return self . state . element def display_size ( self ): \"\"\" Returns the display size in pixels. Returns: size (Tuple): The screen dimension (width and height) in pixels. \"\"\" return self . _dimensions def screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" img = self . get_screen_image ( region ) if filepath : img . save ( filepath ) return img def get_screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" return self . screenshot ( filepath , region ) def screen_cut ( self , x , y , width = None , height = None ): \"\"\" Capture a screenshot from a region of the screen. Args: x (int): region start position x y (int): region start position y width (int): region width height (int): region height Returns: Image: The screenshot Image object \"\"\" screen_size = self . _dimensions x = x or 0 y = y or 0 width = width or screen_size [ 0 ] height = height or screen_size [ 1 ] img = self . screenshot ( region = ( x , y , width , height )) return img def save_screenshot ( self , path ): \"\"\" Saves a screenshot in a given path. Args: path (str): The filepath in which to save the screenshot \"\"\" self . screenshot ( path ) def get_element_coords ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the element. \"\"\" self . state . element = None screen_size = self . _dimensions x = x or 0 y = y or 0 width = width or screen_size [ 0 ] height = height or screen_size [ 1 ] region = ( x , y , width , height ) if not best : print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( self . state . map_images [ label ], haystack_image = haystack , region = region , confidence = matching ) try : ele = next ( it ) except StopIteration : ele = None self . state . element = ele if ele : return ele . left , ele . top else : return None , None def get_element_coords_centered ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its centered coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the center of the element. \"\"\" self . get_element_coords ( label , x , y , width , height , matching , best ) return self . state . center () ######### # Browser ######### def page_title ( self ): \"\"\" Returns the active page title. Returns: title (str): The page title. \"\"\" try : return self . _driver . title except InvalidSessionIdException : return None def page_source ( self ): \"\"\" Returns the active page source. Returns: soup (BeautifulSoup): BeautifulSoup object for the page source. \"\"\" try : soup = BeautifulSoup ( self . _driver . page_source , 'html.parser' ) return soup except InvalidSessionIdException : return None def navigate_to ( self , url , is_retry = False ): \"\"\" Opens the browser on the given URL. Args: url (str): The URL to be visited. is_retry (bool): Whether or not this is a retry attempt. \"\"\" self . _x = 0 self . _y = 0 if not self . _driver : self . start_browser () try : self . _driver . get ( url ) except InvalidSessionIdException : if not is_retry : self . stop_browser () self . navigate_to ( url , is_retry = True ) def browse ( self , url ): \"\"\" Opens the browser on the given URL. Args: url (str): The URL to be visited. \"\"\" self . navigate_to ( url ) def execute_javascript ( self , code ): \"\"\" Execute the given javascript code. Args: code (str): The code to be executed. Returns: value (object): Returns the code output or None if not available or if an error happens. \"\"\" return self . _driver . execute_script ( code ) def handle_js_dialog ( self , accept = True , prompt_text = None ): \"\"\" Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). This also cleans the dialog information in the local buffer. Args: accept (bool): Whether to accept or dismiss the dialog. prompt_text (str): The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog. \"\"\" dialog = self . get_js_dialog () if not dialog : # TODO: Maybe we should raise an exception here if no alert available return if prompt_text is not None : dialog . send_keys ( prompt_text ) if accept : dialog . accept () else : dialog . dismiss () def get_js_dialog ( self ): \"\"\" Return the last found dialog. Invoke first the `find_js_dialog` method to look up. Returns: dialog (dict): The dialog information or None if not available. See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening \"\"\" try : dialog = self . _driver . switch_to . alert return dialog except Exception : return None def get_tabs ( self ): \"\"\"Get a list of tab handlers Returns: list: List of tab handlers \"\"\" try : return self . _driver . window_handles except InvalidSessionIdException : return [] def create_tab ( self , url ): \"\"\"Create a new tab and navigate to the given URL. Args: url (str): The desired URL. \"\"\" try : # Refactor this when Selenium 4 is released self . execute_javascript ( f \"window.open(' { url } ', '_blank');\" ) self . _driver . switch_to . window ( self . get_tabs ()[ - 1 ]) except InvalidSessionIdException : self . navigate_to ( url ) def create_window ( self , url ): \"\"\"Creates a new window with the given URL. Args: url (str): The desired URL. \"\"\" try : # Refactor this when Selenium 4 is released self . execute_javascript ( f \"window.open(' { url } ', '_blank', 'location=0');\" ) self . _driver . switch_to . window ( self . get_tabs ()[ - 1 ]) except InvalidSessionIdException : self . navigate_to ( url ) def close_page ( self ): \"\"\"Close the current active page (tab or window). \"\"\" try : self . _driver . close () # If it was the last tab we can't switch tabs = self . get_tabs () if tabs : self . _driver . switch_to . window ( tabs [ - 1 ]) except InvalidSessionIdException : pass def activate_tab ( self , handle ): \"\"\"Activate a tab given by the handle. Args: handle (str): The tab or window handle. \"\"\" self . _driver . switch_to . window ( handle ) def print_pdf ( self , path = None , print_options = None ): \"\"\"Print the current page as a PDF file. Args: path (str, optional): The path for the file to be saved. Defaults to None. print_options (dict, optional): Print options as defined at. Defaults to None. Returns: str: the saved file path \"\"\" title = self . page_title () or \"document\" timeout = 60000 if not self . page_title (): timeout = 1000 default_path = os . path . expanduser ( os . path . join ( self . download_folder_path , f \" { title } .pdf\" )) if self . browser in [ Browser . CHROME , Browser . EDGE ] and not self . headless : # Chrome still does not support headless webdriver print # but Firefox does. self . execute_javascript ( \"window.print();\" ) # We need to wait for the file to be available in this case. self . wait_for_file ( default_path , timeout = timeout ) return default_path if print_options is None : print_options = { 'landscape' : False , 'displayHeaderFooter' : False , 'printBackground' : True , 'preferCSSPageSize' : True , 'marginTop' : 0 , 'marginBottom' : 0 } data = self . _webdriver_command ( \"print\" , print_options ) bytes_file = base64 . b64decode ( data ) if not path : path = default_path with open ( path , \"wb\" ) as f : f . write ( bytes_file ) return path def wait_for_downloads ( self , timeout : int = 120000 ): \"\"\" Wait for all downloads to be finished. Beware that this method replaces the current page with the downloads window. Args: timeout (int, optional): Timeout in millis. Defaults to 120000. \"\"\" wait_method = BROWSER_CONFIGS . get ( self . browser ) . get ( \"wait_for_downloads\" ) # waits for all the files to be completed WebDriverWait ( self . _driver , timeout / 1000 , 1 ) . until ( wait_method ) def find_elements ( self , selector : str , by : By = By . CSS_SELECTOR ) -> List [ WebElement ]: \"\"\"Find elements using the specified selector with selector type specified by `by`. Args: selector (str): The selector string to be used. by (str, optional): Selector type. Defaults to By.CSS_SELECTOR. [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By) Returns: List[WebElement]: List of elements found. **Example:** ```python from botcity.web import By ... # Find element by ID all_cells = self.find_elements(\"//td\", By.XPATH) ... ``` \"\"\" return self . _driver . find_elements ( by , selector ) def find_element ( self , selector : str , by : str = By . CSS_SELECTOR ) -> WebElement : \"\"\"Find an element using the specified selector with selector type specified by `by`. If more than one element is found, the first instance is returned. Args: selector (str): The selector string to be used. by (str, optional): Selector type. Defaults to By.CSS_SELECTOR. [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By) Returns: WebElement: The element found. **Example:** ```python from botcity.web import By ... # Find element by ID elem = self.find_element(\"my_elem\", By.ID) # Find element by XPath elem = self.find_element(\"//input[@type='submit']\", By.XPATH) ... ``` \"\"\" out = self . find_elements ( selector = selector , by = by ) if out : return out [ 0 ] def set_file_input_element ( self , element : WebElement , filepath : str ): \"\"\"Configure the filepath for upload in a file element. Note: This method does not submit the form. Args: element (WebElement): The file upload element. filepath (str): The path to the file to be uploaded. **Example:** ```python ... # Find element elem = self.find_element(\"body > form > input[type=file]\") # Set the filepath self.set_file_input_element(elem, \"./test.txt\") ... ``` \"\"\" fpath = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( filepath ))) element . send_keys ( fpath ) def enter_iframe ( self , iframe : WebElement ): \"\"\"Switch the WebBot driver to the specified iframe. Args: iframe (WebElement): The desired iFrame. \"\"\" self . _driver . switch_to . frame ( iframe ) def leave_iframe ( self ): \"\"\"Leave the iframe and switch the WebBot driver to the default content. \"\"\" self . _driver . switch_to . default_content () ####### # Mouse ####### @only_if_element def click_on ( self , label ): \"\"\" Click on the element. Args: label (str): The image identifier \"\"\" x , y = self . get_element_coords_centered ( label ) self . click ( x , y ) @only_if_element def get_last_x ( self ): \"\"\" Get the last X position for the mouse. Returns: x (int): The last x position for the mouse. \"\"\" return self . _x def get_last_y ( self ): \"\"\" Get the last Y position for the mouse. Returns: y (int): The last y position for the mouse. \"\"\" return self . _y def mouse_move ( self , x , y ): \"\"\" Mouse the move to the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" if self . browser == Browser . FIREFOX : # Reset coordinates if the page has gone stale. Only required for Firefox if self . _html_elem is None : self . _html_elem = self . _driver . find_element_by_tag_name ( 'body' ) self . _x = 0 self . _y = 0 else : try : self . _html_elem . is_enabled () except StaleElementReferenceException : self . _html_elem = self . _driver . find_element_by_tag_name ( 'body' ) self . _x = 0 self . _y = 0 mx = x - self . _x my = y - self . _y self . _x = x self . _y = y ActionChains ( self . _driver ) . move_by_offset ( mx , my ) . perform () def click_at ( self , x , y , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" self . mouse_move ( x , y ) ac = ActionChains ( self . _driver ) for i in range ( clicks ): if button == 'left' : ac . click () elif button == 'right' : ac . context_click () else : raise ValueError ( 'Invalid value for button. Accepted values are left or right.' ) ac . pause ( interval_between_clicks / 1000.0 ) ac . perform () @only_if_element def click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" x , y = self . state . center () self . click_at ( x , y , clicks = clicks , button = button , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) @only_if_element def click_relative ( self , x , y , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" x = self . state . x () + x y = self . state . y () + y self . click_at ( x , y , clicks = clicks , button = button , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) @only_if_element def double_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( interval_between_clicks = wait_after , clicks = 2 ) @only_if_element def double_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 2 , interval_between_clicks = interval_between_clicks ) @only_if_element def triple_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( wait_after = wait_after , clicks = 3 ) @only_if_element def triple_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 3 , interval_between_clicks = interval_between_clicks ) def mouse_down ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Holds down the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" ActionChains ( self . _driver ) . click_and_hold () . perform () self . sleep ( wait_after ) def mouse_up ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Releases the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" ActionChains ( self . _driver ) . release () . perform () self . sleep ( wait_after ) def scroll_down ( self , clicks ): \"\"\" Scroll Down n clicks Args: clicks (int): Number of times to scroll down. \"\"\" for i in range ( clicks ): self . _driver . execute_script ( \"window.scrollTo(0, window.scrollY + 200)\" ) self . sleep ( 200 ) def scroll_up ( self , clicks ): \"\"\" Scroll Up n clicks Args: clicks (int): Number of times to scroll up. \"\"\" for i in range ( clicks ): self . _driver . execute_script ( \"window.scrollTo(0, window.scrollY - 200)\" ) self . sleep ( 200 ) def move_to ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" self . mouse_move ( x , y ) @only_if_element def move ( self ): \"\"\" Move to the center position of last found item. \"\"\" x , y = self . state . center () self . move_to ( x , y ) def move_relative ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): Horizontal offset y (int): Vertical offset \"\"\" x = self . get_last_x () + x y = self . get_last_y () + y self . move_to ( x , y ) def move_random ( self , range_x , range_y ): \"\"\" Move randomly along the given x, y range. Args: range_x (int): Horizontal range range_y (int): Vertical range \"\"\" x = int ( random . random () * range_x ) y = int ( random . random () * range_y ) self . move_to ( x , y ) @only_if_element def right_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 ): \"\"\" Right click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. \"\"\" self . click ( clicks = clicks , button = 'right' , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) def right_click_at ( self , x , y ): \"\"\" Right click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" self . click_at ( x , y , button = 'right' ) @only_if_element def right_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Right Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , interval_between_clicks = interval_between_clicks , button = 'right' ) ########## # Keyboard ########## def kb_type ( self , text , interval = 0 ): \"\"\" Type a text char by char (individual key events). Args: text (str): text to be typed. interval (int, optional): interval (ms) between each key press. Defaults to 0 \"\"\" action = ActionChains ( self . _driver ) for c in text : action . send_keys ( c ) action . pause ( interval / 1000.0 ) action . perform () self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION ) def paste ( self , text = None , wait = 0 ): \"\"\" Paste content from the clipboard. Args: text (str, optional): The text to be pasted. Defaults to None wait (int, optional): Wait interval (ms) after task \"\"\" text_to_paste = self . _clipboard if text : text_to_paste = text self . kb_type ( text_to_paste ) def copy_to_clipboard ( self , text , wait = 0 ): \"\"\" Copy content to the clipboard. Args: text (str): The text to be copied. wait (int, optional): Wait interval (ms) after task \"\"\" self . _clipboard = text delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def tab ( self , wait = 0 ): \"\"\" Press key Tab Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . TAB ) action . key_up ( Keys . TAB ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ENTER ) action . key_up ( Keys . ENTER ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def key_right ( self , wait = 0 ): \"\"\" Press key Right Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_RIGHT ) action . key_up ( Keys . ARROW_RIGHT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def key_enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . enter ( wait ) def key_home ( self , wait = 0 ): \"\"\" Press key Home Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . HOME ) action . key_up ( Keys . HOME ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def key_end ( self , wait = 0 ): \"\"\" Press key End Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . END ) action . key_up ( Keys . END ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def page_up ( self , wait = 0 ): \"\"\" Press Page Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . PAGE_UP ) action . key_up ( Keys . PAGE_UP ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def page_down ( self , wait = 0 ): \"\"\" Press Page Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . PAGE_DOWN ) action . key_up ( Keys . PAGE_DOWN ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def key_esc ( self , wait = 0 ): \"\"\" Press key Esc Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ESCAPE ) action . key_up ( Keys . ESCAPE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def _key_fx ( self , idx , wait = 0 ): \"\"\" Press key Fidx where idx is a value from 1 to 12 Args: idx (int): F key index from 1 to 12 wait (int, optional): Wait interval (ms) after task \"\"\" if idx < 1 or idx > 12 : raise ValueError ( \"Only F1 to F12 allowed.\" ) action = ActionChains ( self . _driver ) key = getattr ( Keys , f \"F { idx } \" ) action . key_down ( key ) action . key_up ( key ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def hold_shift ( self , wait = 0 ): \"\"\" Hold key Shift Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . SHIFT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def release_shift ( self ): \"\"\" Release key Shift. This method needs to be invoked after holding Shift or similar. \"\"\" action = ActionChains ( self . _driver ) action . key_up ( Keys . SHIFT ) action . perform () def maximize_window ( self ): \"\"\" Shortcut to maximize window on Windows OS. \"\"\" # TODO: Understand the complications associated with maximizing the browser and the resolution self . _driver . maximize_window () def type_keys_with_interval ( self , interval , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: interval (int): Interval (ms) in which to press and release keys keys (list): List of Keys to be pressed \"\"\" action = ActionChains ( self . _driver ) for k in keys : action . key_down ( k ) action . pause ( interval / 1000.0 ) for k in reversed ( keys ): action . key_up ( k ) action . pause ( interval / 1000.0 ) action . perform () def type_keys ( self , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: keys (list): List of keys to be pressed \"\"\" self . type_keys_with_interval ( 100 , keys ) def control_c ( self , wait = 0 ): \"\"\" Press keys CTRL+C Args: wait (int, optional): Wait interval (ms) after task \"\"\" # Firefox can't do window.getSelection() and return a proper value when the selected text # is in an input of similar. While Firefox doesn't get its shit together we apply this # ugly alternative so control+c works for \"all\" browsers tested so far. cmd = \"\"\" try { return document.activeElement.value.substring( document.activeElement.selectionStart, document.activeElement.selectionEnd ); } catch(error) { return window.getSelection().toString(); } \"\"\" self . _clipboard = self . execute_javascript ( cmd ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def control_v ( self , wait = 0 ): \"\"\" Press keys CTRL+V Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . paste () def control_a ( self , wait = 0 ): \"\"\" Press keys CTRL+A Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) key = Keys . CONTROL if platform . system () == 'Darwin' : key = Keys . COMMAND action . key_down ( key ) action . send_keys ( 'a' ) action . key_up ( key ) action . perform () def get_clipboard ( self ): \"\"\" Get the current content in the clipboard. Returns: text (str): Current clipboard content \"\"\" return self . _clipboard def type_left ( self , wait = 0 ): \"\"\" Press Left key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_LEFT ) action . key_up ( Keys . ARROW_LEFT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def type_right ( self , wait = 0 ): \"\"\" Press Right key Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . key_right ( wait = wait ) def type_down ( self , wait = 0 ): \"\"\" Press Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_DOWN ) action . key_up ( Keys . ARROW_DOWN ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def type_up ( self , wait = 0 ): \"\"\" Press Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_UP ) action . key_up ( Keys . ARROW_UP ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def space ( self , wait = 0 ): \"\"\" Press Space key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . SPACE ) action . key_up ( Keys . SPACE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def backspace ( self , wait = 0 ): \"\"\" Press Backspace key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . BACK_SPACE ) action . key_up ( Keys . BACK_SPACE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def delete ( self , wait = 0 ): \"\"\" Press Delete key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . DELETE ) action . key_up ( Keys . DELETE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) ###### # Misc ###### def wait ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" time . sleep ( interval / 1000.0 ) def sleep ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" self . wait ( interval ) def wait_for_file ( self , path , timeout = 60000 ): \"\"\" Wait for a file to be available on disk. Args: path (str): The path for the file to be executed timeout (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 60000ms (60s). Returns: status (bool): Whether or not the file was available before the timeout \"\"\" path = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( path ))) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > timeout : return False if os . path . isfile ( path ) and os . access ( path , os . R_OK ): if self . browser == Browser . FIREFOX and os . path . exists ( path + '.part' ): # if *.part exists, the download is not completed. continue return True self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION ) browser property writable The web browser to be used. Returns: Type Description browser (Browser) The web browser to be used. capabilities property writable The capabilities to be passed down to the WebDriver when starting the browser. Returns: Type Description capabilities (Dict) The browser specific capabilities to be used. driver property readonly The WebDriver driver instance. Returns: Type Description driver (WebDriver) The WebDriver driver instance. headless property writable Controls whether or not the bot will run headless. Returns: Type Description headless (bool) Whether or not to run the browser on headless mode. options property writable The options to be passed down to the WebDriver when starting the browser. Returns: Type Description options (Options) The browser specific options to be used. activate_tab ( self , handle ) Activate a tab given by the handle. Parameters: Name Type Description Default handle str The tab or window handle. required Source code in web/bot.py def activate_tab ( self , handle ): \"\"\"Activate a tab given by the handle. Args: handle (str): The tab or window handle. \"\"\" self . _driver . switch_to . window ( handle ) add_image ( self , label , path ) Add an image into the state image map. Parameters: Name Type Description Default label str The image identifier required path str The path for the image on disk required Source code in web/bot.py def add_image ( self , label , path ): \"\"\" Add an image into the state image map. Args: label (str): The image identifier path (str): The path for the image on disk \"\"\" self . state . map_images [ label ] = path backspace ( self , wait = 0 ) Press Backspace key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def backspace ( self , wait = 0 ): \"\"\" Press Backspace key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . BACK_SPACE ) action . key_up ( Keys . BACK_SPACE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) browse ( self , url ) Opens the browser on the given URL. Parameters: Name Type Description Default url str The URL to be visited. required Source code in web/bot.py def browse ( self , url ): \"\"\" Opens the browser on the given URL. Args: url (str): The URL to be visited. \"\"\" self . navigate_to ( url ) click ( self , wait_after = 300 , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ) Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right'. Defaults to 'left' 'left' Source code in web/bot.py @only_if_element def click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" x , y = self . state . center () self . click_at ( x , y , clicks = clicks , button = button , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) click_at ( self , x , y , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ) Click at the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right'. Defaults to 'left' 'left' Source code in web/bot.py def click_at ( self , x , y , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" self . mouse_move ( x , y ) ac = ActionChains ( self . _driver ) for i in range ( clicks ): if button == 'left' : ac . click () elif button == 'right' : ac . context_click () else : raise ValueError ( 'Invalid value for button. Accepted values are left or right.' ) ac . pause ( interval_between_clicks / 1000.0 ) ac . perform () click_on ( self , label ) Click on the element. Parameters: Name Type Description Default label str The image identifier required Source code in web/bot.py @only_if_element def click_on ( self , label ): \"\"\" Click on the element. Args: label (str): The image identifier \"\"\" x , y = self . get_element_coords_centered ( label ) self . click ( x , y ) click_relative ( self , x , y , wait_after = 300 , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ) Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right'. Defaults to 'left' 'left' Source code in web/bot.py @only_if_element def click_relative ( self , x , y , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" x = self . state . x () + x y = self . state . y () + y self . click_at ( x , y , clicks = clicks , button = button , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) close_page ( self ) Close the current active page (tab or window). Source code in web/bot.py def close_page ( self ): \"\"\"Close the current active page (tab or window). \"\"\" try : self . _driver . close () # If it was the last tab we can't switch tabs = self . get_tabs () if tabs : self . _driver . switch_to . window ( tabs [ - 1 ]) except InvalidSessionIdException : pass control_a ( self , wait = 0 ) Press keys CTRL+A Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def control_a ( self , wait = 0 ): \"\"\" Press keys CTRL+A Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) key = Keys . CONTROL if platform . system () == 'Darwin' : key = Keys . COMMAND action . key_down ( key ) action . send_keys ( 'a' ) action . key_up ( key ) action . perform () control_c ( self , wait = 0 ) Press keys CTRL+C Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def control_c ( self , wait = 0 ): \"\"\" Press keys CTRL+C Args: wait (int, optional): Wait interval (ms) after task \"\"\" # Firefox can't do window.getSelection() and return a proper value when the selected text # is in an input of similar. While Firefox doesn't get its shit together we apply this # ugly alternative so control+c works for \"all\" browsers tested so far. cmd = \"\"\" try { return document.activeElement.value.substring( document.activeElement.selectionStart, document.activeElement.selectionEnd ); } catch(error) { return window.getSelection().toString(); } \"\"\" self . _clipboard = self . execute_javascript ( cmd ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_v ( self , wait = 0 ) Press keys CTRL+V Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def control_v ( self , wait = 0 ): \"\"\" Press keys CTRL+V Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . paste () copy_to_clipboard ( self , text , wait = 0 ) Copy content to the clipboard. Parameters: Name Type Description Default text str The text to be copied. required wait int Wait interval (ms) after task 0 Source code in web/bot.py def copy_to_clipboard ( self , text , wait = 0 ): \"\"\" Copy content to the clipboard. Args: text (str): The text to be copied. wait (int, optional): Wait interval (ms) after task \"\"\" self . _clipboard = text delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) create_tab ( self , url ) Create a new tab and navigate to the given URL. Parameters: Name Type Description Default url str The desired URL. required Source code in web/bot.py def create_tab ( self , url ): \"\"\"Create a new tab and navigate to the given URL. Args: url (str): The desired URL. \"\"\" try : # Refactor this when Selenium 4 is released self . execute_javascript ( f \"window.open(' { url } ', '_blank');\" ) self . _driver . switch_to . window ( self . get_tabs ()[ - 1 ]) except InvalidSessionIdException : self . navigate_to ( url ) create_window ( self , url ) Creates a new window with the given URL. Parameters: Name Type Description Default url str The desired URL. required Source code in web/bot.py def create_window ( self , url ): \"\"\"Creates a new window with the given URL. Args: url (str): The desired URL. \"\"\" try : # Refactor this when Selenium 4 is released self . execute_javascript ( f \"window.open(' { url } ', '_blank', 'location=0');\" ) self . _driver . switch_to . window ( self . get_tabs ()[ - 1 ]) except InvalidSessionIdException : self . navigate_to ( url ) delete ( self , wait = 0 ) Press Delete key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def delete ( self , wait = 0 ): \"\"\" Press Delete key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . DELETE ) action . key_up ( Keys . DELETE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) display_size ( self ) Returns the display size in pixels. Returns: Type Description size (Tuple) The screen dimension (width and height) in pixels. Source code in web/bot.py def display_size ( self ): \"\"\" Returns the display size in pixels. Returns: size (Tuple): The screen dimension (width and height) in pixels. \"\"\" return self . _dimensions double_click ( self , wait_after = 300 ) Double Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def double_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( interval_between_clicks = wait_after , clicks = 2 ) double_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = 300 ) Double Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def double_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 2 , interval_between_clicks = interval_between_clicks ) enter ( self , wait = 0 ) Press key Enter Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ENTER ) action . key_up ( Keys . ENTER ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) enter_iframe ( self , iframe ) Switch the WebBot driver to the specified iframe. Parameters: Name Type Description Default iframe WebElement The desired iFrame. required Source code in web/bot.py def enter_iframe ( self , iframe : WebElement ): \"\"\"Switch the WebBot driver to the specified iframe. Args: iframe (WebElement): The desired iFrame. \"\"\" self . _driver . switch_to . frame ( iframe ) execute_javascript ( self , code ) Execute the given javascript code. Parameters: Name Type Description Default code str The code to be executed. required Returns: Type Description value (object) Returns the code output or None if not available or if an error happens. Source code in web/bot.py def execute_javascript ( self , code ): \"\"\" Execute the given javascript code. Args: code (str): The code to be executed. Returns: value (object): Returns the code output or None if not available or if an error happens. \"\"\" return self . _driver . execute_script ( code ) find ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ) Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in web/bot.py def find ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label = label , x = x , y = y , width = width , height = height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = grayscale ) find_all ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , grayscale = False , as_list = False ) Find all elements defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False as_list bool, Optional If True, returns a list of element coordinates instead of a generator. Use set_active_element() to be able to interact with the found elements. This parameter must be True if you intend to run multiple find_all() concurrently. Defaults to False. False Returns: Type Description elements (collections.Iterable[NamedTuple]) A generator with all element coordinates found. None if not found. Source code in web/bot.py def find_all ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , grayscale = False , as_list : bool = False ): \"\"\" Find all elements defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. as_list (bool, Optional): If True, returns a list of element coordinates instead of a generator. Use set_active_element() to be able to interact with the found elements. This parameter must be True if you intend to run multiple find_all() concurrently. Defaults to False. Returns: elements (collections.Iterable[NamedTuple]): A generator with all element coordinates found. None if not found. \"\"\" def deduplicate ( elems ): def find_same ( item , items ): x_start = item . left x_end = item . left + item . width y_start = item . top y_end = item . top + item . height similars = [] for itm in items : if itm == item : continue if ( itm . left >= x_start and itm . left < x_end ) \\ and ( itm . top >= y_start and itm . top < y_end ): similars . append ( itm ) continue return similars index = 0 while True : try : dups = find_same ( elems [ index ], elems [ index :]) for d in dups : elems . remove ( d ) index += 1 except IndexError : break return elems self . state . element = None screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( element_path , haystack_image = haystack , region = region , confidence = matching , grayscale = grayscale ) eles = [ ele for ele in it ] if not eles : continue eles = deduplicate ( list ( eles )) # As List if as_list : return eles # As Generator for ele in eles : if ele is not None : self . state . element = ele yield ele break find_element ( self , selector , by = 'css selector' ) Find an element using the specified selector with selector type specified by by . If more than one element is found, the first instance is returned. Parameters: Name Type Description Default selector str The selector string to be used. required by str Selector type. Defaults to By.CSS_SELECTOR. See more 'css selector' Returns: Type Description WebElement The element found. Example: from botcity.web import By ... # Find element by ID elem = self . find_element ( \"my_elem\" , By . ID ) # Find element by XPath elem = self . find_element ( \"//input[@type='submit']\" , By . XPATH ) ... Source code in web/bot.py def find_element ( self , selector : str , by : str = By . CSS_SELECTOR ) -> WebElement : \"\"\"Find an element using the specified selector with selector type specified by `by`. If more than one element is found, the first instance is returned. Args: selector (str): The selector string to be used. by (str, optional): Selector type. Defaults to By.CSS_SELECTOR. [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By) Returns: WebElement: The element found. **Example:** ```python from botcity.web import By ... # Find element by ID elem = self.find_element(\"my_elem\", By.ID) # Find element by XPath elem = self.find_element(\"//input[@type='submit']\", By.XPATH) ... ``` \"\"\" out = self . find_elements ( selector = selector , by = by ) if out : return out [ 0 ] find_elements ( self , selector , by = 'css selector' ) Find elements using the specified selector with selector type specified by by . Parameters: Name Type Description Default selector str The selector string to be used. required by str Selector type. Defaults to By.CSS_SELECTOR. See more 'css selector' Returns: Type Description List[WebElement] List of elements found. Example: from botcity.web import By ... # Find element by ID all_cells = self . find_elements ( \"//td\" , By . XPATH ) ... Source code in web/bot.py def find_elements ( self , selector : str , by : By = By . CSS_SELECTOR ) -> List [ WebElement ]: \"\"\"Find elements using the specified selector with selector type specified by `by`. Args: selector (str): The selector string to be used. by (str, optional): Selector type. Defaults to By.CSS_SELECTOR. [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By) Returns: List[WebElement]: List of elements found. **Example:** ```python from botcity.web import By ... # Find element by ID all_cells = self.find_elements(\"//td\", By.XPATH) ... ``` \"\"\" return self . _driver . find_elements ( by , selector ) find_multiple ( self , labels , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ) Find multiple elements defined by label on screen until a timeout happens. Parameters: Name Type Description Default labels list A list of image identifiers required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description results (dict) A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. Source code in web/bot.py def find_multiple ( self , labels , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find multiple elements defined by label on screen until a timeout happens. Args: labels (list): A list of image identifiers x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: results (dict): A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. \"\"\" def _to_dict ( lbs , elems ): return { k : v for k , v in zip ( lbs , elems )} screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) results = [ None ] * len ( labels ) paths = [ self . _search_image_file ( la ) for la in labels ] if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () n_cpus = multiprocessing . cpu_count () - 1 while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return _to_dict ( labels , results ) haystack = self . screenshot () helper = functools . partial ( self . _find_multiple_helper , haystack , region , matching , grayscale ) with multiprocessing . Pool ( processes = n_cpus ) as pool : results = pool . map ( helper , paths ) results = [ r for r in results ] if None in results : continue else : return _to_dict ( labels , results ) find_text ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True ) Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in web/bot.py def find_text ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label , x , y , width , height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = True ) find_until ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ) Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in web/bot.py def find_until ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" self . state . element = None screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( element_path , haystack_image = haystack , region = region , confidence = matching , grayscale = grayscale ) try : ele = next ( it ) except StopIteration : ele = None if ele is not None : self . state . element = ele return ele get_clipboard ( self ) Get the current content in the clipboard. Returns: Type Description text (str) Current clipboard content Source code in web/bot.py def get_clipboard ( self ): \"\"\" Get the current content in the clipboard. Returns: text (str): Current clipboard content \"\"\" return self . _clipboard get_element_coords ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ) Find an element defined by label on screen and returns its coordinates. Parameters: Name Type Description Default label str The image identifier required x int X (Left) coordinate of the search area. None y int Y (Top) coordinate of the search area. None width int Width of the search area. None height int Height of the search area. None matching float Minimum score to consider a match in the element image recognition process. Defaults to 0.9. 0.9 best bool Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. True Returns: Type Description coords (Tuple) A tuple containing the x and y coordinates for the element. Source code in web/bot.py def get_element_coords ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the element. \"\"\" self . state . element = None screen_size = self . _dimensions x = x or 0 y = y or 0 width = width or screen_size [ 0 ] height = height or screen_size [ 1 ] region = ( x , y , width , height ) if not best : print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( self . state . map_images [ label ], haystack_image = haystack , region = region , confidence = matching ) try : ele = next ( it ) except StopIteration : ele = None self . state . element = ele if ele : return ele . left , ele . top else : return None , None get_element_coords_centered ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ) Find an element defined by label on screen and returns its centered coordinates. Parameters: Name Type Description Default label str The image identifier required x int X (Left) coordinate of the search area. None y int Y (Top) coordinate of the search area. None width int Width of the search area. None height int Height of the search area. None matching float Minimum score to consider a match in the element image recognition process. Defaults to 0.9. 0.9 best bool Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. True Returns: Type Description coords (Tuple) A tuple containing the x and y coordinates for the center of the element. Source code in web/bot.py def get_element_coords_centered ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its centered coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the center of the element. \"\"\" self . get_element_coords ( label , x , y , width , height , matching , best ) return self . state . center () get_image_from_map ( self , label ) Return an image from teh state image map. Parameters: Name Type Description Default label str The image identifier required Returns: Type Description Image The Image object Source code in web/bot.py def get_image_from_map ( self , label ): \"\"\" Return an image from teh state image map. Args: label (str): The image identifier Returns: Image: The Image object \"\"\" path = self . state . map_images . get ( label ) if not path : raise KeyError ( 'Invalid label for image map.' ) img = Image . open ( path ) return img get_js_dialog ( self ) Return the last found dialog. Invoke first the find_js_dialog method to look up. Returns: Type Description dialog (dict) The dialog information or None if not available. See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening Source code in web/bot.py def get_js_dialog ( self ): \"\"\" Return the last found dialog. Invoke first the `find_js_dialog` method to look up. Returns: dialog (dict): The dialog information or None if not available. See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening \"\"\" try : dialog = self . _driver . switch_to . alert return dialog except Exception : return None get_last_element ( self ) Return the last element found. Returns: Type Description element (NamedTuple) The element coordinates (left, top, width, height) Source code in web/bot.py def get_last_element ( self ): \"\"\" Return the last element found. Returns: element (NamedTuple): The element coordinates (left, top, width, height) \"\"\" return self . state . element get_last_x ( self ) Get the last X position for the mouse. Returns: Type Description x (int) The last x position for the mouse. Source code in web/bot.py @only_if_element def get_last_x ( self ): \"\"\" Get the last X position for the mouse. Returns: x (int): The last x position for the mouse. \"\"\" return self . _x get_last_y ( self ) Get the last Y position for the mouse. Returns: Type Description y (int) The last y position for the mouse. Source code in web/bot.py def get_last_y ( self ): \"\"\" Get the last Y position for the mouse. Returns: y (int): The last y position for the mouse. \"\"\" return self . _y get_screen_image ( self , region = None ) Capture and returns a screenshot from the browser. Parameters: Name Type Description Default region tuple A tuple containing the left, top, width and height to crop the screen image. None Returns: Type Description image (Image) The screenshot Image object. Source code in web/bot.py def get_screen_image ( self , region = None ): \"\"\" Capture and returns a screenshot from the browser. Args: region (tuple): A tuple containing the left, top, width and height to crop the screen image. Returns: image (Image): The screenshot Image object. \"\"\" if not region : region = ( 0 , 0 , 0 , 0 ) x = region [ 0 ] or 0 y = region [ 1 ] or 0 width = region [ 2 ] or self . _dimensions [ 0 ] height = region [ 3 ] or self . _dimensions [ 1 ] data = self . _driver . get_screenshot_as_base64 () image_data = base64 . b64decode ( data ) img = Image . open ( io . BytesIO ( image_data )) img = img . crop (( x , y , x + width , y + height )) return img get_screenshot ( self , filepath = None , region = None ) Capture a screenshot. Parameters: Name Type Description Default filepath str The filepath in which to save the screenshot. Defaults to None. None region tuple Bounding box containing left, top, width and height to crop screenshot. None Returns: Type Description Image The screenshot Image object Source code in web/bot.py def get_screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" return self . screenshot ( filepath , region ) get_tabs ( self ) Get a list of tab handlers Returns: Type Description list List of tab handlers Source code in web/bot.py def get_tabs ( self ): \"\"\"Get a list of tab handlers Returns: list: List of tab handlers \"\"\" try : return self . _driver . window_handles except InvalidSessionIdException : return [] get_viewport_size ( self ) Returns the browser current viewport size. Returns: Type Description width (int) The current viewport width. height (int): The current viewport height. Source code in web/bot.py def get_viewport_size ( self ): \"\"\" Returns the browser current viewport size. Returns: width (int): The current viewport width. height (int): The current viewport height. \"\"\" # Access each dimension individually width = self . _driver . get_window_size () . get ( \"width\" ) height = self . _driver . get_window_size () . get ( \"height\" ) return width , height handle_js_dialog ( self , accept = True , prompt_text = None ) Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). This also cleans the dialog information in the local buffer. Parameters: Name Type Description Default accept bool Whether to accept or dismiss the dialog. True prompt_text str The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog. None Source code in web/bot.py def handle_js_dialog ( self , accept = True , prompt_text = None ): \"\"\" Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). This also cleans the dialog information in the local buffer. Args: accept (bool): Whether to accept or dismiss the dialog. prompt_text (str): The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog. \"\"\" dialog = self . get_js_dialog () if not dialog : # TODO: Maybe we should raise an exception here if no alert available return if prompt_text is not None : dialog . send_keys ( prompt_text ) if accept : dialog . accept () else : dialog . dismiss () hold_shift ( self , wait = 0 ) Hold key Shift Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def hold_shift ( self , wait = 0 ): \"\"\" Hold key Shift Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . SHIFT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) kb_type ( self , text , interval = 0 ) Type a text char by char (individual key events). Parameters: Name Type Description Default text str text to be typed. required interval int interval (ms) between each key press. Defaults to 0 0 Source code in web/bot.py def kb_type ( self , text , interval = 0 ): \"\"\" Type a text char by char (individual key events). Args: text (str): text to be typed. interval (int, optional): interval (ms) between each key press. Defaults to 0 \"\"\" action = ActionChains ( self . _driver ) for c in text : action . send_keys ( c ) action . pause ( interval / 1000.0 ) action . perform () self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION ) key_end ( self , wait = 0 ) Press key End Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_end ( self , wait = 0 ): \"\"\" Press key End Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . END ) action . key_up ( Keys . END ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) key_enter ( self , wait = 0 ) Press key Enter Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . enter ( wait ) key_esc ( self , wait = 0 ) Press key Esc Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_esc ( self , wait = 0 ): \"\"\" Press key Esc Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ESCAPE ) action . key_up ( Keys . ESCAPE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) key_home ( self , wait = 0 ) Press key Home Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_home ( self , wait = 0 ): \"\"\" Press key Home Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . HOME ) action . key_up ( Keys . HOME ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) key_right ( self , wait = 0 ) Press key Right Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_right ( self , wait = 0 ): \"\"\" Press key Right Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_RIGHT ) action . key_up ( Keys . ARROW_RIGHT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) leave_iframe ( self ) Leave the iframe and switch the WebBot driver to the default content. Source code in web/bot.py def leave_iframe ( self ): \"\"\"Leave the iframe and switch the WebBot driver to the default content. \"\"\" self . _driver . switch_to . default_content () maximize_window ( self ) Shortcut to maximize window on Windows OS. Source code in web/bot.py def maximize_window ( self ): \"\"\" Shortcut to maximize window on Windows OS. \"\"\" # TODO: Understand the complications associated with maximizing the browser and the resolution self . _driver . maximize_window () mouse_down ( self , wait_after = 300 , * , button = 'left' ) Holds down the requested mouse button. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in web/bot.py def mouse_down ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Holds down the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" ActionChains ( self . _driver ) . click_and_hold () . perform () self . sleep ( wait_after ) mouse_move ( self , x , y ) Mouse the move to the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in web/bot.py def mouse_move ( self , x , y ): \"\"\" Mouse the move to the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" if self . browser == Browser . FIREFOX : # Reset coordinates if the page has gone stale. Only required for Firefox if self . _html_elem is None : self . _html_elem = self . _driver . find_element_by_tag_name ( 'body' ) self . _x = 0 self . _y = 0 else : try : self . _html_elem . is_enabled () except StaleElementReferenceException : self . _html_elem = self . _driver . find_element_by_tag_name ( 'body' ) self . _x = 0 self . _y = 0 mx = x - self . _x my = y - self . _y self . _x = x self . _y = y ActionChains ( self . _driver ) . move_by_offset ( mx , my ) . perform () mouse_up ( self , wait_after = 300 , * , button = 'left' ) Releases the requested mouse button. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in web/bot.py def mouse_up ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Releases the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" ActionChains ( self . _driver ) . release () . perform () self . sleep ( wait_after ) move ( self ) Move to the center position of last found item. Source code in web/bot.py @only_if_element def move ( self ): \"\"\" Move to the center position of last found item. \"\"\" x , y = self . state . center () self . move_to ( x , y ) move_random ( self , range_x , range_y ) Move randomly along the given x, y range. Parameters: Name Type Description Default range_x int Horizontal range required range_y int Vertical range required Source code in web/bot.py def move_random ( self , range_x , range_y ): \"\"\" Move randomly along the given x, y range. Args: range_x (int): Horizontal range range_y (int): Vertical range \"\"\" x = int ( random . random () * range_x ) y = int ( random . random () * range_y ) self . move_to ( x , y ) move_relative ( self , x , y ) Move the mouse relative to its current position. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required Source code in web/bot.py def move_relative ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): Horizontal offset y (int): Vertical offset \"\"\" x = self . get_last_x () + x y = self . get_last_y () + y self . move_to ( x , y ) move_to ( self , x , y ) Move the mouse relative to its current position. Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in web/bot.py def move_to ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" self . mouse_move ( x , y ) navigate_to ( self , url , is_retry = False ) Opens the browser on the given URL. Parameters: Name Type Description Default url str The URL to be visited. required is_retry bool Whether or not this is a retry attempt. False Source code in web/bot.py def navigate_to ( self , url , is_retry = False ): \"\"\" Opens the browser on the given URL. Args: url (str): The URL to be visited. is_retry (bool): Whether or not this is a retry attempt. \"\"\" self . _x = 0 self . _y = 0 if not self . _driver : self . start_browser () try : self . _driver . get ( url ) except InvalidSessionIdException : if not is_retry : self . stop_browser () self . navigate_to ( url , is_retry = True ) page_down ( self , wait = 0 ) Press Page Down key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def page_down ( self , wait = 0 ): \"\"\" Press Page Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . PAGE_DOWN ) action . key_up ( Keys . PAGE_DOWN ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) page_source ( self ) Returns the active page source. Returns: Type Description soup (BeautifulSoup) BeautifulSoup object for the page source. Source code in web/bot.py def page_source ( self ): \"\"\" Returns the active page source. Returns: soup (BeautifulSoup): BeautifulSoup object for the page source. \"\"\" try : soup = BeautifulSoup ( self . _driver . page_source , 'html.parser' ) return soup except InvalidSessionIdException : return None page_title ( self ) Returns the active page title. Returns: Type Description title (str) The page title. Source code in web/bot.py def page_title ( self ): \"\"\" Returns the active page title. Returns: title (str): The page title. \"\"\" try : return self . _driver . title except InvalidSessionIdException : return None page_up ( self , wait = 0 ) Press Page Up key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def page_up ( self , wait = 0 ): \"\"\" Press Page Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . PAGE_UP ) action . key_up ( Keys . PAGE_UP ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) paste ( self , text = None , wait = 0 ) Paste content from the clipboard. Parameters: Name Type Description Default text str The text to be pasted. Defaults to None None wait int Wait interval (ms) after task 0 Source code in web/bot.py def paste ( self , text = None , wait = 0 ): \"\"\" Paste content from the clipboard. Args: text (str, optional): The text to be pasted. Defaults to None wait (int, optional): Wait interval (ms) after task \"\"\" text_to_paste = self . _clipboard if text : text_to_paste = text self . kb_type ( text_to_paste ) print_pdf ( self , path = None , print_options = None ) Print the current page as a PDF file. Parameters: Name Type Description Default path str The path for the file to be saved. Defaults to None. None print_options dict Print options as defined at. Defaults to None. None Returns: Type Description str the saved file path Source code in web/bot.py def print_pdf ( self , path = None , print_options = None ): \"\"\"Print the current page as a PDF file. Args: path (str, optional): The path for the file to be saved. Defaults to None. print_options (dict, optional): Print options as defined at. Defaults to None. Returns: str: the saved file path \"\"\" title = self . page_title () or \"document\" timeout = 60000 if not self . page_title (): timeout = 1000 default_path = os . path . expanduser ( os . path . join ( self . download_folder_path , f \" { title } .pdf\" )) if self . browser in [ Browser . CHROME , Browser . EDGE ] and not self . headless : # Chrome still does not support headless webdriver print # but Firefox does. self . execute_javascript ( \"window.print();\" ) # We need to wait for the file to be available in this case. self . wait_for_file ( default_path , timeout = timeout ) return default_path if print_options is None : print_options = { 'landscape' : False , 'displayHeaderFooter' : False , 'printBackground' : True , 'preferCSSPageSize' : True , 'marginTop' : 0 , 'marginBottom' : 0 } data = self . _webdriver_command ( \"print\" , print_options ) bytes_file = base64 . b64decode ( data ) if not path : path = default_path with open ( path , \"wb\" ) as f : f . write ( bytes_file ) return path release_shift ( self ) Release key Shift. This method needs to be invoked after holding Shift or similar. Source code in web/bot.py def release_shift ( self ): \"\"\" Release key Shift. This method needs to be invoked after holding Shift or similar. \"\"\" action = ActionChains ( self . _driver ) action . key_up ( Keys . SHIFT ) action . perform () right_click ( self , wait_after = 300 , * , clicks = 1 , interval_between_clicks = 0 ) Right click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 Source code in web/bot.py @only_if_element def right_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 ): \"\"\" Right click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. \"\"\" self . click ( clicks = clicks , button = 'right' , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) right_click_at ( self , x , y ) Right click at the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in web/bot.py def right_click_at ( self , x , y ): \"\"\" Right click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" self . click_at ( x , y , button = 'right' ) right_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = 300 ) Right Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def right_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Right Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , interval_between_clicks = interval_between_clicks , button = 'right' ) save_screenshot ( self , path ) Saves a screenshot in a given path. Parameters: Name Type Description Default path str The filepath in which to save the screenshot required Source code in web/bot.py def save_screenshot ( self , path ): \"\"\" Saves a screenshot in a given path. Args: path (str): The filepath in which to save the screenshot \"\"\" self . screenshot ( path ) screen_cut ( self , x , y , width = None , height = None ) Capture a screenshot from a region of the screen. Parameters: Name Type Description Default x int region start position x required y int region start position y required width int region width None height int region height None Returns: Type Description Image The screenshot Image object Source code in web/bot.py def screen_cut ( self , x , y , width = None , height = None ): \"\"\" Capture a screenshot from a region of the screen. Args: x (int): region start position x y (int): region start position y width (int): region width height (int): region height Returns: Image: The screenshot Image object \"\"\" screen_size = self . _dimensions x = x or 0 y = y or 0 width = width or screen_size [ 0 ] height = height or screen_size [ 1 ] img = self . screenshot ( region = ( x , y , width , height )) return img screenshot ( self , filepath = None , region = None ) Capture a screenshot. Parameters: Name Type Description Default filepath str The filepath in which to save the screenshot. Defaults to None. None region tuple Bounding box containing left, top, width and height to crop screenshot. None Returns: Type Description Image The screenshot Image object Source code in web/bot.py def screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" img = self . get_screen_image ( region ) if filepath : img . save ( filepath ) return img scroll_down ( self , clicks ) Scroll Down n clicks Parameters: Name Type Description Default clicks int Number of times to scroll down. required Source code in web/bot.py def scroll_down ( self , clicks ): \"\"\" Scroll Down n clicks Args: clicks (int): Number of times to scroll down. \"\"\" for i in range ( clicks ): self . _driver . execute_script ( \"window.scrollTo(0, window.scrollY + 200)\" ) self . sleep ( 200 ) scroll_up ( self , clicks ) Scroll Up n clicks Parameters: Name Type Description Default clicks int Number of times to scroll up. required Source code in web/bot.py def scroll_up ( self , clicks ): \"\"\" Scroll Up n clicks Args: clicks (int): Number of times to scroll up. \"\"\" for i in range ( clicks ): self . _driver . execute_script ( \"window.scrollTo(0, window.scrollY - 200)\" ) self . sleep ( 200 ) set_current_element ( self , element ) Changes the current screen element the bot will interact when using click(), move(), and similar methods. This method is equivalent to self.state.element = element. Parameters: Name Type Description Default element Box A screen element from self.state.element or the find_all(as_list=True) method. required Source code in web/bot.py def set_current_element ( self , element : cv2find . Box ): \"\"\" Changes the current screen element the bot will interact when using click(), move(), and similar methods. This method is equivalent to self.state.element = element. Args: element (Box): A screen element from self.state.element or the find_all(as_list=True) method. \"\"\" self . state . element = element set_file_input_element ( self , element , filepath ) Configure the filepath for upload in a file element. Note: This method does not submit the form. Parameters: Name Type Description Default element WebElement The file upload element. required filepath str The path to the file to be uploaded. required Example: ... # Find element elem = self . find_element ( \"body > form > input[type=file]\" ) # Set the filepath self . set_file_input_element ( elem , \"./test.txt\" ) ... Source code in web/bot.py def set_file_input_element ( self , element : WebElement , filepath : str ): \"\"\"Configure the filepath for upload in a file element. Note: This method does not submit the form. Args: element (WebElement): The file upload element. filepath (str): The path to the file to be uploaded. **Example:** ```python ... # Find element elem = self.find_element(\"body > form > input[type=file]\") # Set the filepath self.set_file_input_element(elem, \"./test.txt\") ... ``` \"\"\" fpath = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( filepath ))) element . send_keys ( fpath ) set_screen_resolution ( self , width = None , height = None ) Configures the browser dimensions. Parameters: Name Type Description Default width int The desired width. None height int The desired height. None Source code in web/bot.py def set_screen_resolution ( self , width = None , height = None ): \"\"\" Configures the browser dimensions. Args: width (int): The desired width. height (int): The desired height. \"\"\" self . _dimensions = ( width or 1600 , height or 900 ) if self . headless : # When running headless the window size is the viewport size window_size = self . _dimensions else : # When running non-headless we need to account for the borders and etc # So the size must be bigger to have the same viewport size as before window_size = self . _driver . execute_script ( \"\"\" return [window.outerWidth - window.innerWidth + arguments[0], window.outerHeight - window.innerHeight + arguments[1]]; \"\"\" , * self . _dimensions ) self . _driver . set_window_size ( * window_size ) sleep ( self , interval ) Wait / Sleep for a given interval. Parameters: Name Type Description Default interval int Interval in milliseconds required Source code in web/bot.py def sleep ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" self . wait ( interval ) space ( self , wait = 0 ) Press Space key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def space ( self , wait = 0 ): \"\"\" Press Space key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . SPACE ) action . key_up ( Keys . SPACE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) start_browser ( self ) Starts the selected browser. Source code in web/bot.py def start_browser ( self ): \"\"\" Starts the selected browser. \"\"\" def check_driver (): # Look for driver driver_name = BROWSER_CONFIGS . get ( self . browser ) . get ( \"driver\" ) location = shutil . which ( driver_name ) if not location : raise RuntimeError ( f \" { driver_name } was not found. Please make sure to have it on your PATH or set driver_path\" ) return location # Specific webdriver class for a given browser driver_class = BROWSER_CONFIGS . get ( self . browser ) . get ( \"class\" ) # Specific default options method for a given browser func_def_options = BROWSER_CONFIGS . get ( self . browser ) . get ( \"options\" ) # Specific capabilities method for a given browser func_def_capabilities = BROWSER_CONFIGS . get ( self . browser ) . get ( \"capabilities\" ) opt = self . options or func_def_options ( self . headless , self . _download_folder_path , None ) cap = self . capabilities or func_def_capabilities () self . options = opt self . capabilities = cap driver_path = self . driver_path or check_driver () self . driver_path = driver_path self . _driver = driver_class ( options = opt , desired_capabilities = cap , executable_path = driver_path ) self . set_screen_resolution () stop_browser ( self ) Stops the Chrome browser and clean up the User Data Directory. Source code in web/bot.py def stop_browser ( self ): \"\"\" Stops the Chrome browser and clean up the User Data Directory. \"\"\" if not self . _driver : return self . _driver . close () self . _driver . quit () self . _driver = None tab ( self , wait = 0 ) Press key Tab Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def tab ( self , wait = 0 ): \"\"\" Press key Tab Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . TAB ) action . key_up ( Keys . TAB ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) triple_click ( self , wait_after = 300 ) Triple Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def triple_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( wait_after = wait_after , clicks = 3 ) triple_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = 300 ) Triple Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def triple_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 3 , interval_between_clicks = interval_between_clicks ) type_down ( self , wait = 0 ) Press Down key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def type_down ( self , wait = 0 ): \"\"\" Press Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_DOWN ) action . key_up ( Keys . ARROW_DOWN ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) type_keys ( self , keys ) Press a sequence of keys. Hold the keys in the specific order and releases them. Parameters: Name Type Description Default keys list List of keys to be pressed required Source code in web/bot.py def type_keys ( self , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: keys (list): List of keys to be pressed \"\"\" self . type_keys_with_interval ( 100 , keys ) type_keys_with_interval ( self , interval , keys ) Press a sequence of keys. Hold the keys in the specific order and releases them. Parameters: Name Type Description Default interval int Interval (ms) in which to press and release keys required keys list List of Keys to be pressed required Source code in web/bot.py def type_keys_with_interval ( self , interval , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: interval (int): Interval (ms) in which to press and release keys keys (list): List of Keys to be pressed \"\"\" action = ActionChains ( self . _driver ) for k in keys : action . key_down ( k ) action . pause ( interval / 1000.0 ) for k in reversed ( keys ): action . key_up ( k ) action . pause ( interval / 1000.0 ) action . perform () type_left ( self , wait = 0 ) Press Left key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def type_left ( self , wait = 0 ): \"\"\" Press Left key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_LEFT ) action . key_up ( Keys . ARROW_LEFT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) type_right ( self , wait = 0 ) Press Right key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def type_right ( self , wait = 0 ): \"\"\" Press Right key Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . key_right ( wait = wait ) type_up ( self , wait = 0 ) Press Up key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def type_up ( self , wait = 0 ): \"\"\" Press Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_UP ) action . key_up ( Keys . ARROW_UP ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) wait ( self , interval ) Wait / Sleep for a given interval. Parameters: Name Type Description Default interval int Interval in milliseconds required Source code in web/bot.py def wait ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" time . sleep ( interval / 1000.0 ) wait_for_downloads ( self , timeout = 120000 ) Wait for all downloads to be finished. Beware that this method replaces the current page with the downloads window. Parameters: Name Type Description Default timeout int Timeout in millis. Defaults to 120000. 120000 Source code in web/bot.py def wait_for_downloads ( self , timeout : int = 120000 ): \"\"\" Wait for all downloads to be finished. Beware that this method replaces the current page with the downloads window. Args: timeout (int, optional): Timeout in millis. Defaults to 120000. \"\"\" wait_method = BROWSER_CONFIGS . get ( self . browser ) . get ( \"wait_for_downloads\" ) # waits for all the files to be completed WebDriverWait ( self . _driver , timeout / 1000 , 1 ) . until ( wait_method ) wait_for_file ( self , path , timeout = 60000 ) Wait for a file to be available on disk. Parameters: Name Type Description Default path str The path for the file to be executed required timeout int Maximum wait time (ms) to search for a hit. Defaults to 60000ms (60s). 60000 Returns: Type Description status (bool) Whether or not the file was available before the timeout Source code in web/bot.py def wait_for_file ( self , path , timeout = 60000 ): \"\"\" Wait for a file to be available on disk. Args: path (str): The path for the file to be executed timeout (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 60000ms (60s). Returns: status (bool): Whether or not the file was available before the timeout \"\"\" path = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( path ))) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > timeout : return False if os . path . isfile ( path ) and os . access ( path , os . R_OK ): if self . browser == Browser . FIREFOX and os . path . exists ( path + '.part' ): # if *.part exists, the download is not completed. continue return True self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION )","title":"Framework"},{"location":"bot/#framework","text":"The botcity.web module contains specialized implementations aimed at Web automation such as WebBot which is described below. You are expected to implement the action method of the WebBot class in your Bot class. Here is a very brief example of a bot which opens the BotCity website using Google Chrome and the ChromeDriver WebDriver to remote control the browser. from botcity.web import WebBot class Bot ( WebBot ): def action ( self , execution = None # Configure whether or not to run on headless mode self . headless = False # Opens the BotCity website. self . browse ( \"https://botcity.dev/en\" ) # Wait for 10 seconds before closing everything self . sleep ( 10000 ) # Stop the browser and clean up self . stop_browser () if __name__ == '__main__' : Bot . main ()","title":"Framework"},{"location":"bot/#botcity.web.bot.WebBot","text":"Source code in web/bot.py class WebBot ( BaseBot ): KEYS = Keys \"\"\" Base class for Web Bots. Users must implement the `action` method in their classes. Attributes: state (State): The internal state of this bot. maestro (BotMaestroSDK): an instance to interact with the BotMaestro server. \"\"\" def __init__ ( self , headless = False ): self . state = State () self . maestro = BotMaestroSDK () if MAESTRO_AVAILABLE else None self . _browser = Browser . CHROME self . _options = None self . _capabilities = None self . _driver_path = None self . _driver = None self . _headless = headless self . _clipboard = \"\" # Stub mouse coordinates self . _html_elem = None self . _x = 0 self . _y = 0 # State for Key modifiers self . _shift_hold = False self . _dimensions = ( 1600 , 900 ) self . _download_folder_path = os . getcwd () @property def driver ( self ): \"\"\" The WebDriver driver instance. Returns: driver (WebDriver): The WebDriver driver instance. \"\"\" return self . _driver @property def driver_path ( self ): return self . _driver_path @driver_path . setter def driver_path ( self , driver_path ): \"\"\" The webdriver executable path. Args: driver_path (str): The full path to the proper webdriver path used for the selected browser. If set to None, the code will look into the PATH for the proper file when starting the browser. \"\"\" driver_path = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( driver_path ))) if driver_path and not os . path . isfile ( driver_path ): raise ValueError ( \"Invalid driver_path. The file does not exist.\" ) self . _driver_path = driver_path @property def browser ( self ): \"\"\" The web browser to be used. Returns: browser (Browser): The web browser to be used. \"\"\" return self . _browser @browser . setter def browser ( self , browser ): \"\"\" The web browser to be used. Args: browser (Browser): The name of web browser to be used from the Browser enum. \"\"\" self . _browser = browser @property def options ( self ): \"\"\" The options to be passed down to the WebDriver when starting the browser. Returns: options (Options): The browser specific options to be used. \"\"\" return self . _options @options . setter def options ( self , options ): \"\"\" The options to be passed down to the WebDriver when starting the browser. Args: options (Options): The browser specific options to be used. \"\"\" self . _options = options @property def capabilities ( self ): \"\"\" The capabilities to be passed down to the WebDriver when starting the browser. Returns: capabilities (Dict): The browser specific capabilities to be used. \"\"\" return self . _capabilities @capabilities . setter def capabilities ( self , capabilities ): \"\"\" The capabilities to be passed down to the WebDriver when starting the browser. Args: capabilities (Dict): The browser specific capabilities to be used. \"\"\" self . _capabilities = capabilities @property def download_folder_path ( self ): return self . _download_folder_path @download_folder_path . setter def download_folder_path ( self , folder_path ): \"\"\" The download folder path to be used. Set it up before starting the Browser or browsing a URL or restart the browser after changing it. Args: folder_path (str): The desired download folder path. \"\"\" self . _download_folder_path = folder_path @property def headless ( self ): \"\"\" Controls whether or not the bot will run headless. Returns: headless (bool): Whether or not to run the browser on headless mode. \"\"\" return self . _headless @headless . setter def headless ( self , headless ): \"\"\" Controls whether or not the bot will run headless. Args: headless (boolean): If set to True will make the bot run headless. \"\"\" if self . _driver : logger . warning ( \"Browser is running. Invoke stop_browser and start browser for changes to take effect.\" ) self . _headless = headless def start_browser ( self ): \"\"\" Starts the selected browser. \"\"\" def check_driver (): # Look for driver driver_name = BROWSER_CONFIGS . get ( self . browser ) . get ( \"driver\" ) location = shutil . which ( driver_name ) if not location : raise RuntimeError ( f \" { driver_name } was not found. Please make sure to have it on your PATH or set driver_path\" ) return location # Specific webdriver class for a given browser driver_class = BROWSER_CONFIGS . get ( self . browser ) . get ( \"class\" ) # Specific default options method for a given browser func_def_options = BROWSER_CONFIGS . get ( self . browser ) . get ( \"options\" ) # Specific capabilities method for a given browser func_def_capabilities = BROWSER_CONFIGS . get ( self . browser ) . get ( \"capabilities\" ) opt = self . options or func_def_options ( self . headless , self . _download_folder_path , None ) cap = self . capabilities or func_def_capabilities () self . options = opt self . capabilities = cap driver_path = self . driver_path or check_driver () self . driver_path = driver_path self . _driver = driver_class ( options = opt , desired_capabilities = cap , executable_path = driver_path ) self . set_screen_resolution () def stop_browser ( self ): \"\"\" Stops the Chrome browser and clean up the User Data Directory. \"\"\" if not self . _driver : return self . _driver . close () self . _driver . quit () self . _driver = None def set_screen_resolution ( self , width = None , height = None ): \"\"\" Configures the browser dimensions. Args: width (int): The desired width. height (int): The desired height. \"\"\" self . _dimensions = ( width or 1600 , height or 900 ) if self . headless : # When running headless the window size is the viewport size window_size = self . _dimensions else : # When running non-headless we need to account for the borders and etc # So the size must be bigger to have the same viewport size as before window_size = self . _driver . execute_script ( \"\"\" return [window.outerWidth - window.innerWidth + arguments[0], window.outerHeight - window.innerHeight + arguments[1]]; \"\"\" , * self . _dimensions ) self . _driver . set_window_size ( * window_size ) def _webdriver_command ( self , command , params = None , req_type = \"POST\" ): \"\"\" Execute a webdriver command. Args: command (str): The command URL after the session part params (dict): The payload to be serialized and sent to the webdriver. Defaults to None. req_type (str, optional): The type of request to be made. Defaults to \"POST\". Returns: str: The value of the response \"\"\" if not params : params = {} resource = f \"/session/ { self . driver . session_id } / { command } \" url = self . driver . command_executor . _url + resource body = json . dumps ( params ) response = self . driver . command_executor . _request ( req_type , url , body ) if not response : raise Exception ( response . get ( 'value' )) return response . get ( 'value' ) ########## # Display ########## def get_screen_image ( self , region = None ): \"\"\" Capture and returns a screenshot from the browser. Args: region (tuple): A tuple containing the left, top, width and height to crop the screen image. Returns: image (Image): The screenshot Image object. \"\"\" if not region : region = ( 0 , 0 , 0 , 0 ) x = region [ 0 ] or 0 y = region [ 1 ] or 0 width = region [ 2 ] or self . _dimensions [ 0 ] height = region [ 3 ] or self . _dimensions [ 1 ] data = self . _driver . get_screenshot_as_base64 () image_data = base64 . b64decode ( data ) img = Image . open ( io . BytesIO ( image_data )) img = img . crop (( x , y , x + width , y + height )) return img def get_viewport_size ( self ): \"\"\" Returns the browser current viewport size. Returns: width (int): The current viewport width. height (int): The current viewport height. \"\"\" # Access each dimension individually width = self . _driver . get_window_size () . get ( \"width\" ) height = self . _driver . get_window_size () . get ( \"height\" ) return width , height def add_image ( self , label , path ): \"\"\" Add an image into the state image map. Args: label (str): The image identifier path (str): The path for the image on disk \"\"\" self . state . map_images [ label ] = path def get_image_from_map ( self , label ): \"\"\" Return an image from teh state image map. Args: label (str): The image identifier Returns: Image: The Image object \"\"\" path = self . state . map_images . get ( label ) if not path : raise KeyError ( 'Invalid label for image map.' ) img = Image . open ( path ) return img def find_multiple ( self , labels , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find multiple elements defined by label on screen until a timeout happens. Args: labels (list): A list of image identifiers x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: results (dict): A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. \"\"\" def _to_dict ( lbs , elems ): return { k : v for k , v in zip ( lbs , elems )} screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) results = [ None ] * len ( labels ) paths = [ self . _search_image_file ( la ) for la in labels ] if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () n_cpus = multiprocessing . cpu_count () - 1 while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return _to_dict ( labels , results ) haystack = self . screenshot () helper = functools . partial ( self . _find_multiple_helper , haystack , region , matching , grayscale ) with multiprocessing . Pool ( processes = n_cpus ) as pool : results = pool . map ( helper , paths ) results = [ r for r in results ] if None in results : continue else : return _to_dict ( labels , results ) def _find_multiple_helper ( self , haystack , region , confidence , grayscale , needle ): ele = cv2find . locate_all_opencv ( needle , haystack , region = region , confidence = confidence , grayscale = grayscale ) try : ele = next ( ele ) except StopIteration : ele = None return ele def find ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label = label , x = x , y = y , width = width , height = height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = grayscale ) def find_until ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" self . state . element = None screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( element_path , haystack_image = haystack , region = region , confidence = matching , grayscale = grayscale ) try : ele = next ( it ) except StopIteration : ele = None if ele is not None : self . state . element = ele return ele def set_current_element ( self , element : cv2find . Box ): \"\"\" Changes the current screen element the bot will interact when using click(), move(), and similar methods. This method is equivalent to self.state.element = element. Args: element (Box): A screen element from self.state.element or the find_all(as_list=True) method. \"\"\" self . state . element = element def find_all ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , grayscale = False , as_list : bool = False ): \"\"\" Find all elements defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. as_list (bool, Optional): If True, returns a list of element coordinates instead of a generator. Use set_active_element() to be able to interact with the found elements. This parameter must be True if you intend to run multiple find_all() concurrently. Defaults to False. Returns: elements (collections.Iterable[NamedTuple]): A generator with all element coordinates found. None if not found. \"\"\" def deduplicate ( elems ): def find_same ( item , items ): x_start = item . left x_end = item . left + item . width y_start = item . top y_end = item . top + item . height similars = [] for itm in items : if itm == item : continue if ( itm . left >= x_start and itm . left < x_end ) \\ and ( itm . top >= y_start and itm . top < y_end ): similars . append ( itm ) continue return similars index = 0 while True : try : dups = find_same ( elems [ index ], elems [ index :]) for d in dups : elems . remove ( d ) index += 1 except IndexError : break return elems self . state . element = None screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( element_path , haystack_image = haystack , region = region , confidence = matching , grayscale = grayscale ) eles = [ ele for ele in it ] if not eles : continue eles = deduplicate ( list ( eles )) # As List if as_list : return eles # As Generator for ele in eles : if ele is not None : self . state . element = ele yield ele break def find_text ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label , x , y , width , height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = True ) def get_last_element ( self ): \"\"\" Return the last element found. Returns: element (NamedTuple): The element coordinates (left, top, width, height) \"\"\" return self . state . element def display_size ( self ): \"\"\" Returns the display size in pixels. Returns: size (Tuple): The screen dimension (width and height) in pixels. \"\"\" return self . _dimensions def screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" img = self . get_screen_image ( region ) if filepath : img . save ( filepath ) return img def get_screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" return self . screenshot ( filepath , region ) def screen_cut ( self , x , y , width = None , height = None ): \"\"\" Capture a screenshot from a region of the screen. Args: x (int): region start position x y (int): region start position y width (int): region width height (int): region height Returns: Image: The screenshot Image object \"\"\" screen_size = self . _dimensions x = x or 0 y = y or 0 width = width or screen_size [ 0 ] height = height or screen_size [ 1 ] img = self . screenshot ( region = ( x , y , width , height )) return img def save_screenshot ( self , path ): \"\"\" Saves a screenshot in a given path. Args: path (str): The filepath in which to save the screenshot \"\"\" self . screenshot ( path ) def get_element_coords ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the element. \"\"\" self . state . element = None screen_size = self . _dimensions x = x or 0 y = y or 0 width = width or screen_size [ 0 ] height = height or screen_size [ 1 ] region = ( x , y , width , height ) if not best : print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( self . state . map_images [ label ], haystack_image = haystack , region = region , confidence = matching ) try : ele = next ( it ) except StopIteration : ele = None self . state . element = ele if ele : return ele . left , ele . top else : return None , None def get_element_coords_centered ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its centered coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the center of the element. \"\"\" self . get_element_coords ( label , x , y , width , height , matching , best ) return self . state . center () ######### # Browser ######### def page_title ( self ): \"\"\" Returns the active page title. Returns: title (str): The page title. \"\"\" try : return self . _driver . title except InvalidSessionIdException : return None def page_source ( self ): \"\"\" Returns the active page source. Returns: soup (BeautifulSoup): BeautifulSoup object for the page source. \"\"\" try : soup = BeautifulSoup ( self . _driver . page_source , 'html.parser' ) return soup except InvalidSessionIdException : return None def navigate_to ( self , url , is_retry = False ): \"\"\" Opens the browser on the given URL. Args: url (str): The URL to be visited. is_retry (bool): Whether or not this is a retry attempt. \"\"\" self . _x = 0 self . _y = 0 if not self . _driver : self . start_browser () try : self . _driver . get ( url ) except InvalidSessionIdException : if not is_retry : self . stop_browser () self . navigate_to ( url , is_retry = True ) def browse ( self , url ): \"\"\" Opens the browser on the given URL. Args: url (str): The URL to be visited. \"\"\" self . navigate_to ( url ) def execute_javascript ( self , code ): \"\"\" Execute the given javascript code. Args: code (str): The code to be executed. Returns: value (object): Returns the code output or None if not available or if an error happens. \"\"\" return self . _driver . execute_script ( code ) def handle_js_dialog ( self , accept = True , prompt_text = None ): \"\"\" Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). This also cleans the dialog information in the local buffer. Args: accept (bool): Whether to accept or dismiss the dialog. prompt_text (str): The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog. \"\"\" dialog = self . get_js_dialog () if not dialog : # TODO: Maybe we should raise an exception here if no alert available return if prompt_text is not None : dialog . send_keys ( prompt_text ) if accept : dialog . accept () else : dialog . dismiss () def get_js_dialog ( self ): \"\"\" Return the last found dialog. Invoke first the `find_js_dialog` method to look up. Returns: dialog (dict): The dialog information or None if not available. See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening \"\"\" try : dialog = self . _driver . switch_to . alert return dialog except Exception : return None def get_tabs ( self ): \"\"\"Get a list of tab handlers Returns: list: List of tab handlers \"\"\" try : return self . _driver . window_handles except InvalidSessionIdException : return [] def create_tab ( self , url ): \"\"\"Create a new tab and navigate to the given URL. Args: url (str): The desired URL. \"\"\" try : # Refactor this when Selenium 4 is released self . execute_javascript ( f \"window.open(' { url } ', '_blank');\" ) self . _driver . switch_to . window ( self . get_tabs ()[ - 1 ]) except InvalidSessionIdException : self . navigate_to ( url ) def create_window ( self , url ): \"\"\"Creates a new window with the given URL. Args: url (str): The desired URL. \"\"\" try : # Refactor this when Selenium 4 is released self . execute_javascript ( f \"window.open(' { url } ', '_blank', 'location=0');\" ) self . _driver . switch_to . window ( self . get_tabs ()[ - 1 ]) except InvalidSessionIdException : self . navigate_to ( url ) def close_page ( self ): \"\"\"Close the current active page (tab or window). \"\"\" try : self . _driver . close () # If it was the last tab we can't switch tabs = self . get_tabs () if tabs : self . _driver . switch_to . window ( tabs [ - 1 ]) except InvalidSessionIdException : pass def activate_tab ( self , handle ): \"\"\"Activate a tab given by the handle. Args: handle (str): The tab or window handle. \"\"\" self . _driver . switch_to . window ( handle ) def print_pdf ( self , path = None , print_options = None ): \"\"\"Print the current page as a PDF file. Args: path (str, optional): The path for the file to be saved. Defaults to None. print_options (dict, optional): Print options as defined at. Defaults to None. Returns: str: the saved file path \"\"\" title = self . page_title () or \"document\" timeout = 60000 if not self . page_title (): timeout = 1000 default_path = os . path . expanduser ( os . path . join ( self . download_folder_path , f \" { title } .pdf\" )) if self . browser in [ Browser . CHROME , Browser . EDGE ] and not self . headless : # Chrome still does not support headless webdriver print # but Firefox does. self . execute_javascript ( \"window.print();\" ) # We need to wait for the file to be available in this case. self . wait_for_file ( default_path , timeout = timeout ) return default_path if print_options is None : print_options = { 'landscape' : False , 'displayHeaderFooter' : False , 'printBackground' : True , 'preferCSSPageSize' : True , 'marginTop' : 0 , 'marginBottom' : 0 } data = self . _webdriver_command ( \"print\" , print_options ) bytes_file = base64 . b64decode ( data ) if not path : path = default_path with open ( path , \"wb\" ) as f : f . write ( bytes_file ) return path def wait_for_downloads ( self , timeout : int = 120000 ): \"\"\" Wait for all downloads to be finished. Beware that this method replaces the current page with the downloads window. Args: timeout (int, optional): Timeout in millis. Defaults to 120000. \"\"\" wait_method = BROWSER_CONFIGS . get ( self . browser ) . get ( \"wait_for_downloads\" ) # waits for all the files to be completed WebDriverWait ( self . _driver , timeout / 1000 , 1 ) . until ( wait_method ) def find_elements ( self , selector : str , by : By = By . CSS_SELECTOR ) -> List [ WebElement ]: \"\"\"Find elements using the specified selector with selector type specified by `by`. Args: selector (str): The selector string to be used. by (str, optional): Selector type. Defaults to By.CSS_SELECTOR. [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By) Returns: List[WebElement]: List of elements found. **Example:** ```python from botcity.web import By ... # Find element by ID all_cells = self.find_elements(\"//td\", By.XPATH) ... ``` \"\"\" return self . _driver . find_elements ( by , selector ) def find_element ( self , selector : str , by : str = By . CSS_SELECTOR ) -> WebElement : \"\"\"Find an element using the specified selector with selector type specified by `by`. If more than one element is found, the first instance is returned. Args: selector (str): The selector string to be used. by (str, optional): Selector type. Defaults to By.CSS_SELECTOR. [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By) Returns: WebElement: The element found. **Example:** ```python from botcity.web import By ... # Find element by ID elem = self.find_element(\"my_elem\", By.ID) # Find element by XPath elem = self.find_element(\"//input[@type='submit']\", By.XPATH) ... ``` \"\"\" out = self . find_elements ( selector = selector , by = by ) if out : return out [ 0 ] def set_file_input_element ( self , element : WebElement , filepath : str ): \"\"\"Configure the filepath for upload in a file element. Note: This method does not submit the form. Args: element (WebElement): The file upload element. filepath (str): The path to the file to be uploaded. **Example:** ```python ... # Find element elem = self.find_element(\"body > form > input[type=file]\") # Set the filepath self.set_file_input_element(elem, \"./test.txt\") ... ``` \"\"\" fpath = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( filepath ))) element . send_keys ( fpath ) def enter_iframe ( self , iframe : WebElement ): \"\"\"Switch the WebBot driver to the specified iframe. Args: iframe (WebElement): The desired iFrame. \"\"\" self . _driver . switch_to . frame ( iframe ) def leave_iframe ( self ): \"\"\"Leave the iframe and switch the WebBot driver to the default content. \"\"\" self . _driver . switch_to . default_content () ####### # Mouse ####### @only_if_element def click_on ( self , label ): \"\"\" Click on the element. Args: label (str): The image identifier \"\"\" x , y = self . get_element_coords_centered ( label ) self . click ( x , y ) @only_if_element def get_last_x ( self ): \"\"\" Get the last X position for the mouse. Returns: x (int): The last x position for the mouse. \"\"\" return self . _x def get_last_y ( self ): \"\"\" Get the last Y position for the mouse. Returns: y (int): The last y position for the mouse. \"\"\" return self . _y def mouse_move ( self , x , y ): \"\"\" Mouse the move to the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" if self . browser == Browser . FIREFOX : # Reset coordinates if the page has gone stale. Only required for Firefox if self . _html_elem is None : self . _html_elem = self . _driver . find_element_by_tag_name ( 'body' ) self . _x = 0 self . _y = 0 else : try : self . _html_elem . is_enabled () except StaleElementReferenceException : self . _html_elem = self . _driver . find_element_by_tag_name ( 'body' ) self . _x = 0 self . _y = 0 mx = x - self . _x my = y - self . _y self . _x = x self . _y = y ActionChains ( self . _driver ) . move_by_offset ( mx , my ) . perform () def click_at ( self , x , y , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" self . mouse_move ( x , y ) ac = ActionChains ( self . _driver ) for i in range ( clicks ): if button == 'left' : ac . click () elif button == 'right' : ac . context_click () else : raise ValueError ( 'Invalid value for button. Accepted values are left or right.' ) ac . pause ( interval_between_clicks / 1000.0 ) ac . perform () @only_if_element def click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" x , y = self . state . center () self . click_at ( x , y , clicks = clicks , button = button , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) @only_if_element def click_relative ( self , x , y , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" x = self . state . x () + x y = self . state . y () + y self . click_at ( x , y , clicks = clicks , button = button , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) @only_if_element def double_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( interval_between_clicks = wait_after , clicks = 2 ) @only_if_element def double_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 2 , interval_between_clicks = interval_between_clicks ) @only_if_element def triple_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( wait_after = wait_after , clicks = 3 ) @only_if_element def triple_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 3 , interval_between_clicks = interval_between_clicks ) def mouse_down ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Holds down the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" ActionChains ( self . _driver ) . click_and_hold () . perform () self . sleep ( wait_after ) def mouse_up ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Releases the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" ActionChains ( self . _driver ) . release () . perform () self . sleep ( wait_after ) def scroll_down ( self , clicks ): \"\"\" Scroll Down n clicks Args: clicks (int): Number of times to scroll down. \"\"\" for i in range ( clicks ): self . _driver . execute_script ( \"window.scrollTo(0, window.scrollY + 200)\" ) self . sleep ( 200 ) def scroll_up ( self , clicks ): \"\"\" Scroll Up n clicks Args: clicks (int): Number of times to scroll up. \"\"\" for i in range ( clicks ): self . _driver . execute_script ( \"window.scrollTo(0, window.scrollY - 200)\" ) self . sleep ( 200 ) def move_to ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" self . mouse_move ( x , y ) @only_if_element def move ( self ): \"\"\" Move to the center position of last found item. \"\"\" x , y = self . state . center () self . move_to ( x , y ) def move_relative ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): Horizontal offset y (int): Vertical offset \"\"\" x = self . get_last_x () + x y = self . get_last_y () + y self . move_to ( x , y ) def move_random ( self , range_x , range_y ): \"\"\" Move randomly along the given x, y range. Args: range_x (int): Horizontal range range_y (int): Vertical range \"\"\" x = int ( random . random () * range_x ) y = int ( random . random () * range_y ) self . move_to ( x , y ) @only_if_element def right_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 ): \"\"\" Right click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. \"\"\" self . click ( clicks = clicks , button = 'right' , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after ) def right_click_at ( self , x , y ): \"\"\" Right click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" self . click_at ( x , y , button = 'right' ) @only_if_element def right_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Right Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , interval_between_clicks = interval_between_clicks , button = 'right' ) ########## # Keyboard ########## def kb_type ( self , text , interval = 0 ): \"\"\" Type a text char by char (individual key events). Args: text (str): text to be typed. interval (int, optional): interval (ms) between each key press. Defaults to 0 \"\"\" action = ActionChains ( self . _driver ) for c in text : action . send_keys ( c ) action . pause ( interval / 1000.0 ) action . perform () self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION ) def paste ( self , text = None , wait = 0 ): \"\"\" Paste content from the clipboard. Args: text (str, optional): The text to be pasted. Defaults to None wait (int, optional): Wait interval (ms) after task \"\"\" text_to_paste = self . _clipboard if text : text_to_paste = text self . kb_type ( text_to_paste ) def copy_to_clipboard ( self , text , wait = 0 ): \"\"\" Copy content to the clipboard. Args: text (str): The text to be copied. wait (int, optional): Wait interval (ms) after task \"\"\" self . _clipboard = text delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def tab ( self , wait = 0 ): \"\"\" Press key Tab Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . TAB ) action . key_up ( Keys . TAB ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ENTER ) action . key_up ( Keys . ENTER ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def key_right ( self , wait = 0 ): \"\"\" Press key Right Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_RIGHT ) action . key_up ( Keys . ARROW_RIGHT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def key_enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . enter ( wait ) def key_home ( self , wait = 0 ): \"\"\" Press key Home Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . HOME ) action . key_up ( Keys . HOME ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def key_end ( self , wait = 0 ): \"\"\" Press key End Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . END ) action . key_up ( Keys . END ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def page_up ( self , wait = 0 ): \"\"\" Press Page Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . PAGE_UP ) action . key_up ( Keys . PAGE_UP ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def page_down ( self , wait = 0 ): \"\"\" Press Page Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . PAGE_DOWN ) action . key_up ( Keys . PAGE_DOWN ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def key_esc ( self , wait = 0 ): \"\"\" Press key Esc Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ESCAPE ) action . key_up ( Keys . ESCAPE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def _key_fx ( self , idx , wait = 0 ): \"\"\" Press key Fidx where idx is a value from 1 to 12 Args: idx (int): F key index from 1 to 12 wait (int, optional): Wait interval (ms) after task \"\"\" if idx < 1 or idx > 12 : raise ValueError ( \"Only F1 to F12 allowed.\" ) action = ActionChains ( self . _driver ) key = getattr ( Keys , f \"F { idx } \" ) action . key_down ( key ) action . key_up ( key ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def hold_shift ( self , wait = 0 ): \"\"\" Hold key Shift Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . SHIFT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def release_shift ( self ): \"\"\" Release key Shift. This method needs to be invoked after holding Shift or similar. \"\"\" action = ActionChains ( self . _driver ) action . key_up ( Keys . SHIFT ) action . perform () def maximize_window ( self ): \"\"\" Shortcut to maximize window on Windows OS. \"\"\" # TODO: Understand the complications associated with maximizing the browser and the resolution self . _driver . maximize_window () def type_keys_with_interval ( self , interval , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: interval (int): Interval (ms) in which to press and release keys keys (list): List of Keys to be pressed \"\"\" action = ActionChains ( self . _driver ) for k in keys : action . key_down ( k ) action . pause ( interval / 1000.0 ) for k in reversed ( keys ): action . key_up ( k ) action . pause ( interval / 1000.0 ) action . perform () def type_keys ( self , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: keys (list): List of keys to be pressed \"\"\" self . type_keys_with_interval ( 100 , keys ) def control_c ( self , wait = 0 ): \"\"\" Press keys CTRL+C Args: wait (int, optional): Wait interval (ms) after task \"\"\" # Firefox can't do window.getSelection() and return a proper value when the selected text # is in an input of similar. While Firefox doesn't get its shit together we apply this # ugly alternative so control+c works for \"all\" browsers tested so far. cmd = \"\"\" try { return document.activeElement.value.substring( document.activeElement.selectionStart, document.activeElement.selectionEnd ); } catch(error) { return window.getSelection().toString(); } \"\"\" self . _clipboard = self . execute_javascript ( cmd ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def control_v ( self , wait = 0 ): \"\"\" Press keys CTRL+V Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . paste () def control_a ( self , wait = 0 ): \"\"\" Press keys CTRL+A Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) key = Keys . CONTROL if platform . system () == 'Darwin' : key = Keys . COMMAND action . key_down ( key ) action . send_keys ( 'a' ) action . key_up ( key ) action . perform () def get_clipboard ( self ): \"\"\" Get the current content in the clipboard. Returns: text (str): Current clipboard content \"\"\" return self . _clipboard def type_left ( self , wait = 0 ): \"\"\" Press Left key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_LEFT ) action . key_up ( Keys . ARROW_LEFT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def type_right ( self , wait = 0 ): \"\"\" Press Right key Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . key_right ( wait = wait ) def type_down ( self , wait = 0 ): \"\"\" Press Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_DOWN ) action . key_up ( Keys . ARROW_DOWN ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def type_up ( self , wait = 0 ): \"\"\" Press Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_UP ) action . key_up ( Keys . ARROW_UP ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def space ( self , wait = 0 ): \"\"\" Press Space key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . SPACE ) action . key_up ( Keys . SPACE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def backspace ( self , wait = 0 ): \"\"\" Press Backspace key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . BACK_SPACE ) action . key_up ( Keys . BACK_SPACE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) def delete ( self , wait = 0 ): \"\"\" Press Delete key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . DELETE ) action . key_up ( Keys . DELETE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) ###### # Misc ###### def wait ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" time . sleep ( interval / 1000.0 ) def sleep ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" self . wait ( interval ) def wait_for_file ( self , path , timeout = 60000 ): \"\"\" Wait for a file to be available on disk. Args: path (str): The path for the file to be executed timeout (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 60000ms (60s). Returns: status (bool): Whether or not the file was available before the timeout \"\"\" path = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( path ))) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > timeout : return False if os . path . isfile ( path ) and os . access ( path , os . R_OK ): if self . browser == Browser . FIREFOX and os . path . exists ( path + '.part' ): # if *.part exists, the download is not completed. continue return True self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION )","title":"WebBot"},{"location":"bot/#botcity.web.bot.WebBot.browser","text":"The web browser to be used. Returns: Type Description browser (Browser) The web browser to be used.","title":"browser"},{"location":"bot/#botcity.web.bot.WebBot.capabilities","text":"The capabilities to be passed down to the WebDriver when starting the browser. Returns: Type Description capabilities (Dict) The browser specific capabilities to be used.","title":"capabilities"},{"location":"bot/#botcity.web.bot.WebBot.driver","text":"The WebDriver driver instance. Returns: Type Description driver (WebDriver) The WebDriver driver instance.","title":"driver"},{"location":"bot/#botcity.web.bot.WebBot.headless","text":"Controls whether or not the bot will run headless. Returns: Type Description headless (bool) Whether or not to run the browser on headless mode.","title":"headless"},{"location":"bot/#botcity.web.bot.WebBot.options","text":"The options to be passed down to the WebDriver when starting the browser. Returns: Type Description options (Options) The browser specific options to be used.","title":"options"},{"location":"bot/#botcity.web.bot.WebBot.activate_tab","text":"Activate a tab given by the handle. Parameters: Name Type Description Default handle str The tab or window handle. required Source code in web/bot.py def activate_tab ( self , handle ): \"\"\"Activate a tab given by the handle. Args: handle (str): The tab or window handle. \"\"\" self . _driver . switch_to . window ( handle )","title":"activate_tab()"},{"location":"bot/#botcity.web.bot.WebBot.add_image","text":"Add an image into the state image map. Parameters: Name Type Description Default label str The image identifier required path str The path for the image on disk required Source code in web/bot.py def add_image ( self , label , path ): \"\"\" Add an image into the state image map. Args: label (str): The image identifier path (str): The path for the image on disk \"\"\" self . state . map_images [ label ] = path","title":"add_image()"},{"location":"bot/#botcity.web.bot.WebBot.backspace","text":"Press Backspace key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def backspace ( self , wait = 0 ): \"\"\" Press Backspace key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . BACK_SPACE ) action . key_up ( Keys . BACK_SPACE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"backspace()"},{"location":"bot/#botcity.web.bot.WebBot.browse","text":"Opens the browser on the given URL. Parameters: Name Type Description Default url str The URL to be visited. required Source code in web/bot.py def browse ( self , url ): \"\"\" Opens the browser on the given URL. Args: url (str): The URL to be visited. \"\"\" self . navigate_to ( url )","title":"browse()"},{"location":"bot/#botcity.web.bot.WebBot.click","text":"Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right'. Defaults to 'left' 'left' Source code in web/bot.py @only_if_element def click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" x , y = self . state . center () self . click_at ( x , y , clicks = clicks , button = button , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after )","title":"click()"},{"location":"bot/#botcity.web.bot.WebBot.click_at","text":"Click at the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right'. Defaults to 'left' 'left' Source code in web/bot.py def click_at ( self , x , y , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" self . mouse_move ( x , y ) ac = ActionChains ( self . _driver ) for i in range ( clicks ): if button == 'left' : ac . click () elif button == 'right' : ac . context_click () else : raise ValueError ( 'Invalid value for button. Accepted values are left or right.' ) ac . pause ( interval_between_clicks / 1000.0 ) ac . perform ()","title":"click_at()"},{"location":"bot/#botcity.web.bot.WebBot.click_on","text":"Click on the element. Parameters: Name Type Description Default label str The image identifier required Source code in web/bot.py @only_if_element def click_on ( self , label ): \"\"\" Click on the element. Args: label (str): The image identifier \"\"\" x , y = self . get_element_coords_centered ( label ) self . click ( x , y )","title":"click_on()"},{"location":"bot/#botcity.web.bot.WebBot.click_relative","text":"Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right'. Defaults to 'left' 'left' Source code in web/bot.py @only_if_element def click_relative ( self , x , y , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right'. Defaults to 'left' \"\"\" x = self . state . x () + x y = self . state . y () + y self . click_at ( x , y , clicks = clicks , button = button , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after )","title":"click_relative()"},{"location":"bot/#botcity.web.bot.WebBot.close_page","text":"Close the current active page (tab or window). Source code in web/bot.py def close_page ( self ): \"\"\"Close the current active page (tab or window). \"\"\" try : self . _driver . close () # If it was the last tab we can't switch tabs = self . get_tabs () if tabs : self . _driver . switch_to . window ( tabs [ - 1 ]) except InvalidSessionIdException : pass","title":"close_page()"},{"location":"bot/#botcity.web.bot.WebBot.control_a","text":"Press keys CTRL+A Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def control_a ( self , wait = 0 ): \"\"\" Press keys CTRL+A Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) key = Keys . CONTROL if platform . system () == 'Darwin' : key = Keys . COMMAND action . key_down ( key ) action . send_keys ( 'a' ) action . key_up ( key ) action . perform ()","title":"control_a()"},{"location":"bot/#botcity.web.bot.WebBot.control_c","text":"Press keys CTRL+C Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def control_c ( self , wait = 0 ): \"\"\" Press keys CTRL+C Args: wait (int, optional): Wait interval (ms) after task \"\"\" # Firefox can't do window.getSelection() and return a proper value when the selected text # is in an input of similar. While Firefox doesn't get its shit together we apply this # ugly alternative so control+c works for \"all\" browsers tested so far. cmd = \"\"\" try { return document.activeElement.value.substring( document.activeElement.selectionStart, document.activeElement.selectionEnd ); } catch(error) { return window.getSelection().toString(); } \"\"\" self . _clipboard = self . execute_javascript ( cmd ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_c()"},{"location":"bot/#botcity.web.bot.WebBot.control_v","text":"Press keys CTRL+V Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def control_v ( self , wait = 0 ): \"\"\" Press keys CTRL+V Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . paste ()","title":"control_v()"},{"location":"bot/#botcity.web.bot.WebBot.copy_to_clipboard","text":"Copy content to the clipboard. Parameters: Name Type Description Default text str The text to be copied. required wait int Wait interval (ms) after task 0 Source code in web/bot.py def copy_to_clipboard ( self , text , wait = 0 ): \"\"\" Copy content to the clipboard. Args: text (str): The text to be copied. wait (int, optional): Wait interval (ms) after task \"\"\" self . _clipboard = text delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"copy_to_clipboard()"},{"location":"bot/#botcity.web.bot.WebBot.create_tab","text":"Create a new tab and navigate to the given URL. Parameters: Name Type Description Default url str The desired URL. required Source code in web/bot.py def create_tab ( self , url ): \"\"\"Create a new tab and navigate to the given URL. Args: url (str): The desired URL. \"\"\" try : # Refactor this when Selenium 4 is released self . execute_javascript ( f \"window.open(' { url } ', '_blank');\" ) self . _driver . switch_to . window ( self . get_tabs ()[ - 1 ]) except InvalidSessionIdException : self . navigate_to ( url )","title":"create_tab()"},{"location":"bot/#botcity.web.bot.WebBot.create_window","text":"Creates a new window with the given URL. Parameters: Name Type Description Default url str The desired URL. required Source code in web/bot.py def create_window ( self , url ): \"\"\"Creates a new window with the given URL. Args: url (str): The desired URL. \"\"\" try : # Refactor this when Selenium 4 is released self . execute_javascript ( f \"window.open(' { url } ', '_blank', 'location=0');\" ) self . _driver . switch_to . window ( self . get_tabs ()[ - 1 ]) except InvalidSessionIdException : self . navigate_to ( url )","title":"create_window()"},{"location":"bot/#botcity.web.bot.WebBot.delete","text":"Press Delete key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def delete ( self , wait = 0 ): \"\"\" Press Delete key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . DELETE ) action . key_up ( Keys . DELETE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"delete()"},{"location":"bot/#botcity.web.bot.WebBot.display_size","text":"Returns the display size in pixels. Returns: Type Description size (Tuple) The screen dimension (width and height) in pixels. Source code in web/bot.py def display_size ( self ): \"\"\" Returns the display size in pixels. Returns: size (Tuple): The screen dimension (width and height) in pixels. \"\"\" return self . _dimensions","title":"display_size()"},{"location":"bot/#botcity.web.bot.WebBot.double_click","text":"Double Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def double_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( interval_between_clicks = wait_after , clicks = 2 )","title":"double_click()"},{"location":"bot/#botcity.web.bot.WebBot.double_click_relative","text":"Double Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def double_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 2 , interval_between_clicks = interval_between_clicks )","title":"double_click_relative()"},{"location":"bot/#botcity.web.bot.WebBot.enter","text":"Press key Enter Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ENTER ) action . key_up ( Keys . ENTER ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"enter()"},{"location":"bot/#botcity.web.bot.WebBot.enter_iframe","text":"Switch the WebBot driver to the specified iframe. Parameters: Name Type Description Default iframe WebElement The desired iFrame. required Source code in web/bot.py def enter_iframe ( self , iframe : WebElement ): \"\"\"Switch the WebBot driver to the specified iframe. Args: iframe (WebElement): The desired iFrame. \"\"\" self . _driver . switch_to . frame ( iframe )","title":"enter_iframe()"},{"location":"bot/#botcity.web.bot.WebBot.execute_javascript","text":"Execute the given javascript code. Parameters: Name Type Description Default code str The code to be executed. required Returns: Type Description value (object) Returns the code output or None if not available or if an error happens. Source code in web/bot.py def execute_javascript ( self , code ): \"\"\" Execute the given javascript code. Args: code (str): The code to be executed. Returns: value (object): Returns the code output or None if not available or if an error happens. \"\"\" return self . _driver . execute_script ( code )","title":"execute_javascript()"},{"location":"bot/#botcity.web.bot.WebBot.find","text":"Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in web/bot.py def find ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label = label , x = x , y = y , width = width , height = height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = grayscale )","title":"find()"},{"location":"bot/#botcity.web.bot.WebBot.find_all","text":"Find all elements defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False as_list bool, Optional If True, returns a list of element coordinates instead of a generator. Use set_active_element() to be able to interact with the found elements. This parameter must be True if you intend to run multiple find_all() concurrently. Defaults to False. False Returns: Type Description elements (collections.Iterable[NamedTuple]) A generator with all element coordinates found. None if not found. Source code in web/bot.py def find_all ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , grayscale = False , as_list : bool = False ): \"\"\" Find all elements defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. as_list (bool, Optional): If True, returns a list of element coordinates instead of a generator. Use set_active_element() to be able to interact with the found elements. This parameter must be True if you intend to run multiple find_all() concurrently. Defaults to False. Returns: elements (collections.Iterable[NamedTuple]): A generator with all element coordinates found. None if not found. \"\"\" def deduplicate ( elems ): def find_same ( item , items ): x_start = item . left x_end = item . left + item . width y_start = item . top y_end = item . top + item . height similars = [] for itm in items : if itm == item : continue if ( itm . left >= x_start and itm . left < x_end ) \\ and ( itm . top >= y_start and itm . top < y_end ): similars . append ( itm ) continue return similars index = 0 while True : try : dups = find_same ( elems [ index ], elems [ index :]) for d in dups : elems . remove ( d ) index += 1 except IndexError : break return elems self . state . element = None screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( element_path , haystack_image = haystack , region = region , confidence = matching , grayscale = grayscale ) eles = [ ele for ele in it ] if not eles : continue eles = deduplicate ( list ( eles )) # As List if as_list : return eles # As Generator for ele in eles : if ele is not None : self . state . element = ele yield ele break","title":"find_all()"},{"location":"bot/#botcity.web.bot.WebBot.find_element","text":"Find an element using the specified selector with selector type specified by by . If more than one element is found, the first instance is returned. Parameters: Name Type Description Default selector str The selector string to be used. required by str Selector type. Defaults to By.CSS_SELECTOR. See more 'css selector' Returns: Type Description WebElement The element found. Example: from botcity.web import By ... # Find element by ID elem = self . find_element ( \"my_elem\" , By . ID ) # Find element by XPath elem = self . find_element ( \"//input[@type='submit']\" , By . XPATH ) ... Source code in web/bot.py def find_element ( self , selector : str , by : str = By . CSS_SELECTOR ) -> WebElement : \"\"\"Find an element using the specified selector with selector type specified by `by`. If more than one element is found, the first instance is returned. Args: selector (str): The selector string to be used. by (str, optional): Selector type. Defaults to By.CSS_SELECTOR. [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By) Returns: WebElement: The element found. **Example:** ```python from botcity.web import By ... # Find element by ID elem = self.find_element(\"my_elem\", By.ID) # Find element by XPath elem = self.find_element(\"//input[@type='submit']\", By.XPATH) ... ``` \"\"\" out = self . find_elements ( selector = selector , by = by ) if out : return out [ 0 ]","title":"find_element()"},{"location":"bot/#botcity.web.bot.WebBot.find_elements","text":"Find elements using the specified selector with selector type specified by by . Parameters: Name Type Description Default selector str The selector string to be used. required by str Selector type. Defaults to By.CSS_SELECTOR. See more 'css selector' Returns: Type Description List[WebElement] List of elements found. Example: from botcity.web import By ... # Find element by ID all_cells = self . find_elements ( \"//td\" , By . XPATH ) ... Source code in web/bot.py def find_elements ( self , selector : str , by : By = By . CSS_SELECTOR ) -> List [ WebElement ]: \"\"\"Find elements using the specified selector with selector type specified by `by`. Args: selector (str): The selector string to be used. by (str, optional): Selector type. Defaults to By.CSS_SELECTOR. [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By) Returns: List[WebElement]: List of elements found. **Example:** ```python from botcity.web import By ... # Find element by ID all_cells = self.find_elements(\"//td\", By.XPATH) ... ``` \"\"\" return self . _driver . find_elements ( by , selector )","title":"find_elements()"},{"location":"bot/#botcity.web.bot.WebBot.find_multiple","text":"Find multiple elements defined by label on screen until a timeout happens. Parameters: Name Type Description Default labels list A list of image identifiers required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description results (dict) A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. Source code in web/bot.py def find_multiple ( self , labels , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find multiple elements defined by label on screen until a timeout happens. Args: labels (list): A list of image identifiers x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: results (dict): A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. \"\"\" def _to_dict ( lbs , elems ): return { k : v for k , v in zip ( lbs , elems )} screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) results = [ None ] * len ( labels ) paths = [ self . _search_image_file ( la ) for la in labels ] if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () n_cpus = multiprocessing . cpu_count () - 1 while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return _to_dict ( labels , results ) haystack = self . screenshot () helper = functools . partial ( self . _find_multiple_helper , haystack , region , matching , grayscale ) with multiprocessing . Pool ( processes = n_cpus ) as pool : results = pool . map ( helper , paths ) results = [ r for r in results ] if None in results : continue else : return _to_dict ( labels , results )","title":"find_multiple()"},{"location":"bot/#botcity.web.bot.WebBot.find_text","text":"Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in web/bot.py def find_text ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label , x , y , width , height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = True )","title":"find_text()"},{"location":"bot/#botcity.web.bot.WebBot.find_until","text":"Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in web/bot.py def find_until ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" self . state . element = None screen_w , screen_h = self . _dimensions x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( element_path , haystack_image = haystack , region = region , confidence = matching , grayscale = grayscale ) try : ele = next ( it ) except StopIteration : ele = None if ele is not None : self . state . element = ele return ele","title":"find_until()"},{"location":"bot/#botcity.web.bot.WebBot.get_clipboard","text":"Get the current content in the clipboard. Returns: Type Description text (str) Current clipboard content Source code in web/bot.py def get_clipboard ( self ): \"\"\" Get the current content in the clipboard. Returns: text (str): Current clipboard content \"\"\" return self . _clipboard","title":"get_clipboard()"},{"location":"bot/#botcity.web.bot.WebBot.get_element_coords","text":"Find an element defined by label on screen and returns its coordinates. Parameters: Name Type Description Default label str The image identifier required x int X (Left) coordinate of the search area. None y int Y (Top) coordinate of the search area. None width int Width of the search area. None height int Height of the search area. None matching float Minimum score to consider a match in the element image recognition process. Defaults to 0.9. 0.9 best bool Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. True Returns: Type Description coords (Tuple) A tuple containing the x and y coordinates for the element. Source code in web/bot.py def get_element_coords ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the element. \"\"\" self . state . element = None screen_size = self . _dimensions x = x or 0 y = y or 0 width = width or screen_size [ 0 ] height = height or screen_size [ 1 ] region = ( x , y , width , height ) if not best : print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) haystack = self . get_screen_image () it = cv2find . locate_all_opencv ( self . state . map_images [ label ], haystack_image = haystack , region = region , confidence = matching ) try : ele = next ( it ) except StopIteration : ele = None self . state . element = ele if ele : return ele . left , ele . top else : return None , None","title":"get_element_coords()"},{"location":"bot/#botcity.web.bot.WebBot.get_element_coords_centered","text":"Find an element defined by label on screen and returns its centered coordinates. Parameters: Name Type Description Default label str The image identifier required x int X (Left) coordinate of the search area. None y int Y (Top) coordinate of the search area. None width int Width of the search area. None height int Height of the search area. None matching float Minimum score to consider a match in the element image recognition process. Defaults to 0.9. 0.9 best bool Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. True Returns: Type Description coords (Tuple) A tuple containing the x and y coordinates for the center of the element. Source code in web/bot.py def get_element_coords_centered ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its centered coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the center of the element. \"\"\" self . get_element_coords ( label , x , y , width , height , matching , best ) return self . state . center ()","title":"get_element_coords_centered()"},{"location":"bot/#botcity.web.bot.WebBot.get_image_from_map","text":"Return an image from teh state image map. Parameters: Name Type Description Default label str The image identifier required Returns: Type Description Image The Image object Source code in web/bot.py def get_image_from_map ( self , label ): \"\"\" Return an image from teh state image map. Args: label (str): The image identifier Returns: Image: The Image object \"\"\" path = self . state . map_images . get ( label ) if not path : raise KeyError ( 'Invalid label for image map.' ) img = Image . open ( path ) return img","title":"get_image_from_map()"},{"location":"bot/#botcity.web.bot.WebBot.get_js_dialog","text":"Return the last found dialog. Invoke first the find_js_dialog method to look up. Returns: Type Description dialog (dict) The dialog information or None if not available. See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening Source code in web/bot.py def get_js_dialog ( self ): \"\"\" Return the last found dialog. Invoke first the `find_js_dialog` method to look up. Returns: dialog (dict): The dialog information or None if not available. See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening \"\"\" try : dialog = self . _driver . switch_to . alert return dialog except Exception : return None","title":"get_js_dialog()"},{"location":"bot/#botcity.web.bot.WebBot.get_last_element","text":"Return the last element found. Returns: Type Description element (NamedTuple) The element coordinates (left, top, width, height) Source code in web/bot.py def get_last_element ( self ): \"\"\" Return the last element found. Returns: element (NamedTuple): The element coordinates (left, top, width, height) \"\"\" return self . state . element","title":"get_last_element()"},{"location":"bot/#botcity.web.bot.WebBot.get_last_x","text":"Get the last X position for the mouse. Returns: Type Description x (int) The last x position for the mouse. Source code in web/bot.py @only_if_element def get_last_x ( self ): \"\"\" Get the last X position for the mouse. Returns: x (int): The last x position for the mouse. \"\"\" return self . _x","title":"get_last_x()"},{"location":"bot/#botcity.web.bot.WebBot.get_last_y","text":"Get the last Y position for the mouse. Returns: Type Description y (int) The last y position for the mouse. Source code in web/bot.py def get_last_y ( self ): \"\"\" Get the last Y position for the mouse. Returns: y (int): The last y position for the mouse. \"\"\" return self . _y","title":"get_last_y()"},{"location":"bot/#botcity.web.bot.WebBot.get_screen_image","text":"Capture and returns a screenshot from the browser. Parameters: Name Type Description Default region tuple A tuple containing the left, top, width and height to crop the screen image. None Returns: Type Description image (Image) The screenshot Image object. Source code in web/bot.py def get_screen_image ( self , region = None ): \"\"\" Capture and returns a screenshot from the browser. Args: region (tuple): A tuple containing the left, top, width and height to crop the screen image. Returns: image (Image): The screenshot Image object. \"\"\" if not region : region = ( 0 , 0 , 0 , 0 ) x = region [ 0 ] or 0 y = region [ 1 ] or 0 width = region [ 2 ] or self . _dimensions [ 0 ] height = region [ 3 ] or self . _dimensions [ 1 ] data = self . _driver . get_screenshot_as_base64 () image_data = base64 . b64decode ( data ) img = Image . open ( io . BytesIO ( image_data )) img = img . crop (( x , y , x + width , y + height )) return img","title":"get_screen_image()"},{"location":"bot/#botcity.web.bot.WebBot.get_screenshot","text":"Capture a screenshot. Parameters: Name Type Description Default filepath str The filepath in which to save the screenshot. Defaults to None. None region tuple Bounding box containing left, top, width and height to crop screenshot. None Returns: Type Description Image The screenshot Image object Source code in web/bot.py def get_screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" return self . screenshot ( filepath , region )","title":"get_screenshot()"},{"location":"bot/#botcity.web.bot.WebBot.get_tabs","text":"Get a list of tab handlers Returns: Type Description list List of tab handlers Source code in web/bot.py def get_tabs ( self ): \"\"\"Get a list of tab handlers Returns: list: List of tab handlers \"\"\" try : return self . _driver . window_handles except InvalidSessionIdException : return []","title":"get_tabs()"},{"location":"bot/#botcity.web.bot.WebBot.get_viewport_size","text":"Returns the browser current viewport size. Returns: Type Description width (int) The current viewport width. height (int): The current viewport height. Source code in web/bot.py def get_viewport_size ( self ): \"\"\" Returns the browser current viewport size. Returns: width (int): The current viewport width. height (int): The current viewport height. \"\"\" # Access each dimension individually width = self . _driver . get_window_size () . get ( \"width\" ) height = self . _driver . get_window_size () . get ( \"height\" ) return width , height","title":"get_viewport_size()"},{"location":"bot/#botcity.web.bot.WebBot.handle_js_dialog","text":"Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). This also cleans the dialog information in the local buffer. Parameters: Name Type Description Default accept bool Whether to accept or dismiss the dialog. True prompt_text str The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog. None Source code in web/bot.py def handle_js_dialog ( self , accept = True , prompt_text = None ): \"\"\" Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). This also cleans the dialog information in the local buffer. Args: accept (bool): Whether to accept or dismiss the dialog. prompt_text (str): The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog. \"\"\" dialog = self . get_js_dialog () if not dialog : # TODO: Maybe we should raise an exception here if no alert available return if prompt_text is not None : dialog . send_keys ( prompt_text ) if accept : dialog . accept () else : dialog . dismiss ()","title":"handle_js_dialog()"},{"location":"bot/#botcity.web.bot.WebBot.hold_shift","text":"Hold key Shift Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def hold_shift ( self , wait = 0 ): \"\"\" Hold key Shift Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . SHIFT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"hold_shift()"},{"location":"bot/#botcity.web.bot.WebBot.kb_type","text":"Type a text char by char (individual key events). Parameters: Name Type Description Default text str text to be typed. required interval int interval (ms) between each key press. Defaults to 0 0 Source code in web/bot.py def kb_type ( self , text , interval = 0 ): \"\"\" Type a text char by char (individual key events). Args: text (str): text to be typed. interval (int, optional): interval (ms) between each key press. Defaults to 0 \"\"\" action = ActionChains ( self . _driver ) for c in text : action . send_keys ( c ) action . pause ( interval / 1000.0 ) action . perform () self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION )","title":"kb_type()"},{"location":"bot/#botcity.web.bot.WebBot.key_end","text":"Press key End Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_end ( self , wait = 0 ): \"\"\" Press key End Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . END ) action . key_up ( Keys . END ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"key_end()"},{"location":"bot/#botcity.web.bot.WebBot.key_enter","text":"Press key Enter Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . enter ( wait )","title":"key_enter()"},{"location":"bot/#botcity.web.bot.WebBot.key_esc","text":"Press key Esc Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_esc ( self , wait = 0 ): \"\"\" Press key Esc Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ESCAPE ) action . key_up ( Keys . ESCAPE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"key_esc()"},{"location":"bot/#botcity.web.bot.WebBot.key_home","text":"Press key Home Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_home ( self , wait = 0 ): \"\"\" Press key Home Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . HOME ) action . key_up ( Keys . HOME ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"key_home()"},{"location":"bot/#botcity.web.bot.WebBot.key_right","text":"Press key Right Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def key_right ( self , wait = 0 ): \"\"\" Press key Right Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_RIGHT ) action . key_up ( Keys . ARROW_RIGHT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"key_right()"},{"location":"bot/#botcity.web.bot.WebBot.leave_iframe","text":"Leave the iframe and switch the WebBot driver to the default content. Source code in web/bot.py def leave_iframe ( self ): \"\"\"Leave the iframe and switch the WebBot driver to the default content. \"\"\" self . _driver . switch_to . default_content ()","title":"leave_iframe()"},{"location":"bot/#botcity.web.bot.WebBot.maximize_window","text":"Shortcut to maximize window on Windows OS. Source code in web/bot.py def maximize_window ( self ): \"\"\" Shortcut to maximize window on Windows OS. \"\"\" # TODO: Understand the complications associated with maximizing the browser and the resolution self . _driver . maximize_window ()","title":"maximize_window()"},{"location":"bot/#botcity.web.bot.WebBot.mouse_down","text":"Holds down the requested mouse button. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in web/bot.py def mouse_down ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Holds down the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" ActionChains ( self . _driver ) . click_and_hold () . perform () self . sleep ( wait_after )","title":"mouse_down()"},{"location":"bot/#botcity.web.bot.WebBot.mouse_move","text":"Mouse the move to the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in web/bot.py def mouse_move ( self , x , y ): \"\"\" Mouse the move to the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" if self . browser == Browser . FIREFOX : # Reset coordinates if the page has gone stale. Only required for Firefox if self . _html_elem is None : self . _html_elem = self . _driver . find_element_by_tag_name ( 'body' ) self . _x = 0 self . _y = 0 else : try : self . _html_elem . is_enabled () except StaleElementReferenceException : self . _html_elem = self . _driver . find_element_by_tag_name ( 'body' ) self . _x = 0 self . _y = 0 mx = x - self . _x my = y - self . _y self . _x = x self . _y = y ActionChains ( self . _driver ) . move_by_offset ( mx , my ) . perform ()","title":"mouse_move()"},{"location":"bot/#botcity.web.bot.WebBot.mouse_up","text":"Releases the requested mouse button. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in web/bot.py def mouse_up ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Releases the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" ActionChains ( self . _driver ) . release () . perform () self . sleep ( wait_after )","title":"mouse_up()"},{"location":"bot/#botcity.web.bot.WebBot.move","text":"Move to the center position of last found item. Source code in web/bot.py @only_if_element def move ( self ): \"\"\" Move to the center position of last found item. \"\"\" x , y = self . state . center () self . move_to ( x , y )","title":"move()"},{"location":"bot/#botcity.web.bot.WebBot.move_random","text":"Move randomly along the given x, y range. Parameters: Name Type Description Default range_x int Horizontal range required range_y int Vertical range required Source code in web/bot.py def move_random ( self , range_x , range_y ): \"\"\" Move randomly along the given x, y range. Args: range_x (int): Horizontal range range_y (int): Vertical range \"\"\" x = int ( random . random () * range_x ) y = int ( random . random () * range_y ) self . move_to ( x , y )","title":"move_random()"},{"location":"bot/#botcity.web.bot.WebBot.move_relative","text":"Move the mouse relative to its current position. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required Source code in web/bot.py def move_relative ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): Horizontal offset y (int): Vertical offset \"\"\" x = self . get_last_x () + x y = self . get_last_y () + y self . move_to ( x , y )","title":"move_relative()"},{"location":"bot/#botcity.web.bot.WebBot.move_to","text":"Move the mouse relative to its current position. Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in web/bot.py def move_to ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" self . mouse_move ( x , y )","title":"move_to()"},{"location":"bot/#botcity.web.bot.WebBot.navigate_to","text":"Opens the browser on the given URL. Parameters: Name Type Description Default url str The URL to be visited. required is_retry bool Whether or not this is a retry attempt. False Source code in web/bot.py def navigate_to ( self , url , is_retry = False ): \"\"\" Opens the browser on the given URL. Args: url (str): The URL to be visited. is_retry (bool): Whether or not this is a retry attempt. \"\"\" self . _x = 0 self . _y = 0 if not self . _driver : self . start_browser () try : self . _driver . get ( url ) except InvalidSessionIdException : if not is_retry : self . stop_browser () self . navigate_to ( url , is_retry = True )","title":"navigate_to()"},{"location":"bot/#botcity.web.bot.WebBot.page_down","text":"Press Page Down key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def page_down ( self , wait = 0 ): \"\"\" Press Page Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . PAGE_DOWN ) action . key_up ( Keys . PAGE_DOWN ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"page_down()"},{"location":"bot/#botcity.web.bot.WebBot.page_source","text":"Returns the active page source. Returns: Type Description soup (BeautifulSoup) BeautifulSoup object for the page source. Source code in web/bot.py def page_source ( self ): \"\"\" Returns the active page source. Returns: soup (BeautifulSoup): BeautifulSoup object for the page source. \"\"\" try : soup = BeautifulSoup ( self . _driver . page_source , 'html.parser' ) return soup except InvalidSessionIdException : return None","title":"page_source()"},{"location":"bot/#botcity.web.bot.WebBot.page_title","text":"Returns the active page title. Returns: Type Description title (str) The page title. Source code in web/bot.py def page_title ( self ): \"\"\" Returns the active page title. Returns: title (str): The page title. \"\"\" try : return self . _driver . title except InvalidSessionIdException : return None","title":"page_title()"},{"location":"bot/#botcity.web.bot.WebBot.page_up","text":"Press Page Up key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def page_up ( self , wait = 0 ): \"\"\" Press Page Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" # TODO: Investigate why with Firefox the key isn't working properly action = ActionChains ( self . _driver ) action . key_down ( Keys . PAGE_UP ) action . key_up ( Keys . PAGE_UP ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"page_up()"},{"location":"bot/#botcity.web.bot.WebBot.paste","text":"Paste content from the clipboard. Parameters: Name Type Description Default text str The text to be pasted. Defaults to None None wait int Wait interval (ms) after task 0 Source code in web/bot.py def paste ( self , text = None , wait = 0 ): \"\"\" Paste content from the clipboard. Args: text (str, optional): The text to be pasted. Defaults to None wait (int, optional): Wait interval (ms) after task \"\"\" text_to_paste = self . _clipboard if text : text_to_paste = text self . kb_type ( text_to_paste )","title":"paste()"},{"location":"bot/#botcity.web.bot.WebBot.print_pdf","text":"Print the current page as a PDF file. Parameters: Name Type Description Default path str The path for the file to be saved. Defaults to None. None print_options dict Print options as defined at. Defaults to None. None Returns: Type Description str the saved file path Source code in web/bot.py def print_pdf ( self , path = None , print_options = None ): \"\"\"Print the current page as a PDF file. Args: path (str, optional): The path for the file to be saved. Defaults to None. print_options (dict, optional): Print options as defined at. Defaults to None. Returns: str: the saved file path \"\"\" title = self . page_title () or \"document\" timeout = 60000 if not self . page_title (): timeout = 1000 default_path = os . path . expanduser ( os . path . join ( self . download_folder_path , f \" { title } .pdf\" )) if self . browser in [ Browser . CHROME , Browser . EDGE ] and not self . headless : # Chrome still does not support headless webdriver print # but Firefox does. self . execute_javascript ( \"window.print();\" ) # We need to wait for the file to be available in this case. self . wait_for_file ( default_path , timeout = timeout ) return default_path if print_options is None : print_options = { 'landscape' : False , 'displayHeaderFooter' : False , 'printBackground' : True , 'preferCSSPageSize' : True , 'marginTop' : 0 , 'marginBottom' : 0 } data = self . _webdriver_command ( \"print\" , print_options ) bytes_file = base64 . b64decode ( data ) if not path : path = default_path with open ( path , \"wb\" ) as f : f . write ( bytes_file ) return path","title":"print_pdf()"},{"location":"bot/#botcity.web.bot.WebBot.release_shift","text":"Release key Shift. This method needs to be invoked after holding Shift or similar. Source code in web/bot.py def release_shift ( self ): \"\"\" Release key Shift. This method needs to be invoked after holding Shift or similar. \"\"\" action = ActionChains ( self . _driver ) action . key_up ( Keys . SHIFT ) action . perform ()","title":"release_shift()"},{"location":"bot/#botcity.web.bot.WebBot.right_click","text":"Right click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 Source code in web/bot.py @only_if_element def right_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 ): \"\"\" Right click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. \"\"\" self . click ( clicks = clicks , button = 'right' , interval_between_clicks = interval_between_clicks ) self . sleep ( wait_after )","title":"right_click()"},{"location":"bot/#botcity.web.bot.WebBot.right_click_at","text":"Right click at the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in web/bot.py def right_click_at ( self , x , y ): \"\"\" Right click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" self . click_at ( x , y , button = 'right' )","title":"right_click_at()"},{"location":"bot/#botcity.web.bot.WebBot.right_click_relative","text":"Right Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def right_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Right Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , interval_between_clicks = interval_between_clicks , button = 'right' )","title":"right_click_relative()"},{"location":"bot/#botcity.web.bot.WebBot.save_screenshot","text":"Saves a screenshot in a given path. Parameters: Name Type Description Default path str The filepath in which to save the screenshot required Source code in web/bot.py def save_screenshot ( self , path ): \"\"\" Saves a screenshot in a given path. Args: path (str): The filepath in which to save the screenshot \"\"\" self . screenshot ( path )","title":"save_screenshot()"},{"location":"bot/#botcity.web.bot.WebBot.screen_cut","text":"Capture a screenshot from a region of the screen. Parameters: Name Type Description Default x int region start position x required y int region start position y required width int region width None height int region height None Returns: Type Description Image The screenshot Image object Source code in web/bot.py def screen_cut ( self , x , y , width = None , height = None ): \"\"\" Capture a screenshot from a region of the screen. Args: x (int): region start position x y (int): region start position y width (int): region width height (int): region height Returns: Image: The screenshot Image object \"\"\" screen_size = self . _dimensions x = x or 0 y = y or 0 width = width or screen_size [ 0 ] height = height or screen_size [ 1 ] img = self . screenshot ( region = ( x , y , width , height )) return img","title":"screen_cut()"},{"location":"bot/#botcity.web.bot.WebBot.screenshot","text":"Capture a screenshot. Parameters: Name Type Description Default filepath str The filepath in which to save the screenshot. Defaults to None. None region tuple Bounding box containing left, top, width and height to crop screenshot. None Returns: Type Description Image The screenshot Image object Source code in web/bot.py def screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" img = self . get_screen_image ( region ) if filepath : img . save ( filepath ) return img","title":"screenshot()"},{"location":"bot/#botcity.web.bot.WebBot.scroll_down","text":"Scroll Down n clicks Parameters: Name Type Description Default clicks int Number of times to scroll down. required Source code in web/bot.py def scroll_down ( self , clicks ): \"\"\" Scroll Down n clicks Args: clicks (int): Number of times to scroll down. \"\"\" for i in range ( clicks ): self . _driver . execute_script ( \"window.scrollTo(0, window.scrollY + 200)\" ) self . sleep ( 200 )","title":"scroll_down()"},{"location":"bot/#botcity.web.bot.WebBot.scroll_up","text":"Scroll Up n clicks Parameters: Name Type Description Default clicks int Number of times to scroll up. required Source code in web/bot.py def scroll_up ( self , clicks ): \"\"\" Scroll Up n clicks Args: clicks (int): Number of times to scroll up. \"\"\" for i in range ( clicks ): self . _driver . execute_script ( \"window.scrollTo(0, window.scrollY - 200)\" ) self . sleep ( 200 )","title":"scroll_up()"},{"location":"bot/#botcity.web.bot.WebBot.set_current_element","text":"Changes the current screen element the bot will interact when using click(), move(), and similar methods. This method is equivalent to self.state.element = element. Parameters: Name Type Description Default element Box A screen element from self.state.element or the find_all(as_list=True) method. required Source code in web/bot.py def set_current_element ( self , element : cv2find . Box ): \"\"\" Changes the current screen element the bot will interact when using click(), move(), and similar methods. This method is equivalent to self.state.element = element. Args: element (Box): A screen element from self.state.element or the find_all(as_list=True) method. \"\"\" self . state . element = element","title":"set_current_element()"},{"location":"bot/#botcity.web.bot.WebBot.set_file_input_element","text":"Configure the filepath for upload in a file element. Note: This method does not submit the form. Parameters: Name Type Description Default element WebElement The file upload element. required filepath str The path to the file to be uploaded. required Example: ... # Find element elem = self . find_element ( \"body > form > input[type=file]\" ) # Set the filepath self . set_file_input_element ( elem , \"./test.txt\" ) ... Source code in web/bot.py def set_file_input_element ( self , element : WebElement , filepath : str ): \"\"\"Configure the filepath for upload in a file element. Note: This method does not submit the form. Args: element (WebElement): The file upload element. filepath (str): The path to the file to be uploaded. **Example:** ```python ... # Find element elem = self.find_element(\"body > form > input[type=file]\") # Set the filepath self.set_file_input_element(elem, \"./test.txt\") ... ``` \"\"\" fpath = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( filepath ))) element . send_keys ( fpath )","title":"set_file_input_element()"},{"location":"bot/#botcity.web.bot.WebBot.set_screen_resolution","text":"Configures the browser dimensions. Parameters: Name Type Description Default width int The desired width. None height int The desired height. None Source code in web/bot.py def set_screen_resolution ( self , width = None , height = None ): \"\"\" Configures the browser dimensions. Args: width (int): The desired width. height (int): The desired height. \"\"\" self . _dimensions = ( width or 1600 , height or 900 ) if self . headless : # When running headless the window size is the viewport size window_size = self . _dimensions else : # When running non-headless we need to account for the borders and etc # So the size must be bigger to have the same viewport size as before window_size = self . _driver . execute_script ( \"\"\" return [window.outerWidth - window.innerWidth + arguments[0], window.outerHeight - window.innerHeight + arguments[1]]; \"\"\" , * self . _dimensions ) self . _driver . set_window_size ( * window_size )","title":"set_screen_resolution()"},{"location":"bot/#botcity.web.bot.WebBot.sleep","text":"Wait / Sleep for a given interval. Parameters: Name Type Description Default interval int Interval in milliseconds required Source code in web/bot.py def sleep ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" self . wait ( interval )","title":"sleep()"},{"location":"bot/#botcity.web.bot.WebBot.space","text":"Press Space key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def space ( self , wait = 0 ): \"\"\" Press Space key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . SPACE ) action . key_up ( Keys . SPACE ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"space()"},{"location":"bot/#botcity.web.bot.WebBot.start_browser","text":"Starts the selected browser. Source code in web/bot.py def start_browser ( self ): \"\"\" Starts the selected browser. \"\"\" def check_driver (): # Look for driver driver_name = BROWSER_CONFIGS . get ( self . browser ) . get ( \"driver\" ) location = shutil . which ( driver_name ) if not location : raise RuntimeError ( f \" { driver_name } was not found. Please make sure to have it on your PATH or set driver_path\" ) return location # Specific webdriver class for a given browser driver_class = BROWSER_CONFIGS . get ( self . browser ) . get ( \"class\" ) # Specific default options method for a given browser func_def_options = BROWSER_CONFIGS . get ( self . browser ) . get ( \"options\" ) # Specific capabilities method for a given browser func_def_capabilities = BROWSER_CONFIGS . get ( self . browser ) . get ( \"capabilities\" ) opt = self . options or func_def_options ( self . headless , self . _download_folder_path , None ) cap = self . capabilities or func_def_capabilities () self . options = opt self . capabilities = cap driver_path = self . driver_path or check_driver () self . driver_path = driver_path self . _driver = driver_class ( options = opt , desired_capabilities = cap , executable_path = driver_path ) self . set_screen_resolution ()","title":"start_browser()"},{"location":"bot/#botcity.web.bot.WebBot.stop_browser","text":"Stops the Chrome browser and clean up the User Data Directory. Source code in web/bot.py def stop_browser ( self ): \"\"\" Stops the Chrome browser and clean up the User Data Directory. \"\"\" if not self . _driver : return self . _driver . close () self . _driver . quit () self . _driver = None","title":"stop_browser()"},{"location":"bot/#botcity.web.bot.WebBot.tab","text":"Press key Tab Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def tab ( self , wait = 0 ): \"\"\" Press key Tab Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . TAB ) action . key_up ( Keys . TAB ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"tab()"},{"location":"bot/#botcity.web.bot.WebBot.triple_click","text":"Triple Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def triple_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( wait_after = wait_after , clicks = 3 )","title":"triple_click()"},{"location":"bot/#botcity.web.bot.WebBot.triple_click_relative","text":"Triple Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in web/bot.py @only_if_element def triple_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 3 , interval_between_clicks = interval_between_clicks )","title":"triple_click_relative()"},{"location":"bot/#botcity.web.bot.WebBot.type_down","text":"Press Down key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def type_down ( self , wait = 0 ): \"\"\" Press Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_DOWN ) action . key_up ( Keys . ARROW_DOWN ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"type_down()"},{"location":"bot/#botcity.web.bot.WebBot.type_keys","text":"Press a sequence of keys. Hold the keys in the specific order and releases them. Parameters: Name Type Description Default keys list List of keys to be pressed required Source code in web/bot.py def type_keys ( self , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: keys (list): List of keys to be pressed \"\"\" self . type_keys_with_interval ( 100 , keys )","title":"type_keys()"},{"location":"bot/#botcity.web.bot.WebBot.type_keys_with_interval","text":"Press a sequence of keys. Hold the keys in the specific order and releases them. Parameters: Name Type Description Default interval int Interval (ms) in which to press and release keys required keys list List of Keys to be pressed required Source code in web/bot.py def type_keys_with_interval ( self , interval , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: interval (int): Interval (ms) in which to press and release keys keys (list): List of Keys to be pressed \"\"\" action = ActionChains ( self . _driver ) for k in keys : action . key_down ( k ) action . pause ( interval / 1000.0 ) for k in reversed ( keys ): action . key_up ( k ) action . pause ( interval / 1000.0 ) action . perform ()","title":"type_keys_with_interval()"},{"location":"bot/#botcity.web.bot.WebBot.type_left","text":"Press Left key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def type_left ( self , wait = 0 ): \"\"\" Press Left key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_LEFT ) action . key_up ( Keys . ARROW_LEFT ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"type_left()"},{"location":"bot/#botcity.web.bot.WebBot.type_right","text":"Press Right key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def type_right ( self , wait = 0 ): \"\"\" Press Right key Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . key_right ( wait = wait )","title":"type_right()"},{"location":"bot/#botcity.web.bot.WebBot.type_up","text":"Press Up key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in web/bot.py def type_up ( self , wait = 0 ): \"\"\" Press Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" action = ActionChains ( self . _driver ) action . key_down ( Keys . ARROW_UP ) action . key_up ( Keys . ARROW_UP ) action . perform () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"type_up()"},{"location":"bot/#botcity.web.bot.WebBot.wait","text":"Wait / Sleep for a given interval. Parameters: Name Type Description Default interval int Interval in milliseconds required Source code in web/bot.py def wait ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" time . sleep ( interval / 1000.0 )","title":"wait()"},{"location":"bot/#botcity.web.bot.WebBot.wait_for_downloads","text":"Wait for all downloads to be finished. Beware that this method replaces the current page with the downloads window. Parameters: Name Type Description Default timeout int Timeout in millis. Defaults to 120000. 120000 Source code in web/bot.py def wait_for_downloads ( self , timeout : int = 120000 ): \"\"\" Wait for all downloads to be finished. Beware that this method replaces the current page with the downloads window. Args: timeout (int, optional): Timeout in millis. Defaults to 120000. \"\"\" wait_method = BROWSER_CONFIGS . get ( self . browser ) . get ( \"wait_for_downloads\" ) # waits for all the files to be completed WebDriverWait ( self . _driver , timeout / 1000 , 1 ) . until ( wait_method )","title":"wait_for_downloads()"},{"location":"bot/#botcity.web.bot.WebBot.wait_for_file","text":"Wait for a file to be available on disk. Parameters: Name Type Description Default path str The path for the file to be executed required timeout int Maximum wait time (ms) to search for a hit. Defaults to 60000ms (60s). 60000 Returns: Type Description status (bool) Whether or not the file was available before the timeout Source code in web/bot.py def wait_for_file ( self , path , timeout = 60000 ): \"\"\" Wait for a file to be available on disk. Args: path (str): The path for the file to be executed timeout (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 60000ms (60s). Returns: status (bool): Whether or not the file was available before the timeout \"\"\" path = os . path . abspath ( os . path . expanduser ( os . path . expandvars ( path ))) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > timeout : return False if os . path . isfile ( path ) and os . access ( path , os . R_OK ): if self . browser == Browser . FIREFOX and os . path . exists ( path + '.part' ): # if *.part exists, the download is not completed. continue return True self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION )","title":"wait_for_file()"},{"location":"browsers/","text":"Browsers Every supported browser has a default set of options and capabilities curated for you that are used by default. In case you need to customize the options or capabilities you can do so via the default_options and default_capabilities methods available within each browser module. Here is an example on how to do that: from botcity.web import WebBot , Browser # For Chrome from botcity.web.browsers.chrome import default_options , default_capabilities # For Firefox #from botcity.web.browsers.firefox import default_options, default_capabilities # For Edge #from botcity.web.browsers.edge import default_options, default_capabilities class Bot ( WebBot ): def action ( self , execution = None ): # Configure whether or not to run on headless mode self . headless = False # Fetch the default options for my preferred browser # Pass in the headless, download_folder_path and user_data_dir # to be used when building the default_options def_options = default_options ( headless = self . headless , download_folder_path = self . download_folder_path , user_data_dir = None # Informing None here will generate a temporary directory ) # Add your customized argument def_options . add_argument ( \"<My Special Argument>\" ) # Update the options to use the customized Options. self . options = def_options # Fetch the default options for my preferred browser def_capabilities = default_capabilities () # Set of modify the key and value for my desired capability def_capabilities [ \"<My Special Parameter>\" ] = \"special value\" # Update the capabilities to use the customized configurations. self . capabilities = def_capabilities ... Specific Browser Modules Here are the documentation for the methods mentioned above for each of the supported browsers. Chrome botcity . web . browsers . chrome . default_options ( headless = False , download_folder_path = None , user_data_dir = None ) Retrieve the default options for this browser curated by BotCity. Parameters: Name Type Description Default headless bool Whether or not to use the headless mode. Defaults to False. False download_folder_path str The default path in which to save files. If None, the current directory is used. Defaults to None. None user_data_dir [type] The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. None Returns: Type Description ChromeOptions The Chrome options. Source code in web/browsers/chrome.py def default_options ( headless = False , download_folder_path = None , user_data_dir = None ) -> ChromeOptions : \"\"\"Retrieve the default options for this browser curated by BotCity. Args: headless (bool, optional): Whether or not to use the headless mode. Defaults to False. download_folder_path (str, optional): The default path in which to save files. If None, the current directory is used. Defaults to None. user_data_dir ([type], optional): The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. Returns: ChromeOptions: The Chrome options. \"\"\" chrome_options = ChromeOptions () chrome_options . add_argument ( \"--remote-debugging-port=0\" ) chrome_options . add_argument ( \"--no-first-run\" ) chrome_options . add_argument ( \"--no-default-browser-check\" ) chrome_options . add_argument ( \"--disable-background-networking\" ) chrome_options . add_argument ( \"--disable-background-timer-throttling\" ) chrome_options . add_argument ( \"--disable-client-side-phishing-detection\" ) chrome_options . add_argument ( \"--disable-default-apps\" ) chrome_options . add_argument ( \"--disable-extensions\" ) chrome_options . add_argument ( \"--disable-hang-monitor\" ) chrome_options . add_argument ( \"--disable-popup-blocking\" ) chrome_options . add_argument ( \"--disable-prompt-on-repost\" ) chrome_options . add_argument ( \"--disable-syncdisable-translate\" ) chrome_options . add_argument ( \"--metrics-recording-only\" ) chrome_options . add_argument ( \"--safebrowsing-disable-auto-update\" ) chrome_options . add_argument ( \"--disable-blink-features=AutomationControlled\" ) # Disable banner for Browser being remote-controlled chrome_options . add_experimental_option ( \"excludeSwitches\" , [ \"enable-automation\" ]) chrome_options . add_experimental_option ( 'useAutomationExtension' , False ) if headless : chrome_options . add_argument ( \"--headless\" ) chrome_options . add_argument ( \"--disable-gpu\" ) chrome_options . add_argument ( \"--hide-scrollbars\" ) chrome_options . add_argument ( \"--mute-audio\" ) if not user_data_dir : temp_dir = tempfile . TemporaryDirectory ( prefix = \"botcity_\" ) user_data_dir = temp_dir . name atexit . register ( cleanup_temp_dir , temp_dir ) chrome_options . add_argument ( f \"--user-data-dir= { user_data_dir } \" ) if not download_folder_path : download_folder_path = os . getcwd () app_state = { 'recentDestinations' : [{ 'id' : 'Save as PDF' , 'origin' : 'local' , 'account' : '' }], 'selectedDestinationId' : 'Save as PDF' , 'version' : 2 } # Set the Downloads default folder prefs = { \"printing.print_preview_sticky_settings.appState\" : json . dumps ( app_state ), \"download.default_directory\" : download_folder_path , \"savefile.default_directory\" : download_folder_path , \"printing.default_destination_selection_rules\" : { \"kind\" : \"local\" , \"namePattern\" : \"Save as PDF\" , }, \"safebrowsing.enabled\" : True , \"credentials_enable_service\" : False , \"profile.password_manager_enabled\" : False } chrome_options . add_experimental_option ( \"prefs\" , prefs ) chrome_options . add_argument ( \"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" ) chrome_options . add_argument ( \"--kiosk-printing\" ) return chrome_options botcity . web . browsers . chrome . default_capabilities () Fetch the default capabilities for this browser. Returns: Type Description Dict Dictionary with the default capabilities defined. Source code in web/browsers/chrome.py def default_capabilities () -> Dict : \"\"\"Fetch the default capabilities for this browser. Returns: Dict: Dictionary with the default capabilities defined. \"\"\" return DesiredCapabilities . CHROME . copy () Firefox botcity . web . browsers . firefox . default_options ( headless = False , download_folder_path = None , user_data_dir = None ) Retrieve the default options for this browser curated by BotCity. Parameters: Name Type Description Default headless bool Whether or not to use the headless mode. Defaults to False. False download_folder_path str The default path in which to save files. If None, the current directory is used. Defaults to None. None user_data_dir [type] The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. None Returns: Type Description FirefoxOptions The Firefox options. Source code in web/browsers/firefox.py def default_options ( headless = False , download_folder_path = None , user_data_dir = None ) -> FirefoxOptions : \"\"\"Retrieve the default options for this browser curated by BotCity. Args: headless (bool, optional): Whether or not to use the headless mode. Defaults to False. download_folder_path (str, optional): The default path in which to save files. If None, the current directory is used. Defaults to None. user_data_dir ([type], optional): The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. Returns: FirefoxOptions: The Firefox options. \"\"\" firefox_options = FirefoxOptions () firefox_options . headless = headless if not user_data_dir : temp_dir = tempfile . TemporaryDirectory ( prefix = \"botcity_\" ) user_data_dir = temp_dir . name atexit . register ( cleanup_temp_dir , temp_dir ) firefox_profile = webdriver . FirefoxProfile ( user_data_dir ) firefox_profile . set_preference ( \"security.default_personal_cert\" , \"Select Automatically\" ) firefox_profile . set_preference ( 'browser.download.folderList' , 2 ) firefox_profile . set_preference ( 'browser.download.manager.showWhenStarting' , False ) if not download_folder_path : download_folder_path = os . getcwd () firefox_profile . set_preference ( 'browser.download.dir' , download_folder_path ) firefox_profile . set_preference ( 'general.warnOnAboutConfig' , False ) mimetypes_to_download = \",\" . join ( FIREFOX_MIMETYPES_TO_DOWNLOAD ) firefox_profile . set_preference ( \"pdfjs.disabled\" , True ) firefox_profile . set_preference ( \"plugin.disable_full_page_plugin_for_types\" , mimetypes_to_download ) firefox_profile . set_preference ( 'browser.helperApps.neverAsk.saveToDisk' , mimetypes_to_download ) firefox_profile . update_preferences () firefox_options . profile = firefox_profile return firefox_options botcity . web . browsers . firefox . default_capabilities () Fetch the default capabilities for this browser. Returns: Type Description Dict Dictionary with the default capabilities defined. Source code in web/browsers/firefox.py def default_capabilities () -> Dict : \"\"\"Fetch the default capabilities for this browser. Returns: Dict: Dictionary with the default capabilities defined. \"\"\" return DesiredCapabilities . FIREFOX . copy () Edge botcity . web . browsers . edge . default_options ( headless = False , download_folder_path = None , user_data_dir = None ) Retrieve the default options for this browser curated by BotCity. Parameters: Name Type Description Default headless bool Whether or not to use the headless mode. Defaults to False. False download_folder_path str The default path in which to save files. If None, the current directory is used. Defaults to None. None user_data_dir [type] The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. None Returns: Type Description EdgeOptions The Edge options. Source code in web/browsers/edge.py def default_options ( headless = False , download_folder_path = None , user_data_dir = None ) -> EdgeOptions : \"\"\"Retrieve the default options for this browser curated by BotCity. Args: headless (bool, optional): Whether or not to use the headless mode. Defaults to False. download_folder_path (str, optional): The default path in which to save files. If None, the current directory is used. Defaults to None. user_data_dir ([type], optional): The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. Returns: EdgeOptions: The Edge options. \"\"\" edge_options = EdgeOptions () edge_options . use_chromium = True edge_options . add_argument ( \"--remote-debugging-port=0\" ) edge_options . add_argument ( \"--no-first-run\" ) edge_options . add_argument ( \"--no-default-browser-check\" ) edge_options . add_argument ( \"--disable-background-networking\" ) edge_options . add_argument ( \"--disable-background-timer-throttling\" ) edge_options . add_argument ( \"--disable-client-side-phishing-detection\" ) edge_options . add_argument ( \"--disable-default-apps\" ) edge_options . add_argument ( \"--disable-extensions\" ) edge_options . add_argument ( \"--disable-hang-monitor\" ) edge_options . add_argument ( \"--disable-popup-blocking\" ) edge_options . add_argument ( \"--disable-prompt-on-repost\" ) edge_options . add_argument ( \"--disable-syncdisable-translate\" ) edge_options . add_argument ( \"--metrics-recording-only\" ) edge_options . add_argument ( \"--safebrowsing-disable-auto-update\" ) edge_options . add_argument ( \"--disable-blink-features=AutomationControlled\" ) # Disable banner for Browser being remote-controlled edge_options . add_experimental_option ( \"excludeSwitches\" , [ \"enable-automation\" ]) edge_options . add_experimental_option ( 'useAutomationExtension' , False ) if headless : edge_options . add_argument ( \"--headless\" ) edge_options . add_argument ( \"--disable-gpu\" ) edge_options . add_argument ( \"--hide-scrollbars\" ) edge_options . add_argument ( \"--mute-audio\" ) if not user_data_dir : temp_dir = tempfile . TemporaryDirectory ( prefix = \"botcity_\" ) user_data_dir = temp_dir . name atexit . register ( cleanup_temp_dir , temp_dir ) edge_options . add_argument ( f \"--user-data-dir= { user_data_dir } \" ) if not download_folder_path : download_folder_path = os . getcwd () app_state = { \"recentDestinations\" : [{ \"id\" : \"Save as PDF\" , \"origin\" : \"local\" , \"account\" : \"\" }], \"selectedDestinationId\" : \"Save as PDF\" , \"version\" : 2 , \"isHeaderFooterEnabled\" : False , \"marginsType\" : 2 , \"isCssBackgroundEnabled\" : True } # Set the Downloads default folder prefs = { \"printing.print_preview_sticky_settings.appState\" : json . dumps ( app_state ), \"download.default_directory\" : download_folder_path , \"savefile.default_directory\" : download_folder_path , \"printing.default_destination_selection_rules\" : { \"kind\" : \"local\" , \"namePattern\" : \"Save as PDF\" , }, \"safebrowsing.enabled\" : True , \"credentials_enable_service\" : False , \"profile.password_manager_enabled\" : False } edge_options . add_experimental_option ( \"prefs\" , prefs ) edge_options . add_argument ( \"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" ) edge_options . add_argument ( \"--kiosk-printing\" ) return edge_options botcity . web . browsers . edge . default_capabilities () Fetch the default capabilities for this browser. Returns: Type Description Dict Dictionary with the default capabilities defined. Source code in web/browsers/edge.py def default_capabilities () -> Dict : \"\"\"Fetch the default capabilities for this browser. Returns: Dict: Dictionary with the default capabilities defined. \"\"\" return DesiredCapabilities . EDGE . copy ()","title":"Browsers"},{"location":"browsers/#browsers","text":"Every supported browser has a default set of options and capabilities curated for you that are used by default. In case you need to customize the options or capabilities you can do so via the default_options and default_capabilities methods available within each browser module. Here is an example on how to do that: from botcity.web import WebBot , Browser # For Chrome from botcity.web.browsers.chrome import default_options , default_capabilities # For Firefox #from botcity.web.browsers.firefox import default_options, default_capabilities # For Edge #from botcity.web.browsers.edge import default_options, default_capabilities class Bot ( WebBot ): def action ( self , execution = None ): # Configure whether or not to run on headless mode self . headless = False # Fetch the default options for my preferred browser # Pass in the headless, download_folder_path and user_data_dir # to be used when building the default_options def_options = default_options ( headless = self . headless , download_folder_path = self . download_folder_path , user_data_dir = None # Informing None here will generate a temporary directory ) # Add your customized argument def_options . add_argument ( \"<My Special Argument>\" ) # Update the options to use the customized Options. self . options = def_options # Fetch the default options for my preferred browser def_capabilities = default_capabilities () # Set of modify the key and value for my desired capability def_capabilities [ \"<My Special Parameter>\" ] = \"special value\" # Update the capabilities to use the customized configurations. self . capabilities = def_capabilities ...","title":"Browsers"},{"location":"browsers/#specific-browser-modules","text":"Here are the documentation for the methods mentioned above for each of the supported browsers.","title":"Specific Browser Modules"},{"location":"browsers/#chrome","text":"","title":"Chrome"},{"location":"browsers/#botcity.web.browsers.chrome.default_options","text":"Retrieve the default options for this browser curated by BotCity. Parameters: Name Type Description Default headless bool Whether or not to use the headless mode. Defaults to False. False download_folder_path str The default path in which to save files. If None, the current directory is used. Defaults to None. None user_data_dir [type] The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. None Returns: Type Description ChromeOptions The Chrome options. Source code in web/browsers/chrome.py def default_options ( headless = False , download_folder_path = None , user_data_dir = None ) -> ChromeOptions : \"\"\"Retrieve the default options for this browser curated by BotCity. Args: headless (bool, optional): Whether or not to use the headless mode. Defaults to False. download_folder_path (str, optional): The default path in which to save files. If None, the current directory is used. Defaults to None. user_data_dir ([type], optional): The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. Returns: ChromeOptions: The Chrome options. \"\"\" chrome_options = ChromeOptions () chrome_options . add_argument ( \"--remote-debugging-port=0\" ) chrome_options . add_argument ( \"--no-first-run\" ) chrome_options . add_argument ( \"--no-default-browser-check\" ) chrome_options . add_argument ( \"--disable-background-networking\" ) chrome_options . add_argument ( \"--disable-background-timer-throttling\" ) chrome_options . add_argument ( \"--disable-client-side-phishing-detection\" ) chrome_options . add_argument ( \"--disable-default-apps\" ) chrome_options . add_argument ( \"--disable-extensions\" ) chrome_options . add_argument ( \"--disable-hang-monitor\" ) chrome_options . add_argument ( \"--disable-popup-blocking\" ) chrome_options . add_argument ( \"--disable-prompt-on-repost\" ) chrome_options . add_argument ( \"--disable-syncdisable-translate\" ) chrome_options . add_argument ( \"--metrics-recording-only\" ) chrome_options . add_argument ( \"--safebrowsing-disable-auto-update\" ) chrome_options . add_argument ( \"--disable-blink-features=AutomationControlled\" ) # Disable banner for Browser being remote-controlled chrome_options . add_experimental_option ( \"excludeSwitches\" , [ \"enable-automation\" ]) chrome_options . add_experimental_option ( 'useAutomationExtension' , False ) if headless : chrome_options . add_argument ( \"--headless\" ) chrome_options . add_argument ( \"--disable-gpu\" ) chrome_options . add_argument ( \"--hide-scrollbars\" ) chrome_options . add_argument ( \"--mute-audio\" ) if not user_data_dir : temp_dir = tempfile . TemporaryDirectory ( prefix = \"botcity_\" ) user_data_dir = temp_dir . name atexit . register ( cleanup_temp_dir , temp_dir ) chrome_options . add_argument ( f \"--user-data-dir= { user_data_dir } \" ) if not download_folder_path : download_folder_path = os . getcwd () app_state = { 'recentDestinations' : [{ 'id' : 'Save as PDF' , 'origin' : 'local' , 'account' : '' }], 'selectedDestinationId' : 'Save as PDF' , 'version' : 2 } # Set the Downloads default folder prefs = { \"printing.print_preview_sticky_settings.appState\" : json . dumps ( app_state ), \"download.default_directory\" : download_folder_path , \"savefile.default_directory\" : download_folder_path , \"printing.default_destination_selection_rules\" : { \"kind\" : \"local\" , \"namePattern\" : \"Save as PDF\" , }, \"safebrowsing.enabled\" : True , \"credentials_enable_service\" : False , \"profile.password_manager_enabled\" : False } chrome_options . add_experimental_option ( \"prefs\" , prefs ) chrome_options . add_argument ( \"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" ) chrome_options . add_argument ( \"--kiosk-printing\" ) return chrome_options","title":"default_options()"},{"location":"browsers/#botcity.web.browsers.chrome.default_capabilities","text":"Fetch the default capabilities for this browser. Returns: Type Description Dict Dictionary with the default capabilities defined. Source code in web/browsers/chrome.py def default_capabilities () -> Dict : \"\"\"Fetch the default capabilities for this browser. Returns: Dict: Dictionary with the default capabilities defined. \"\"\" return DesiredCapabilities . CHROME . copy ()","title":"default_capabilities()"},{"location":"browsers/#firefox","text":"","title":"Firefox"},{"location":"browsers/#botcity.web.browsers.firefox.default_options","text":"Retrieve the default options for this browser curated by BotCity. Parameters: Name Type Description Default headless bool Whether or not to use the headless mode. Defaults to False. False download_folder_path str The default path in which to save files. If None, the current directory is used. Defaults to None. None user_data_dir [type] The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. None Returns: Type Description FirefoxOptions The Firefox options. Source code in web/browsers/firefox.py def default_options ( headless = False , download_folder_path = None , user_data_dir = None ) -> FirefoxOptions : \"\"\"Retrieve the default options for this browser curated by BotCity. Args: headless (bool, optional): Whether or not to use the headless mode. Defaults to False. download_folder_path (str, optional): The default path in which to save files. If None, the current directory is used. Defaults to None. user_data_dir ([type], optional): The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. Returns: FirefoxOptions: The Firefox options. \"\"\" firefox_options = FirefoxOptions () firefox_options . headless = headless if not user_data_dir : temp_dir = tempfile . TemporaryDirectory ( prefix = \"botcity_\" ) user_data_dir = temp_dir . name atexit . register ( cleanup_temp_dir , temp_dir ) firefox_profile = webdriver . FirefoxProfile ( user_data_dir ) firefox_profile . set_preference ( \"security.default_personal_cert\" , \"Select Automatically\" ) firefox_profile . set_preference ( 'browser.download.folderList' , 2 ) firefox_profile . set_preference ( 'browser.download.manager.showWhenStarting' , False ) if not download_folder_path : download_folder_path = os . getcwd () firefox_profile . set_preference ( 'browser.download.dir' , download_folder_path ) firefox_profile . set_preference ( 'general.warnOnAboutConfig' , False ) mimetypes_to_download = \",\" . join ( FIREFOX_MIMETYPES_TO_DOWNLOAD ) firefox_profile . set_preference ( \"pdfjs.disabled\" , True ) firefox_profile . set_preference ( \"plugin.disable_full_page_plugin_for_types\" , mimetypes_to_download ) firefox_profile . set_preference ( 'browser.helperApps.neverAsk.saveToDisk' , mimetypes_to_download ) firefox_profile . update_preferences () firefox_options . profile = firefox_profile return firefox_options","title":"default_options()"},{"location":"browsers/#botcity.web.browsers.firefox.default_capabilities","text":"Fetch the default capabilities for this browser. Returns: Type Description Dict Dictionary with the default capabilities defined. Source code in web/browsers/firefox.py def default_capabilities () -> Dict : \"\"\"Fetch the default capabilities for this browser. Returns: Dict: Dictionary with the default capabilities defined. \"\"\" return DesiredCapabilities . FIREFOX . copy ()","title":"default_capabilities()"},{"location":"browsers/#edge","text":"","title":"Edge"},{"location":"browsers/#botcity.web.browsers.edge.default_options","text":"Retrieve the default options for this browser curated by BotCity. Parameters: Name Type Description Default headless bool Whether or not to use the headless mode. Defaults to False. False download_folder_path str The default path in which to save files. If None, the current directory is used. Defaults to None. None user_data_dir [type] The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. None Returns: Type Description EdgeOptions The Edge options. Source code in web/browsers/edge.py def default_options ( headless = False , download_folder_path = None , user_data_dir = None ) -> EdgeOptions : \"\"\"Retrieve the default options for this browser curated by BotCity. Args: headless (bool, optional): Whether or not to use the headless mode. Defaults to False. download_folder_path (str, optional): The default path in which to save files. If None, the current directory is used. Defaults to None. user_data_dir ([type], optional): The directory to use as user profile. If None, a new temporary directory is used. Defaults to None. Returns: EdgeOptions: The Edge options. \"\"\" edge_options = EdgeOptions () edge_options . use_chromium = True edge_options . add_argument ( \"--remote-debugging-port=0\" ) edge_options . add_argument ( \"--no-first-run\" ) edge_options . add_argument ( \"--no-default-browser-check\" ) edge_options . add_argument ( \"--disable-background-networking\" ) edge_options . add_argument ( \"--disable-background-timer-throttling\" ) edge_options . add_argument ( \"--disable-client-side-phishing-detection\" ) edge_options . add_argument ( \"--disable-default-apps\" ) edge_options . add_argument ( \"--disable-extensions\" ) edge_options . add_argument ( \"--disable-hang-monitor\" ) edge_options . add_argument ( \"--disable-popup-blocking\" ) edge_options . add_argument ( \"--disable-prompt-on-repost\" ) edge_options . add_argument ( \"--disable-syncdisable-translate\" ) edge_options . add_argument ( \"--metrics-recording-only\" ) edge_options . add_argument ( \"--safebrowsing-disable-auto-update\" ) edge_options . add_argument ( \"--disable-blink-features=AutomationControlled\" ) # Disable banner for Browser being remote-controlled edge_options . add_experimental_option ( \"excludeSwitches\" , [ \"enable-automation\" ]) edge_options . add_experimental_option ( 'useAutomationExtension' , False ) if headless : edge_options . add_argument ( \"--headless\" ) edge_options . add_argument ( \"--disable-gpu\" ) edge_options . add_argument ( \"--hide-scrollbars\" ) edge_options . add_argument ( \"--mute-audio\" ) if not user_data_dir : temp_dir = tempfile . TemporaryDirectory ( prefix = \"botcity_\" ) user_data_dir = temp_dir . name atexit . register ( cleanup_temp_dir , temp_dir ) edge_options . add_argument ( f \"--user-data-dir= { user_data_dir } \" ) if not download_folder_path : download_folder_path = os . getcwd () app_state = { \"recentDestinations\" : [{ \"id\" : \"Save as PDF\" , \"origin\" : \"local\" , \"account\" : \"\" }], \"selectedDestinationId\" : \"Save as PDF\" , \"version\" : 2 , \"isHeaderFooterEnabled\" : False , \"marginsType\" : 2 , \"isCssBackgroundEnabled\" : True } # Set the Downloads default folder prefs = { \"printing.print_preview_sticky_settings.appState\" : json . dumps ( app_state ), \"download.default_directory\" : download_folder_path , \"savefile.default_directory\" : download_folder_path , \"printing.default_destination_selection_rules\" : { \"kind\" : \"local\" , \"namePattern\" : \"Save as PDF\" , }, \"safebrowsing.enabled\" : True , \"credentials_enable_service\" : False , \"profile.password_manager_enabled\" : False } edge_options . add_experimental_option ( \"prefs\" , prefs ) edge_options . add_argument ( \"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\" ) edge_options . add_argument ( \"--kiosk-printing\" ) return edge_options","title":"default_options()"},{"location":"browsers/#botcity.web.browsers.edge.default_capabilities","text":"Fetch the default capabilities for this browser. Returns: Type Description Dict Dictionary with the default capabilities defined. Source code in web/browsers/edge.py def default_capabilities () -> Dict : \"\"\"Fetch the default capabilities for this browser. Returns: Dict: Dictionary with the default capabilities defined. \"\"\" return DesiredCapabilities . EDGE . copy ()","title":"default_capabilities()"},{"location":"intro/","text":"Getting Started Supported Browsers This framework leverages the WebDriver API in order to communicate with browsers for Automation. In doing so, it requires that the WebDriver for the chosen browser to be installed and available preferrably in your PATH . If you can't add the necessary WebDriver to your PATH you will be able to inform the driver path via code in your bot. Here is a list of supported browsers along with links for you to download the proper WebDriver: Browser WebDriver Download Chrome ChromeDriver Firefox GeckoDriver Edge MSDriverEdge Please follow the instructions on the WebDriver website for installation and setup. Once the desired WebDriver for the Web Browser to be used is installed we can proceed to the next steps. WebBot After you installed this package, the next step is to import the package into your code and start using the WebBot class to build your RPA pipeline. from botcity.web import * Template Project We created a template project using Cookiecutter to help you create new bots using BotCity's Python Framework. Take a look into the template project website for more information on how to use it and get started. Customizing the Browser To provide flexibility we have properties to allow you to configure which browser to use, the WebDriver location as well as the options used when launching the browser. Over the next steps we will over the possible customizations in detail. Selecting the Browser The WebBot class by default comes configured to run with Google Chrome . You can select any other available browser by setting the browser property to one of the Browser enum available values. Here is an example on how to change the default browser to be used: from botcity.web import WebBot , Browser class Bot ( WebBot ): def action ( self , execution = None ): # Configure whether or not to run on headless mode self . headless = False # Changes the Browser to Firefox self . browser = Browser . FIREFOX # For Chrome # self.browser = Browser.CHROME ... From the snippet above the key takeaway is the self.browser piece in which we set it to one of the values from the Browser enum as mentioned before. Defining the WebDriver Path If your WebDriver for the selected browser is not available on the system PATH you can inform the location via the driver_path property. Here is how that can be done: from botcity.web import WebBot , Browser class Bot ( WebBot ): def action ( self , execution = None ): # Configure whether or not to run on headless mode self . headless = False # Inform the WebDriver path for Google Chrome's chromedriver self . driver_path = \"/home/username/drivers/chromedriver\" ... Customizing Browser Options By default the browsers are launched with a set of curated options which we picked as essential. Before getting into how to customize those details let's walk through some of the assumptions and details which are covered by the default options . Headless Execution : Depending on the headless property set on your Bot class we pick the proper configuration to launch the browser in the desired mode. Downloads Folder Path : By default we save all downloaded files on the Desktop folder. User Profile : By default we generate a temporary directory (which is later erased) to be used as the profile directory. This procedure ensure that every execution starts with a clean browser session and things such as cookies and stored passwords or certificates from one execution won't interfere with the others. A handful of other options are also set and they can be inspected on the source code for each browser on the botcity.web.browsers module. If you really need to customize the options you can do so via the options property. You can fetch the default options curated by BotCity and make your changes or start your options from scratch. In the following snippet we will cover how to build on top of the existing options. from botcity.web import WebBot , Browser # For Chrome from botcity.web.browsers.chrome import default_options # For Firefox #from botcity.web.browsers.firefox import default_options class Bot ( WebBot ): def action ( self , execution = None ): # Configure whether or not to run on headless mode self . headless = False # Fetch the default options for my preferred browser # Pass in the headless, download_folder_path and user_data_dir # to be used when building the default_options def_options = default_options ( headless = self . headless , download_folder_path = self . download_folder_path , user_data_dir = None # Informing None here will generate a temporary directory ) # Add your customized argument def_options . add_argument ( \"<My Special Argument>\" ) # Update the options to use the customized Options. self . options = def_options ... Every supported browser will have an exclusive module with curated default options accessible via the module's default_options function. This function takes in arguments to define the mode of execution (headless or not), default download folder path and user data/profile directory. Next Steps Check our examples and experiment with the API. Let us know where it can be improved. Have fun automating!","title":"Getting Started"},{"location":"intro/#getting-started","text":"","title":"Getting Started"},{"location":"intro/#supported-browsers","text":"This framework leverages the WebDriver API in order to communicate with browsers for Automation. In doing so, it requires that the WebDriver for the chosen browser to be installed and available preferrably in your PATH . If you can't add the necessary WebDriver to your PATH you will be able to inform the driver path via code in your bot. Here is a list of supported browsers along with links for you to download the proper WebDriver: Browser WebDriver Download Chrome ChromeDriver Firefox GeckoDriver Edge MSDriverEdge Please follow the instructions on the WebDriver website for installation and setup. Once the desired WebDriver for the Web Browser to be used is installed we can proceed to the next steps.","title":"Supported Browsers"},{"location":"intro/#webbot","text":"After you installed this package, the next step is to import the package into your code and start using the WebBot class to build your RPA pipeline. from botcity.web import *","title":"WebBot"},{"location":"intro/#template-project","text":"We created a template project using Cookiecutter to help you create new bots using BotCity's Python Framework. Take a look into the template project website for more information on how to use it and get started.","title":"Template Project"},{"location":"intro/#customizing-the-browser","text":"To provide flexibility we have properties to allow you to configure which browser to use, the WebDriver location as well as the options used when launching the browser. Over the next steps we will over the possible customizations in detail.","title":"Customizing the Browser"},{"location":"intro/#selecting-the-browser","text":"The WebBot class by default comes configured to run with Google Chrome . You can select any other available browser by setting the browser property to one of the Browser enum available values. Here is an example on how to change the default browser to be used: from botcity.web import WebBot , Browser class Bot ( WebBot ): def action ( self , execution = None ): # Configure whether or not to run on headless mode self . headless = False # Changes the Browser to Firefox self . browser = Browser . FIREFOX # For Chrome # self.browser = Browser.CHROME ... From the snippet above the key takeaway is the self.browser piece in which we set it to one of the values from the Browser enum as mentioned before.","title":"Selecting the Browser"},{"location":"intro/#defining-the-webdriver-path","text":"If your WebDriver for the selected browser is not available on the system PATH you can inform the location via the driver_path property. Here is how that can be done: from botcity.web import WebBot , Browser class Bot ( WebBot ): def action ( self , execution = None ): # Configure whether or not to run on headless mode self . headless = False # Inform the WebDriver path for Google Chrome's chromedriver self . driver_path = \"/home/username/drivers/chromedriver\" ...","title":"Defining the WebDriver Path"},{"location":"intro/#customizing-browser-options","text":"By default the browsers are launched with a set of curated options which we picked as essential. Before getting into how to customize those details let's walk through some of the assumptions and details which are covered by the default options . Headless Execution : Depending on the headless property set on your Bot class we pick the proper configuration to launch the browser in the desired mode. Downloads Folder Path : By default we save all downloaded files on the Desktop folder. User Profile : By default we generate a temporary directory (which is later erased) to be used as the profile directory. This procedure ensure that every execution starts with a clean browser session and things such as cookies and stored passwords or certificates from one execution won't interfere with the others. A handful of other options are also set and they can be inspected on the source code for each browser on the botcity.web.browsers module. If you really need to customize the options you can do so via the options property. You can fetch the default options curated by BotCity and make your changes or start your options from scratch. In the following snippet we will cover how to build on top of the existing options. from botcity.web import WebBot , Browser # For Chrome from botcity.web.browsers.chrome import default_options # For Firefox #from botcity.web.browsers.firefox import default_options class Bot ( WebBot ): def action ( self , execution = None ): # Configure whether or not to run on headless mode self . headless = False # Fetch the default options for my preferred browser # Pass in the headless, download_folder_path and user_data_dir # to be used when building the default_options def_options = default_options ( headless = self . headless , download_folder_path = self . download_folder_path , user_data_dir = None # Informing None here will generate a temporary directory ) # Add your customized argument def_options . add_argument ( \"<My Special Argument>\" ) # Update the options to use the customized Options. self . options = def_options ... Every supported browser will have an exclusive module with curated default options accessible via the module's default_options function. This function takes in arguments to define the mode of execution (headless or not), default download folder path and user data/profile directory.","title":"Customizing Browser Options"},{"location":"intro/#next-steps","text":"Check our examples and experiment with the API. Let us know where it can be improved. Have fun automating!","title":"Next Steps"}]}
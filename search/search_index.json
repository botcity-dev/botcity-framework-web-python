{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to BotCity's Framework Web Python package for RPA. </p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#latest-release","title":"Latest release","text":""},{"location":"#using-pypi","title":"Using PyPI","text":"<pre><code>pip install botcity-framework-web\n</code></pre>"},{"location":"#using-conda-forge-coming-soon","title":"Using conda-forge - Coming Soon","text":"<pre><code>conda install -c conda-forge botcity-framework-web\n</code></pre>"},{"location":"#latest-code","title":"Latest code","text":"<pre><code>pip install git+https://github.com/botcity-dev/botcity-framework-web-python.git\n</code></pre>"},{"location":"bot/","title":"Framework","text":"<p>The <code>botcity.web</code> module contains specialized implementations aimed at Web automation such as <code>WebBot</code> which is described below.</p> <p>You are expected to implement the <code>action</code> method of the <code>WebBot</code> class in your Bot class.</p> <p>Here is a very brief example of a bot which opens the BotCity website using Google Chrome and  the ChromeDriver WebDriver to remote control the browser.</p> <pre><code>from botcity.web import WebBot\n\n\nclass Bot(WebBot):\n    def action(self, execution=None\n        # Configure whether or not to run on headless mode\n        self.headless = False\n\n        # Opens the BotCity website.\n        self.browse(\"https://botcity.dev/en\")\n\n        # Wait for 10 seconds before closing everything\n        self.sleep(10000)\n\n        # Stop the browser and clean up\n        self.stop_browser()\n\n\nif __name__ == '__main__':\n    Bot.main()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot","title":"<code> botcity.web.bot.WebBot            (BaseBot)         </code>","text":"Source code in <code>web/bot.py</code> <pre><code>class WebBot(BaseBot):\n    KEYS = Keys\n    DEFAULT_DIMENSIONS = (1600, 900)\n\"\"\"\n    Base class for Web Bots.\n    Users must implement the `action` method in their classes.\n\n    Attributes:\n        state (State): The internal state of this bot.\n        maestro (BotMaestroSDK): an instance to interact with the BotMaestro server.\n\n    \"\"\"\n\n    def __init__(self, headless=False):\n        self.state = State()\n        self.maestro = BotMaestroSDK() if MAESTRO_AVAILABLE else None\n\n        self._browser = Browser.CHROME\n        self._options = None\n        self._capabilities = None\n        self._driver_path = None\n\n        self._driver = None\n        self._headless = headless\n        self._page_load_strategy = PageLoadStrategy.NORMAL\n\n        self._clipboard = \"\"\n\n        # Stub mouse coordinates\n        self._html_elem = None\n        self._x = 0\n        self._y = 0\n\n        # State for Key modifiers\n        self._shift_hold = False\n\n        self._download_folder_path = os.getcwd()\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.stop_browser()\n\n    @property\n    def driver(self):\n\"\"\"\n        The WebDriver driver instance.\n\n        Returns:\n            driver (WebDriver): The WebDriver driver instance.\n\n        \"\"\"\n        return self._driver\n\n    @property\n    def driver_path(self):\n        return self._driver_path\n\n    @driver_path.setter\n    def driver_path(self, driver_path):\n\"\"\"\n        The webdriver executable path.\n\n        Args:\n            driver_path (str): The full path to the proper webdriver path used for the selected browser.\n                If set to None, the code will look into the PATH for the proper file when starting the browser.\n        \"\"\"\n        driver_path = os.path.abspath(os.path.expanduser(os.path.expandvars(driver_path)))\n        if driver_path and not os.path.isfile(driver_path):\n            raise ValueError(\"Invalid driver_path. The file does not exist.\")\n        self._driver_path = driver_path\n\n    @property\n    def browser(self):\n\"\"\"\n        The web browser to be used.\n\n        Returns:\n            browser (Browser): The web browser to be used.\n        \"\"\"\n        return self._browser\n\n    @browser.setter\n    def browser(self, browser):\n\"\"\"\n        The web browser to be used.\n\n        Args:\n            browser (Browser): The name of web browser to be used from the Browser enum.\n        \"\"\"\n        self._browser = browser\n\n    @property\n    def options(self):\n\"\"\"\n        The options to be passed down to the WebDriver when starting the browser.\n\n        Returns:\n            options (Options): The browser specific options to be used.\n        \"\"\"\n        return self._options\n\n    @options.setter\n    def options(self, options):\n\"\"\"\n        The options to be passed down to the WebDriver when starting the browser.\n\n        Args:\n            options (Options): The browser specific options to be used.\n        \"\"\"\n        self._options = options\n\n    @property\n    def capabilities(self):\n\"\"\"\n        The capabilities to be passed down to the WebDriver when starting the browser.\n\n        Returns:\n            capabilities (Dict): The browser specific capabilities to be used.\n        \"\"\"\n        return self._capabilities\n\n    @capabilities.setter\n    def capabilities(self, capabilities):\n\"\"\"\n        The capabilities to be passed down to the WebDriver when starting the browser.\n\n        Args:\n            capabilities (Dict): The browser specific capabilities to be used.\n        \"\"\"\n        self._capabilities = capabilities\n\n    @property\n    def download_folder_path(self):\n        return self._download_folder_path\n\n    @download_folder_path.setter\n    def download_folder_path(self, folder_path):\n\"\"\"\n        The download folder path to be used. Set it up before starting the Browser or browsing a URL or restart the\n        browser after changing it.\n\n        Args:\n            folder_path (str): The desired download folder path.\n        \"\"\"\n        self._download_folder_path = folder_path\n\n    @property\n    def headless(self):\n\"\"\"\n        Controls whether or not the bot will run headless.\n\n        Returns:\n            headless (bool): Whether or not to run the browser on headless mode.\n        \"\"\"\n        return self._headless\n\n    @headless.setter\n    def headless(self, headless):\n\"\"\"\n        Controls whether or not the bot will run headless.\n\n        Args:\n            headless (boolean): If set to True will make the bot run headless.\n        \"\"\"\n        if self._driver:\n            logger.warning(\"Browser is running. Invoke stop_browser and start browser for changes to take effect.\")\n        self._headless = headless\n\n    @property\n    def page_load_strategy(self) -&gt; PageLoadStrategy:\n\"\"\"\n        The page load strategy to be used.\n\n        Returns:\n            page_load_strategy (PageLoadStrategy): The page load strategy to be used.\n        \"\"\"\n        return self._page_load_strategy\n\n    @page_load_strategy.setter\n    def page_load_strategy(self, page_load_strategy: PageLoadStrategy):\n\"\"\"\n        The page load strategy to be used.\n\n        Args:\n            page_load_strategy (PageLoadStrategy): The page load strategy to be used.\n        \"\"\"\n        if self._driver:\n            logger.warning(\"Browser is running. Invoke stop_browser and start browser for changes to take effect.\")\n        self._page_load_strategy = page_load_strategy\n\n    def start_browser(self):\n\"\"\"\n        Starts the selected browser.\n        \"\"\"\n        def check_driver():\n            # Look for driver\n            driver_name = BROWSER_CONFIGS.get(self.browser).get(\"driver\")\n            location = shutil.which(driver_name)\n            if not location:\n                raise RuntimeError(\n                    f\"{driver_name} was not found. Please make sure to have it on your PATH or set driver_path\")\n            return location\n\n        # Specific webdriver class for a given browser\n        driver_class = BROWSER_CONFIGS.get(self.browser).get(\"class\")\n        # Specific default options method for a given browser\n        func_def_options = BROWSER_CONFIGS.get(self.browser).get(\"options\")\n        # Specific capabilities method for a given browser\n        func_def_capabilities = BROWSER_CONFIGS.get(self.browser).get(\"capabilities\")\n\n        opt = self.options or func_def_options(\n            self.headless, self._download_folder_path, None, self.page_load_strategy\n        )\n        cap = self.capabilities or func_def_capabilities()\n        self.options = opt\n        self.capabilities = cap\n        driver_path = self.driver_path or check_driver()\n        self.driver_path = driver_path\n        if compat.version_selenium_is_larger_than_four():\n            service = BROWSER_CONFIGS.get(self.browser).get(\"service\")\n            service = service(executable_path=self.driver_path)\n            service.desired_capabilities = cap\n\n            self._driver = driver_class(options=opt, service=service)\n        else:\n            self._driver = driver_class(options=opt, desired_capabilities=cap, executable_path=driver_path)\n        self.set_screen_resolution()\n\n    def stop_browser(self):\n\"\"\"\n        Stops the Chrome browser and clean up the User Data Directory.\n\n        Warning:\n            After invoking this method, you will need to reassign your custom options and capabilities.\n        \"\"\"\n        if not self._driver:\n            return\n        self._driver.close()\n        self._driver.quit()\n        self.options = None\n        self.capabilities = None\n        self._driver = None\n\n    def set_screen_resolution(self, width=None, height=None):\n\"\"\"\n        Configures the browser dimensions.\n\n        Args:\n            width (int): The desired width.\n            height (int): The desired height.\n        \"\"\"\n        dimensions = (width or self.DEFAULT_DIMENSIONS[0], height or self.DEFAULT_DIMENSIONS[1])\n\n        if self.headless:\n            # When running headless the window size is the viewport size\n            window_size = dimensions\n        else:\n            # When running non-headless we need to account for the borders and etc\n            # So the size must be bigger to have the same viewport size as before\n            window_size = self._driver.execute_script(\"\"\"\n                return [window.outerWidth - window.innerWidth + arguments[0],\n                  window.outerHeight - window.innerHeight + arguments[1]];\n                \"\"\", *dimensions)\n        self._driver.set_window_size(*window_size)\n\n    def _webdriver_command(self, command, params=None, req_type=\"POST\"):\n\"\"\"\n        Execute a webdriver command.\n\n        Args:\n            command (str): The command URL after the session part\n            params (dict): The payload to be serialized and sent to the webdriver. Defaults to None.\n            req_type (str, optional): The type of request to be made. Defaults to \"POST\".\n\n        Returns:\n            str: The value of the response\n        \"\"\"\n        if not params:\n            params = {}\n\n        resource = f\"/session/{self.driver.session_id}/{command}\"\n        url = self.driver.command_executor._url + resource\n        body = json.dumps(params)\n        response = self.driver.command_executor._request(req_type, url, body)\n\n        if not response:\n            raise Exception(response.get('value'))\n\n        return response.get('value')\n\n    ##########\n    # Display\n    ##########\n\n    def get_screen_image(self, region=None):\n\"\"\"\n        Capture and returns a screenshot from the browser.\n\n        Args:\n            region (tuple): A tuple containing the left, top, width and height\n                to crop the screen image.\n\n        Returns:\n            image (Image): The screenshot Image object.\n        \"\"\"\n        if not region:\n            region = (0, 0, 0, 0)\n\n        x = region[0]\n        y = region[1]\n        width = region[2] or self._get_page_size()[0]\n        height = region[3] or self._get_page_size()[1]\n\n        try:\n            data = self._driver.get_screenshot_as_base64()\n            image_data = base64.b64decode(data)\n            img = Image.open(io.BytesIO(image_data))\n        except:  # noqa: E722\n            img = Image.new(\"RGB\", (width, height))\n\n        img = img.crop((x, y, x + width, y + height))\n        return img\n\n    def get_viewport_size(self):\n\"\"\"\n        Returns the browser current viewport size.\n\n        Returns:\n            width (int): The current viewport width.\n            height (int): The current viewport height.\n        \"\"\"\n        # Access each dimension individually\n        width = self._driver.get_window_size().get(\"width\")\n        height = self._driver.get_window_size().get(\"height\")\n        return width, height\n\n    def _get_page_size(self):\n\"\"\"\n        Returns the browser current page size.\n\n        Returns:\n            width (int): The current page width.\n            height (int): The current page height.\n        \"\"\"\n        if not self._driver:\n            return self.DEFAULT_DIMENSIONS\n\n        width = self.execute_javascript(\"return window.innerWidth\")\n        height = self.execute_javascript(\"return window.innerHeight\")\n        return width, height\n\n    def add_image(self, label, path):\n\"\"\"\n        Add an image into the state image map.\n\n        Args:\n            label (str): The image identifier\n            path (str): The path for the image on disk\n        \"\"\"\n        self.state.map_images[label] = path\n\n    def get_image_from_map(self, label):\n\"\"\"\n        Return an image from teh state image map.\n\n        Args:\n            label (str): The image identifier\n\n        Returns:\n            Image: The Image object\n        \"\"\"\n        path = self.state.map_images.get(label)\n        if not path:\n            raise KeyError('Invalid label for image map.')\n        img = Image.open(path)\n        return img\n\n    def find_multiple(self, labels, x=None, y=None, width=None, height=None, *,\n                      threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n        Find multiple elements defined by label on screen until a timeout happens.\n\n        Args:\n            labels (list): A list of image identifiers\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            best (bool, optional): Whether or not to keep looking until the best matching is found.\n                Defaults to True.\n            grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n                Defaults to False.\n\n        Returns:\n            results (dict): A dictionary in which the key is the label and value are the element coordinates in a\n               NamedTuple.\n        \"\"\"\n\n        def _to_dict(lbs, elems):\n            return {k: v for k, v in zip(lbs, elems)}\n\n        screen_w, screen_h = self._get_page_size()\n        x = x or 0\n        y = y or 0\n        w = width or screen_w\n        h = height or screen_h\n\n        region = (x, y, w, h)\n\n        results = [None] * len(labels)\n        paths = [self._search_image_file(la) for la in labels]\n        paths = [self._image_path_as_image(la) for la in paths]\n\n        if threshold:\n            # TODO: Figure out how we should do threshold\n            print('Threshold not yet supported')\n\n        if not best:\n            # TODO: Implement best=False.\n            print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n        start_time = time.time()\n\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; waiting_time:\n                return _to_dict(labels, results)\n\n            haystack = self.screenshot()\n            helper = functools.partial(self._find_multiple_helper, haystack, region, matching, grayscale)\n\n            results = [helper(p) for p in paths]\n\n            results = [r for r in results]\n            if None in results:\n                continue\n            else:\n                return _to_dict(labels, results)\n\n    def _find_multiple_helper(self, haystack, region, confidence, grayscale, needle):\n        ele = cv2find.locate_all_opencv(\n            needle, haystack, region=region, confidence=confidence, grayscale=grayscale\n        )\n        try:\n            ele = next(ele)\n        except StopIteration:\n            ele = None\n        return ele\n\n    def find(self, label, x=None, y=None, width=None, height=None, *,\n             threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n        Find an element defined by label on screen until a timeout happens.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            best (bool, optional): Whether or not to keep looking until the best matching is found.\n                Defaults to True.\n            grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n                Defaults to False.\n\n        Returns:\n            element (NamedTuple): The element coordinates. None if not found.\n        \"\"\"\n        return self.find_until(label=label, x=x, y=y, width=width, height=height, threshold=threshold,\n                               matching=matching, waiting_time=waiting_time, best=best, grayscale=grayscale)\n\n    def find_until(self, label, x=None, y=None, width=None, height=None, *,\n                   threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n        Find an element defined by label on screen until a timeout happens.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            best (bool, optional): Whether or not to keep looking until the best matching is found.\n                Defaults to True.\n            grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n                Defaults to False.\n\n        Returns:\n            element (NamedTuple): The element coordinates. None if not found.\n        \"\"\"\n        self.state.element = None\n        screen_w, screen_h = self._get_page_size()\n        x = x or 0\n        y = y or 0\n        w = width or screen_w\n        h = height or screen_h\n\n        region = (x, y, w, h)\n\n        element_path = self._search_image_file(label)\n        element_path = self._image_path_as_image(element_path)\n\n        if threshold:\n            # TODO: Figure out how we should do threshold\n            print('Threshold not yet supported')\n\n        if not best:\n            # TODO: Implement best=False.\n            print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n        start_time = time.time()\n\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; waiting_time:\n                return None\n            haystack = self.get_screen_image()\n            it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                           region=region, confidence=matching, grayscale=grayscale)\n            try:\n                ele = next(it)\n            except StopIteration:\n                ele = None\n\n            if ele is not None:\n                self.state.element = ele\n                return ele\n\n    def set_current_element(self, element: cv2find.Box):\n\"\"\"\n        Changes the current screen element the bot will interact when using click(), move(), and similar methods.\n\n        This method is equivalent to self.state.element = element.\n\n        Args:\n            element (Box): A screen element from self.state.element or the find_all(as_list=True) method.\n        \"\"\"\n        self.state.element = element\n\n    def find_all(self, label, x=None, y=None, width=None, height=None, *,\n                 threshold=None, matching=0.9, waiting_time=10000, grayscale=False, as_list: bool = False):\n\"\"\"\n        Find all elements defined by label on screen until a timeout happens.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n                Defaults to False.\n            as_list (bool, Optional): If True, returns a list of element coordinates instead of a generator.\n                Use set_active_element() to be able to interact with the found elements.\n                This parameter must be True if you intend to run multiple find_all() concurrently.\n                Defaults to False.\n\n        Returns:\n            elements (collections.Iterable[NamedTuple]): A generator with all element coordinates found.\n                None if not found.\n        \"\"\"\n        def deduplicate(elems):\n            def find_same(item, items):\n                x_start = item.left\n                x_end = item.left + item.width\n                y_start = item.top\n                y_end = item.top + item.height\n                similars = []\n                for itm in items:\n                    if itm == item:\n                        continue\n                    if (itm.left &gt;= x_start and itm.left &lt; x_end)\\\n                            and (itm.top &gt;= y_start and itm.top &lt; y_end):\n                        similars.append(itm)\n                        continue\n                return similars\n\n            index = 0\n            while True:\n                try:\n                    dups = find_same(elems[index], elems[index:])\n                    for d in dups:\n                        elems.remove(d)\n                    index += 1\n                except IndexError:\n                    break\n            return elems\n\n        self.state.element = None\n        screen_w, screen_h = self._get_page_size()\n        x = x or 0\n        y = y or 0\n        w = width or screen_w\n        h = height or screen_h\n\n        region = (x, y, w, h)\n\n        element_path = self._search_image_file(label)\n        element_path = self._image_path_as_image(element_path)\n\n        if threshold:\n            # TODO: Figure out how we should do threshold\n            print('Threshold not yet supported')\n\n        start_time = time.time()\n\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; waiting_time:\n                return None\n\n            haystack = self.get_screen_image()\n            it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                           region=region, confidence=matching, grayscale=grayscale)\n\n            eles = [ele for ele in it]\n            if not eles:\n                continue\n            eles = deduplicate(list(eles))\n\n            # As List\n            if as_list:\n                return eles\n\n            # As Generator\n            for ele in eles:\n                if ele is not None:\n                    self.state.element = ele\n                    yield ele\n            break\n\n    def find_text(self, label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9,\n                  waiting_time=10000, best=True):\n\"\"\"\n        Find an element defined by label on screen until a timeout happens.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            best (bool, optional): Whether or not to keep looking until the best matching is found.\n                Defaults to True.\n\n        Returns:\n            element (NamedTuple): The element coordinates. None if not found.\n        \"\"\"\n        return self.find_until(label, x, y, width, height, threshold=threshold, matching=matching,\n                               waiting_time=waiting_time, best=best, grayscale=True)\n\n    def get_last_element(self):\n\"\"\"\n        Return the last element found.\n\n        Returns:\n            element (NamedTuple): The element coordinates (left, top, width, height)\n        \"\"\"\n        return self.state.element\n\n    def display_size(self):\n\"\"\"\n        Returns the display size in pixels.\n\n        Returns:\n            size (Tuple): The screen dimension (width and height) in pixels.\n        \"\"\"\n        return self._get_page_size()\n\n    def screenshot(self, filepath=None, region=None):\n\"\"\"\n        Capture a screenshot.\n\n        Args:\n            filepath (str, optional): The filepath in which to save the screenshot. Defaults to None.\n            region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot.\n\n        Returns:\n            Image: The screenshot Image object\n        \"\"\"\n        img = self.get_screen_image(region)\n        if filepath:\n            img.save(filepath)\n        return img\n\n    def get_screenshot(self, filepath=None, region=None):\n\"\"\"\n        Capture a screenshot.\n\n        Args:\n            filepath (str, optional): The filepath in which to save the screenshot. Defaults to None.\n            region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot.\n\n        Returns:\n            Image: The screenshot Image object\n        \"\"\"\n        return self.screenshot(filepath, region)\n\n    def screen_cut(self, x, y, width=None, height=None):\n\"\"\"\n        Capture a screenshot from a region of the screen.\n\n        Args:\n            x (int): region start position x\n            y (int): region start position y\n            width (int): region width\n            height (int): region height\n\n        Returns:\n            Image: The screenshot Image object\n        \"\"\"\n        screen_size = self._get_page_size()\n        x = x or 0\n        y = y or 0\n        width = width or screen_size[0]\n        height = height or screen_size[1]\n        img = self.screenshot(region=(x, y, width, height))\n        return img\n\n    def save_screenshot(self, path):\n\"\"\"\n        Saves a screenshot in a given path.\n\n        Args:\n            path (str): The filepath in which to save the screenshot\n\n        \"\"\"\n        self.screenshot(path)\n\n    def get_element_coords(self, label, x=None, y=None, width=None, height=None, matching=0.9, best=True):\n\"\"\"\n        Find an element defined by label on screen and returns its coordinates.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): X (Left) coordinate of the search area.\n            y (int, optional): Y (Top) coordinate of the search area.\n            width (int, optional): Width of the search area.\n            height (int, optional): Height of the search area.\n            matching (float, optional): Minimum score to consider a match in the element image recognition process.\n                Defaults to 0.9.\n            best (bool, optional): Whether or not to search for the best value. If False the method returns on\n                the first find. Defaults to True.\n\n        Returns:\n            coords (Tuple): A tuple containing the x and y coordinates for the element.\n        \"\"\"\n        self.state.element = None\n        screen_size = self._get_page_size()\n        x = x or 0\n        y = y or 0\n        width = width or screen_size[0]\n        height = height or screen_size[1]\n        region = (x, y, width, height)\n\n        if not best:\n            print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n        element_path = self._search_image_file(label)\n        element_path = self._image_path_as_image(element_path)\n        haystack = self.get_screen_image()\n\n        it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                       region=region, confidence=matching)\n        try:\n            ele = next(it)\n        except StopIteration:\n            ele = None\n        self.state.element = ele\n\n        if ele:\n            return ele.left, ele.top\n        else:\n            return None, None\n\n    def get_element_coords_centered(self, label, x=None, y=None, width=None, height=None,\n                                    matching=0.9, best=True):\n\"\"\"\n        Find an element defined by label on screen and returns its centered coordinates.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): X (Left) coordinate of the search area.\n            y (int, optional): Y (Top) coordinate of the search area.\n            width (int, optional): Width of the search area.\n            height (int, optional): Height of the search area.\n            matching (float, optional): Minimum score to consider a match in the element image recognition process.\n                Defaults to 0.9.\n            best (bool, optional): Whether or not to search for the best value. If False the method returns on\n                the first find. Defaults to True.\n\n        Returns:\n            coords (Tuple): A tuple containing the x and y coordinates for the center of the element.\n        \"\"\"\n        self.get_element_coords(label, x, y, width, height, matching, best)\n        return self.state.center()\n\n    #########\n    # Browser\n    #########\n    def page_title(self):\n\"\"\"\n        Returns the active page title.\n\n        Returns:\n            title (str): The page title.\n        \"\"\"\n        try:\n            return self._driver.title\n        except InvalidSessionIdException:\n            return None\n\n    def page_source(self):\n\"\"\"\n        Returns the active page source.\n\n        Returns:\n            soup (BeautifulSoup): BeautifulSoup object for the page source.\n        \"\"\"\n        try:\n            soup = BeautifulSoup(self._driver.page_source, 'html.parser')\n            return soup\n        except InvalidSessionIdException:\n            return None\n\n    def navigate_to(self, url, is_retry=False):\n\"\"\"\n        Opens the browser on the given URL.\n\n        Args:\n            url (str):  The URL to be visited.\n            is_retry (bool): Whether or not this is a retry attempt.\n        \"\"\"\n        self._x = 0\n        self._y = 0\n        if not self._driver:\n            self.start_browser()\n        try:\n            self._driver.get(url)\n        except InvalidSessionIdException:\n            if not is_retry:\n                self.stop_browser()\n                self.navigate_to(url, is_retry=True)\n\n    def browse(self, url):\n\"\"\"\n        Opens the browser on the given URL.\n\n        Args:\n            url (str):  The URL to be visited.\n        \"\"\"\n        self.navigate_to(url)\n\n    def back(self):\n\"\"\"\n        Goes one step backward in the browser history.\n        \"\"\"\n        self._driver.back()\n\n    def forward(self):\n\"\"\"\n        Goes one step forward in the browser history.\n        \"\"\"\n        self._driver.forward()\n\n    def refresh(self):\n\"\"\"\n        Refreshes the current page.\n        \"\"\"\n        self._driver.refresh()\n\n    @contextmanager\n    def wait_for_new_page(self, waiting_time=10000, activate=True):\n\"\"\"Context manager to wait for a new page to load and activate it.\n\n        Args:\n            waiting_time (int, optional): The maximum waiting time. Defaults to 10000.\n            activate (bool, optional): Whether or not to activate the new page. Defaults to True.\n\n        \"\"\"\n        tabs = self.get_tabs()\n        yield\n        start_time = time.time()\n        while tabs == self.get_tabs():\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; waiting_time:\n                return None\n            time.sleep(0.1)\n        if activate:\n            self.activate_tab(self.get_tabs()[-1])\n\n    def execute_javascript(self, code):\n\"\"\"\n        Execute the given javascript code.\n\n        Args:\n            code (str): The code to be executed.\n\n        Returns:\n            value (object): Returns the code output or None if not available or if an error happens.\n        \"\"\"\n        return self._driver.execute_script(code)\n\n    def handle_js_dialog(self, accept=True, prompt_text=None):\n\"\"\"\n        Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).\n        This also cleans the dialog information in the local buffer.\n\n        Args:\n            accept (bool): Whether to accept or dismiss the dialog.\n            prompt_text (str): The text to enter into the dialog prompt before accepting.\n                Used only if this is a prompt dialog.\n        \"\"\"\n        dialog = self.get_js_dialog()\n        if not dialog:\n            # TODO: Maybe we should raise an exception here if no alert available\n            return\n        if prompt_text is not None:\n            dialog.send_keys(prompt_text)\n        if accept:\n            dialog.accept()\n        else:\n            dialog.dismiss()\n\n    def get_js_dialog(self):\n\"\"\"\n        Return the last found dialog. Invoke first the `find_js_dialog` method to look up.\n\n        Returns:\n            dialog (dict): The dialog information or None if not available.\n                See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening\n        \"\"\"\n        try:\n            dialog = self._driver.switch_to.alert\n            return dialog\n        except Exception:\n            return None\n\n    def get_tabs(self):\n\"\"\"Get a list of tab handlers\n\n        Returns:\n            list: List of tab handlers\n        \"\"\"\n        try:\n            return self._driver.window_handles\n        except InvalidSessionIdException:\n            return []\n\n    def create_tab(self, url):\n\"\"\"Create a new tab and navigate to the given URL.\n\n        Args:\n            url (str): The desired URL.\n        \"\"\"\n        try:\n            # Refactor this when Selenium 4 is released\n            self.execute_javascript(f\"window.open('{url}', '_blank');\")\n            self._driver.switch_to.window(self.get_tabs()[-1])\n        except InvalidSessionIdException:\n            self.navigate_to(url)\n\n    def create_window(self, url):\n\"\"\"Creates a new window with the given URL.\n\n        Args:\n            url (str): The desired URL.\n        \"\"\"\n        try:\n            # Refactor this when Selenium 4 is released\n            self.execute_javascript(f\"window.open('{url}', '_blank', 'location=0');\")\n            self._driver.switch_to.window(self.get_tabs()[-1])\n        except InvalidSessionIdException:\n            self.navigate_to(url)\n\n    def close_page(self):\n\"\"\"Close the current active page (tab or window).\n        \"\"\"\n        try:\n            self._driver.close()\n\n            # If it was the last tab we can't switch\n            tabs = self.get_tabs()\n            if tabs:\n                self._driver.switch_to.window(tabs[-1])\n        except InvalidSessionIdException:\n            pass\n\n    def activate_tab(self, handle):\n\"\"\"Activate a tab given by the handle.\n\n        Args:\n            handle (str): The tab or window handle.\n        \"\"\"\n        self._driver.switch_to.window(handle)\n\n    def print_pdf(self, path=None, print_options=None):\n\"\"\"Print the current page as a PDF file.\n\n        Args:\n            path (str, optional): The path for the file to be saved. Defaults to None.\n            print_options (dict, optional): Print options as defined at. Defaults to None.\n\n        Returns:\n            str: the saved file path\n        \"\"\"\n        title = self.page_title() or \"document\"\n        title = re.sub(\"[\\\\\\\\|/:\u2013]\", \"\", title)\n        timeout = 60000\n        default_path = os.path.expanduser(os.path.join(self.download_folder_path, f\"{title}.pdf\"))\n\n        if self.browser in [Browser.CHROME, Browser.EDGE] and not self.headless:\n            pdf_current_count = self.get_file_count(file_extension=\".pdf\")\n            # Chrome still does not support headless webdriver print\n            # but Firefox does.\n            self.execute_javascript(\"window.print();\")\n\n            # We need to wait for the file to be available in this case.\n            if self.page_title():\n                self.wait_for_file(default_path, timeout=timeout)\n            else:\n                # Waiting when the file don't have the page title in path\n                self.wait_for_new_file(file_extension=\".pdf\", current_count=pdf_current_count)\n\n            # Move the downloaded pdf file if the path is not None\n            if path:\n                last_downloaded_pdf = self.get_last_created_file(self.download_folder_path, \".pdf\")\n                os.rename(last_downloaded_pdf, path)\n                return path\n            self.wait(2000)\n            return default_path\n\n        if print_options is None:\n            print_options = {\n                'landscape': False,\n                'displayHeaderFooter': False,\n                'printBackground': True,\n                'preferCSSPageSize': True,\n                'marginTop': 0,\n                'marginBottom': 0\n            }\n        data = self._webdriver_command(\"print\", print_options)\n        bytes_file = base64.b64decode(data)\n        if not path:\n            path = default_path\n        with open(path, \"wb\") as f:\n            f.write(bytes_file)\n        return path\n\n    def wait_for_downloads(self, timeout: int = 120000):\n\"\"\"\n        Wait for all downloads to be finished.\n        Beware that this method replaces the current page with the downloads window.\n\n        Args:\n            timeout (int, optional): Timeout in millis. Defaults to 120000.\n        \"\"\"\n        if self.browser in [Browser.CHROME, Browser.EDGE] and self.headless:\n            start_time = time.time()\n            while True:\n                elapsed_time = (time.time() - start_time) * 1000\n                if elapsed_time &gt; timeout:\n                    return False\n                downloads_count = self.get_file_count(self.download_folder_path, \".crdownload\")\n                if downloads_count == 0:\n                    return True\n                self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n        wait_method = BROWSER_CONFIGS.get(self.browser).get(\"wait_for_downloads\")\n        # waits for all the files to be completed\n        WebDriverWait(self._driver, timeout/1000.0, 1).until(wait_method)\n\n    def find_elements(self, selector: str, by: By = By.CSS_SELECTOR,\n                      waiting_time=10000, ensure_visible: bool = True) -&gt; List[WebElement]:\n\"\"\"Find elements using the specified selector with selector type specified by `by`.\n\n        Args:\n            selector (str): The selector string to be used.\n            by (str, optional): Selector type. Defaults to By.CSS_SELECTOR.\n                [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By)\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            ensure_visible (bool, optional): Whether to wait for the element to be visible. Defaults to True.\n\n        Returns:\n            List[WebElement]: List of elements found.\n\n        **Example:**\n        ```python\n        from botcity.web import By\n        ...\n        # Find element by ID\n        all_cells = self.find_elements(\"//td\", By.XPATH)\n        ...\n        ```\n        \"\"\"\n        if ensure_visible:\n            condition = EC.visibility_of_all_elements_located\n        else:\n            condition = EC.presence_of_all_elements_located\n\n        try:\n            elements = WebDriverWait(\n                self._driver, timeout=waiting_time / 1000.0\n            ).until(\n                condition((by, selector))\n            )\n            return elements\n        except (TimeoutException, NoSuchElementException) as ex:\n            print(\"Exception on find_elements\", ex)\n            return None\n\n    def find_element(self, selector: str, by: str = By.CSS_SELECTOR, waiting_time=10000,\n                     ensure_visible: bool = False, ensure_clickable: bool = False) -&gt; WebElement:\n\"\"\"Find an element using the specified selector with selector type specified by `by`.\n        If more than one element is found, the first instance is returned.\n\n        Args:\n            selector (str): The selector string to be used.\n            by (str, optional): Selector type. Defaults to By.CSS_SELECTOR.\n                [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By)\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            ensure_visible (bool, optional): Whether to wait for the element to be visible. Defaults to False.\n            ensure_clickable (bool, optional): Whether to wait for the element to be clickable. Defaults to False.\n                If True, `ensure_clickable` takes precedence over `ensure_visible`.\n\n        Returns:\n            WebElement: The element found.\n\n        **Example:**\n        ```python\n        from botcity.web import By\n        ...\n        # Find element by ID\n        elem = self.find_element(\"my_elem\", By.ID)\n        # Find element by XPath\n        elem = self.find_element(\"//input[@type='submit']\", By.XPATH)\n        ...\n        ```\n        \"\"\"\n        condition = EC.visibility_of_element_located if ensure_visible else EC.presence_of_element_located\n        condition = EC.element_to_be_clickable if ensure_clickable else condition\n\n        try:\n            element = WebDriverWait(\n                self._driver, timeout=waiting_time/1000.0\n            ).until(\n                condition((by, selector))\n            )\n            return element\n        except (TimeoutException, NoSuchElementException):\n            return None\n\n    def scroll_element(self, element: WebElement, steps: int = 100, interval: float = 500,\n                       start: int = 0, end: int = None):\n\"\"\"Scrolls down an element by its scroll height or a given amount defined by `start` and `end`.\n\n        This is useful for scrolling down a page to load more content or\n        to scroll down a dynamically loaded element.\n\n        Args:\n            element (WebElement): The element to scroll.\n            steps (int, optional): Number of steps in which to conclude the scroll. Defaults to 100.\n            interval (float, optional): Time interval between each step. Defaults to 500ms.\n            start (int, optional): Start position. Defaults to 0.\n            end (int, optional): End position. Defaults to None.\n        \"\"\"\n        ele_height = self.driver.execute_script(\n            \"return arguments[0].scrollHeight;\", element\n        )\n\n        start = max(0, start)\n        end = min(ele_height, end) if end is not None else ele_height\n\n        for i in range(start, end, steps):\n            self.driver.execute_script(\n                \"arguments[0].scrollTo(0, arguments[1])\", element, i)\n            self.sleep(interval/1000.0)\n\n    def wait_for_stale_element(self, element: WebElement, timeout: int = 10000):\n\"\"\"\n        Wait until the WebElement element becomes stale (outdated).\n\n        Args:\n            element (WebElement): The element to monitor for staleness.\n            timeout (int, optional): Timeout in millis. Defaults to 120000.\n        \"\"\"\n        try:\n            WebDriverWait(self._driver, timeout=timeout/1000.0).until(EC.staleness_of(element))\n        except (TimeoutException, NoSuchElementException):\n            pass\n\n    def wait_for_element_visibility(self, element: WebElement, visible: bool = True, waiting_time=10000):\n\"\"\"Wait for the element to be visible or hidden.\n\n        Args:\n            element (WebElement): The element to wait for.\n            visible (bool, optional): Whether to wait for the element to be visible. Defaults to True.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n        \"\"\"\n        if visible:\n            wait_method = EC.visibility_of\n        else:\n            wait_method = EC.invisibility_of_element\n\n        WebDriverWait(self._driver, timeout=waiting_time/1000.0).until(wait_method(element))\n\n    def set_file_input_element(self, element: WebElement, filepath: str):\n\"\"\"Configure the filepath for upload in a file element.\n        Note: This method does not submit the form.\n\n        Args:\n            element (WebElement): The file upload element.\n            filepath (str): The path to the file to be uploaded.\n\n        **Example:**\n        ```python\n        ...\n        # Find element\n        elem = self.find_element(\"body &gt; form &gt; input[type=file]\")\n        # Set the filepath\n        self.set_file_input_element(elem, \"./test.txt\")\n        ...\n        ```\n        \"\"\"\n        fpath = os.path.abspath(os.path.expanduser(os.path.expandvars(filepath)))\n        element.send_keys(fpath)\n\n    def enter_iframe(self, iframe: WebElement):\n\"\"\"Switch the WebBot driver to the specified iframe.\n\n        Args:\n            iframe (WebElement): The desired iFrame.\n        \"\"\"\n        self._driver.switch_to.frame(iframe)\n\n    def leave_iframe(self):\n\"\"\"Leave the iframe and switch the WebBot driver to the default content.\n        \"\"\"\n        self._driver.switch_to.default_content()\n\n    def install_firefox_extension(self, extension):\n\"\"\"\n        Install an extension in the Firefox browser.\n        This will start the browser if it was not started yet.\n\n        Args:\n            extension (str): The path of the .xpi extension to be loaded.\n        \"\"\"\n        if self.browser != Browser.FIREFOX:\n            raise ValueError(\"install_firefox_extension only works with Firefox.\")\n        if not self._driver:\n            self.start_browser()\n        self._driver.install_addon(os.path.abspath(extension))\n\n    #######\n    # Mouse\n    #######\n    def click_on(self, label):\n\"\"\"\n        Click on the element.\n\n        Args:\n            label (str): The image identifier\n        \"\"\"\n        x, y = self.get_element_coords_centered(label)\n        if None in (x, y):\n            raise ValueError(f'Element not available. Cannot find {label}.')\n        self.click_at(x, y)\n\n    def get_last_x(self):\n\"\"\"\n        Get the last X position for the mouse.\n\n        Returns:\n            x (int): The last x position for the mouse.\n        \"\"\"\n        return self._x\n\n    def get_last_y(self):\n\"\"\"\n        Get the last Y position for the mouse.\n\n        Returns:\n            y (int): The last y position for the mouse.\n        \"\"\"\n        return self._y\n\n    def mouse_move(self, x, y):\n\"\"\"\n        Mouse the move to the coordinate defined by x and y\n\n        Args:\n            x (int): The X coordinate\n            y (int): The Y coordinate\n\n        \"\"\"\n        if self.browser == Browser.FIREFOX:\n            # Reset coordinates if the page has gone stale. Only required for Firefox\n            if self._html_elem is None:\n                self._html_elem = self._driver.find_element(By.TAG_NAME, 'body')\n                self._x = 0\n                self._y = 0\n            else:\n                try:\n                    self._html_elem.is_enabled()\n                except StaleElementReferenceException:\n                    self._html_elem = self._driver.find_element(By.TAG_NAME, 'body')\n                    self._x = 0\n                    self._y = 0\n\n        mx = x - self._x\n        my = y - self._y\n        self._x = x\n        self._y = y\n        ActionChains(self._driver).move_by_offset(mx, my).perform()\n\n    def click_at(self, x, y, *, clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n        Click at the coordinate defined by x and y\n\n        Args:\n            x (int): The X coordinate\n            y (int): The Y coordinate\n            clicks (int, optional): Number of times to click. Defaults to 1.\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            button (str, optional): One of 'left', 'right'. Defaults to 'left'\n        \"\"\"\n        self.mouse_move(x, y)\n        ac = ActionChains(self._driver)\n        for i in range(clicks):\n            if button == 'left':\n                ac.click()\n            elif button == 'right':\n                ac.context_click()\n            else:\n                raise ValueError('Invalid value for button. Accepted values are left or right.')\n            ac.pause(interval_between_clicks/1000.0)\n        ac.perform()\n\n    @only_if_element\n    def click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n              clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n        Click on the last found element.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            clicks (int, optional): Number of times to click. Defaults to 1.\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            button (str, optional): One of 'left', 'right'. Defaults to 'left'\n        \"\"\"\n        x, y = self.state.center()\n        self.click_at(x, y, clicks=clicks, button=button, interval_between_clicks=interval_between_clicks)\n        self.sleep(wait_after)\n\n    @only_if_element\n    def click_relative(self, x, y, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n                       clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n        Click Relative on the last found element.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            clicks (int, optional): Number of times to click. Defaults to 1.\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            button (str, optional): One of 'left', 'right'. Defaults to 'left'\n        \"\"\"\n        x = self.state.x() + x\n        y = self.state.y() + y\n        self.click_at(x, y, clicks=clicks, button=button, interval_between_clicks=interval_between_clicks)\n        self.sleep(wait_after)\n\n    @only_if_element\n    def double_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Double Click on the last found element.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n        \"\"\"\n        self.click(interval_between_clicks=wait_after, clicks=2)\n\n    @only_if_element\n    def double_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Double Click Relative on the last found element.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            wait_after (int, optional): Interval to wait after clicking on the element.\n        \"\"\"\n        self.click_relative(x, y, wait_after=wait_after, clicks=2, interval_between_clicks=interval_between_clicks)\n\n    @only_if_element\n    def triple_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Triple Click on the last found element.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n        \"\"\"\n        self.click(wait_after=wait_after, clicks=3)\n\n    @only_if_element\n    def triple_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Triple Click Relative on the last found element.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            wait_after (int, optional): Interval to wait after clicking on the element.\n        \"\"\"\n        self.click_relative(x, y, wait_after=wait_after, clicks=3, interval_between_clicks=interval_between_clicks)\n\n    def mouse_down(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left'):\n\"\"\"\n        Holds down the requested mouse button.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n        \"\"\"\n        ActionChains(self._driver).click_and_hold().perform()\n        self.sleep(wait_after)\n\n    def mouse_up(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left'):\n\"\"\"\n        Releases the requested mouse button.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n        \"\"\"\n        ActionChains(self._driver).release().perform()\n        self.sleep(wait_after)\n\n    def scroll_down(self, clicks):\n\"\"\"\n        Scroll Down n clicks\n\n        Args:\n            clicks (int): Number of times to scroll down.\n        \"\"\"\n        for i in range(clicks):\n            self._driver.execute_script(\"window.scrollTo(0, window.scrollY + 200)\")\n            self.sleep(200)\n\n    def scroll_up(self, clicks):\n\"\"\"\n        Scroll Up n clicks\n\n        Args:\n            clicks (int): Number of times to scroll up.\n        \"\"\"\n        for i in range(clicks):\n            self._driver.execute_script(\"window.scrollTo(0, window.scrollY - 200)\")\n            self.sleep(200)\n\n    def move_to(self, x, y):\n\"\"\"\n        Move the mouse relative to its current position.\n\n        Args:\n            x (int): The X coordinate\n            y (int): The Y coordinate\n        \"\"\"\n        self.mouse_move(x, y)\n\n    @only_if_element\n    def move(self):\n\"\"\"\n        Move to the center position of last found item.\n        \"\"\"\n        x, y = self.state.center()\n        self.move_to(x, y)\n\n    def move_relative(self, x, y):\n\"\"\"\n        Move the mouse relative to its current position.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n\n        \"\"\"\n        x = self.get_last_x() + x\n        y = self.get_last_y() + y\n        self.move_to(x, y)\n\n    def move_random(self, range_x, range_y):\n\"\"\"\n        Move randomly along the given x, y range.\n\n        Args:\n            range_x (int): Horizontal range\n            range_y (int): Vertical range\n\n        \"\"\"\n        x = int(random.random() * range_x)\n        y = int(random.random() * range_y)\n        self.move_to(x, y)\n\n    @only_if_element\n    def right_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n                    clicks=1, interval_between_clicks=0):\n\"\"\"\n        Right click on the last found element.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            clicks (int, optional): Number of times to click. Defaults to 1.\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        \"\"\"\n        self.click(clicks=clicks, button='right', interval_between_clicks=interval_between_clicks)\n        self.sleep(wait_after)\n\n    def right_click_at(self, x, y):\n\"\"\"\n        Right click at the coordinate defined by x and y\n\n        Args:\n            x (int): The X coordinate\n            y (int): The Y coordinate\n        \"\"\"\n        self.click_at(x, y, button='right')\n\n    @only_if_element\n    def right_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Right Click Relative on the last found element.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            wait_after (int, optional): Interval to wait after clicking on the element.\n\n        \"\"\"\n        self.click_relative(x, y, wait_after=wait_after, interval_between_clicks=interval_between_clicks,\n                            button='right')\n\n    ##########\n    # Keyboard\n    ##########\n    def kb_type(self, text, interval=0):\n\"\"\"\n        Type a text char by char (individual key events).\n\n        Args:\n            text (str): text to be typed.\n            interval (int, optional): interval (ms) between each key press. Defaults to 0\n        \"\"\"\n        action = ActionChains(self._driver)\n\n        for c in text:\n            action.send_keys(c)\n            action.pause(interval / 1000.0)\n\n        action.perform()\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def paste(self, text=None, wait=0):\n\"\"\"\n        Paste content from the clipboard.\n\n        Args:\n            text (str, optional): The text to be pasted. Defaults to None\n            wait (int, optional): Wait interval (ms) after task\n        \"\"\"\n        text_to_paste = self._clipboard\n        if text:\n            text_to_paste = text\n        self.kb_type(text_to_paste)\n\n    def copy_to_clipboard(self, text, wait=0):\n\"\"\"\n        Copy content to the clipboard.\n\n        Args:\n            text (str): The text to be copied.\n            wait (int, optional): Wait interval (ms) after task\n        \"\"\"\n        self._clipboard = text\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def tab(self, wait=0):\n\"\"\"\n        Press key Tab\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.TAB)\n        action.key_up(Keys.TAB)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def enter(self, wait=0):\n\"\"\"\n        Press key Enter\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.ENTER)\n        action.key_up(Keys.ENTER)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def key_right(self, wait=0):\n\"\"\"\n        Press key Right\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.ARROW_RIGHT)\n        action.key_up(Keys.ARROW_RIGHT)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def key_enter(self, wait=0):\n\"\"\"\n        Press key Enter\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.enter(wait)\n\n    def key_home(self, wait=0):\n\"\"\"\n        Press key Home\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        # TODO: Investigate why with Firefox the key isn't working properly\n        action = ActionChains(self._driver)\n        action.key_down(Keys.HOME)\n        action.key_up(Keys.HOME)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def key_end(self, wait=0):\n\"\"\"\n        Press key End\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.END)\n        action.key_up(Keys.END)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def page_up(self, wait=0):\n\"\"\"\n        Press Page Up key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        # TODO: Investigate why with Firefox the key isn't working properly\n        action = ActionChains(self._driver)\n        action.key_down(Keys.PAGE_UP)\n        action.key_up(Keys.PAGE_UP)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def page_down(self, wait=0):\n\"\"\"\n        Press Page Down key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        # TODO: Investigate why with Firefox the key isn't working properly\n        action = ActionChains(self._driver)\n        action.key_down(Keys.PAGE_DOWN)\n        action.key_up(Keys.PAGE_DOWN)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def key_esc(self, wait=0):\n\"\"\"\n        Press key Esc\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.ESCAPE)\n        action.key_up(Keys.ESCAPE)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def _key_fx(self, idx, wait=0):\n\"\"\"\n        Press key Fidx where idx is a value from 1 to 12\n\n        Args:\n            idx (int): F key index from 1 to 12\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        if idx &lt; 1 or idx &gt; 12:\n            raise ValueError(\"Only F1 to F12 allowed.\")\n        action = ActionChains(self._driver)\n        key = getattr(Keys, f\"F{idx}\")\n        action.key_down(key)\n        action.key_up(key)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def hold_shift(self, wait=0):\n\"\"\"\n        Hold key Shift\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.SHIFT)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def release_shift(self):\n\"\"\"\n        Release key Shift.\n        This method needs to be invoked after holding Shift or similar.\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_up(Keys.SHIFT)\n        action.perform()\n\n    def maximize_window(self):\n\"\"\"\n        Shortcut to maximize window on Windows OS.\n        \"\"\"\n        # TODO: Understand the complications associated with maximizing the browser and the resolution\n        self._driver.maximize_window()\n\n    def type_keys_with_interval(self, interval, keys):\n\"\"\"\n        Press a sequence of keys. Hold the keys in the specific order and releases them.\n\n        Args:\n            interval (int): Interval (ms) in which to press and release keys\n            keys (list): List of Keys to be pressed\n        \"\"\"\n        action = ActionChains(self._driver)\n\n        for k in keys:\n            action.key_down(k)\n            action.pause(interval / 1000.0)\n        for k in reversed(keys):\n            action.key_up(k)\n            action.pause(interval / 1000.0)\n        action.perform()\n\n    def type_keys(self, keys):\n\"\"\"\n        Press a sequence of keys. Hold the keys in the specific order and releases them.\n\n        Args:\n            keys (list): List of keys to be pressed\n        \"\"\"\n        self.type_keys_with_interval(100, keys)\n\n    def control_c(self, wait=0):\n\"\"\"\n        Press keys CTRL+C\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        # Firefox can't do window.getSelection() and return a proper value when the selected text\n        # is in an input of similar. While Firefox doesn't get its shit together we apply this\n        # ugly alternative so control+c works for \"all\" browsers tested so far.\n        cmd = \"\"\"\n            try {\n                return document.activeElement.value.substring(\n                    document.activeElement.selectionStart,\n                    document.activeElement.selectionEnd\n                );\n            } catch(error) {\n                return window.getSelection().toString();\n            }\n        \"\"\"\n\n        self._clipboard = self.execute_javascript(cmd)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def control_v(self, wait=0):\n\"\"\"\n        Press keys CTRL+V\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.paste()\n\n    def control_a(self, wait=0):\n\"\"\"\n        Press keys CTRL+A\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        key = Keys.CONTROL\n        if platform.system() == 'Darwin':\n            key = Keys.COMMAND\n\n        action.key_down(key)\n        action.send_keys('a')\n        action.key_up(key)\n        action.perform()\n\n    def get_clipboard(self):\n\"\"\"\n        Get the current content in the clipboard.\n\n        Returns:\n            text (str): Current clipboard content\n        \"\"\"\n        return self._clipboard\n\n    def type_left(self, wait=0):\n\"\"\"\n        Press Left key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.ARROW_LEFT)\n        action.key_up(Keys.ARROW_LEFT)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def type_right(self, wait=0):\n\"\"\"\n        Press Right key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.key_right(wait=wait)\n\n    def type_down(self, wait=0):\n\"\"\"\n        Press Down key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.ARROW_DOWN)\n        action.key_up(Keys.ARROW_DOWN)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def type_up(self, wait=0):\n\"\"\"\n        Press Up key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.ARROW_UP)\n        action.key_up(Keys.ARROW_UP)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def space(self, wait=0):\n\"\"\"\n        Press Space key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.SPACE)\n        action.key_up(Keys.SPACE)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def backspace(self, wait=0):\n\"\"\"\n        Press Backspace key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.BACK_SPACE)\n        action.key_up(Keys.BACK_SPACE)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def delete(self, wait=0):\n\"\"\"\n        Press Delete key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.key_down(Keys.DELETE)\n        action.key_up(Keys.DELETE)\n        action.perform()\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    ######\n    # Misc\n    ######\n\n    def wait(self, interval):\n\"\"\"\n        Wait / Sleep for a given interval.\n\n        Args:\n            interval (int): Interval in milliseconds\n\n        \"\"\"\n        time.sleep(interval / 1000.0)\n\n    def sleep(self, interval):\n\"\"\"\n        Wait / Sleep for a given interval.\n\n        Args:\n            interval (int): Interval in milliseconds\n\n        \"\"\"\n        self.wait(interval)\n\n    def wait_for_file(self, path, timeout=60000):\n\"\"\"\n        Wait for a file to be available on disk.\n\n        Args:\n            path (str): The path for the file to be executed\n            timeout (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 60000ms (60s).\n\n        Returns:\n            status (bool): Whether or not the file was available before the timeout\n\n        \"\"\"\n        path = os.path.abspath(os.path.expanduser(os.path.expandvars(path)))\n        start_time = time.time()\n\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; timeout:\n                return False\n            if os.path.isfile(path) and os.access(path, os.R_OK):\n                if self.browser == Browser.FIREFOX and os.path.getsize(path) == 0:\n                    # if file is empty, the download is not completed.\n                    continue\n                self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n                return True\n            self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def get_last_created_file(self, path=None, file_extension=\"\"):\n\"\"\"Returns the last created file in a specific folder path.\n\n        Args:\n            path (str, optional): The path of the folder where the file is expected. Defaults to None.\n            file_extension (str, optional): The extension of the file to be searched for (e.g., .pdf, .txt).\n\n        Returns:\n            str: the path of the last created file\n        \"\"\"\n        if not path:\n            path = self.download_folder_path\n\n        files_path = glob.glob(os.path.expanduser(os.path.join(path, f\"*{file_extension}\")))\n        last_created_file = max(files_path, key=os.path.getctime)\n        return last_created_file\n\n    def get_file_count(self, path=None, file_extension=\"\"):\n\"\"\"Get the total number of files of the same type.\n\n        Args:\n            path (str, optional): The path of the folder where the files are saved.\n            file_extension (str, optional): The extension of the files to be searched for (e.g., .pdf, .txt).\n\n        Returns:\n            int: the number of files of the given type\n        \"\"\"\n        if not path:\n            path = self.download_folder_path\n\n        files_path = glob.glob(os.path.expanduser(os.path.join(path, f\"*{file_extension}\")))\n        return len(files_path)\n\n    def wait_for_new_file(self, path=None, file_extension=\"\", current_count=0, timeout=60000):\n\"\"\"\n        Wait for a new file to be available on disk without the file path.\n\n        Args:\n            path (str, optional): The path of the folder where the file is expected. Defaults to None.\n            file_extension (str, optional): The extension of the file to be searched for (e.g., .pdf, .txt).\n            current_count (int): The current number of files in the folder of the given type. Defaults to 0 files\n            timeout (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 60000ms (60s).\n\n        Returns:\n            str: the path of the last created file of the given type\n        \"\"\"\n        if not path:\n            path = self.download_folder_path\n\n        start_time = time.time()\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; timeout:\n                return None\n            file_count = self.get_file_count(path, f\"*{file_extension}\")\n            if file_count == current_count + 1:\n                self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n                return self.get_last_created_file(path, f\"*{file_extension}\")\n            self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.browser","title":"<code>browser</code>  <code>property</code> <code>writable</code>","text":"<p>The web browser to be used.</p> <p>Returns:</p> Type Description <code>browser (Browser)</code> <p>The web browser to be used.</p>"},{"location":"bot/#botcity.web.bot.WebBot.capabilities","title":"<code>capabilities</code>  <code>property</code> <code>writable</code>","text":"<p>The capabilities to be passed down to the WebDriver when starting the browser.</p> <p>Returns:</p> Type Description <code>capabilities (Dict)</code> <p>The browser specific capabilities to be used.</p>"},{"location":"bot/#botcity.web.bot.WebBot.driver","title":"<code>driver</code>  <code>property</code> <code>readonly</code>","text":"<p>The WebDriver driver instance.</p> <p>Returns:</p> Type Description <code>driver (WebDriver)</code> <p>The WebDriver driver instance.</p>"},{"location":"bot/#botcity.web.bot.WebBot.headless","title":"<code>headless</code>  <code>property</code> <code>writable</code>","text":"<p>Controls whether or not the bot will run headless.</p> <p>Returns:</p> Type Description <code>headless (bool)</code> <p>Whether or not to run the browser on headless mode.</p>"},{"location":"bot/#botcity.web.bot.WebBot.options","title":"<code>options</code>  <code>property</code> <code>writable</code>","text":"<p>The options to be passed down to the WebDriver when starting the browser.</p> <p>Returns:</p> Type Description <code>options (Options)</code> <p>The browser specific options to be used.</p>"},{"location":"bot/#botcity.web.bot.WebBot.page_load_strategy","title":"<code>page_load_strategy: PageLoadStrategy</code>  <code>property</code> <code>writable</code>","text":"<p>The page load strategy to be used.</p> <p>Returns:</p> Type Description <code>page_load_strategy (PageLoadStrategy)</code> <p>The page load strategy to be used.</p>"},{"location":"bot/#botcity.web.bot.WebBot.activate_tab","title":"<code>activate_tab(self, handle)</code>","text":"<p>Activate a tab given by the handle.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>str</code> <p>The tab or window handle.</p> required Source code in <code>web/bot.py</code> <pre><code>def activate_tab(self, handle):\n\"\"\"Activate a tab given by the handle.\n\n    Args:\n        handle (str): The tab or window handle.\n    \"\"\"\n    self._driver.switch_to.window(handle)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.add_image","title":"<code>add_image(self, label, path)</code>","text":"<p>Add an image into the state image map.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>path</code> <code>str</code> <p>The path for the image on disk</p> required Source code in <code>web/bot.py</code> <pre><code>def add_image(self, label, path):\n\"\"\"\n    Add an image into the state image map.\n\n    Args:\n        label (str): The image identifier\n        path (str): The path for the image on disk\n    \"\"\"\n    self.state.map_images[label] = path\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.back","title":"<code>back(self)</code>","text":"<p>Goes one step backward in the browser history.</p> Source code in <code>web/bot.py</code> <pre><code>def back(self):\n\"\"\"\n    Goes one step backward in the browser history.\n    \"\"\"\n    self._driver.back()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.backspace","title":"<code>backspace(self, wait=0)</code>","text":"<p>Press Backspace key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def backspace(self, wait=0):\n\"\"\"\n    Press Backspace key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.BACK_SPACE)\n    action.key_up(Keys.BACK_SPACE)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.browse","title":"<code>browse(self, url)</code>","text":"<p>Opens the browser on the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to be visited.</p> required Source code in <code>web/bot.py</code> <pre><code>def browse(self, url):\n\"\"\"\n    Opens the browser on the given URL.\n\n    Args:\n        url (str):  The URL to be visited.\n    \"\"\"\n    self.navigate_to(url)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.click","title":"<code>click(self, wait_after=300, *, clicks=1, interval_between_clicks=0, button='left')</code>","text":"<p>Click on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> <code>clicks</code> <code>int</code> <p>Number of times to click. Defaults to 1.</p> <code>1</code> <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>button</code> <code>str</code> <p>One of 'left', 'right'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n          clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n    Click on the last found element.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        clicks (int, optional): Number of times to click. Defaults to 1.\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        button (str, optional): One of 'left', 'right'. Defaults to 'left'\n    \"\"\"\n    x, y = self.state.center()\n    self.click_at(x, y, clicks=clicks, button=button, interval_between_clicks=interval_between_clicks)\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.click_at","title":"<code>click_at(self, x, y, *, clicks=1, interval_between_clicks=0, button='left')</code>","text":"<p>Click at the coordinate defined by x and y</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The X coordinate</p> required <code>y</code> <code>int</code> <p>The Y coordinate</p> required <code>clicks</code> <code>int</code> <p>Number of times to click. Defaults to 1.</p> <code>1</code> <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>button</code> <code>str</code> <p>One of 'left', 'right'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>web/bot.py</code> <pre><code>def click_at(self, x, y, *, clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n    Click at the coordinate defined by x and y\n\n    Args:\n        x (int): The X coordinate\n        y (int): The Y coordinate\n        clicks (int, optional): Number of times to click. Defaults to 1.\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        button (str, optional): One of 'left', 'right'. Defaults to 'left'\n    \"\"\"\n    self.mouse_move(x, y)\n    ac = ActionChains(self._driver)\n    for i in range(clicks):\n        if button == 'left':\n            ac.click()\n        elif button == 'right':\n            ac.context_click()\n        else:\n            raise ValueError('Invalid value for button. Accepted values are left or right.')\n        ac.pause(interval_between_clicks/1000.0)\n    ac.perform()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.click_on","title":"<code>click_on(self, label)</code>","text":"<p>Click on the element.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required Source code in <code>web/bot.py</code> <pre><code>def click_on(self, label):\n\"\"\"\n    Click on the element.\n\n    Args:\n        label (str): The image identifier\n    \"\"\"\n    x, y = self.get_element_coords_centered(label)\n    if None in (x, y):\n        raise ValueError(f'Element not available. Cannot find {label}.')\n    self.click_at(x, y)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.click_relative","title":"<code>click_relative(self, x, y, wait_after=300, *, clicks=1, interval_between_clicks=0, button='left')</code>","text":"<p>Click Relative on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> <code>clicks</code> <code>int</code> <p>Number of times to click. Defaults to 1.</p> <code>1</code> <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>button</code> <code>str</code> <p>One of 'left', 'right'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef click_relative(self, x, y, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n                   clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n    Click Relative on the last found element.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        clicks (int, optional): Number of times to click. Defaults to 1.\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        button (str, optional): One of 'left', 'right'. Defaults to 'left'\n    \"\"\"\n    x = self.state.x() + x\n    y = self.state.y() + y\n    self.click_at(x, y, clicks=clicks, button=button, interval_between_clicks=interval_between_clicks)\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.close_page","title":"<code>close_page(self)</code>","text":"<p>Close the current active page (tab or window).</p> Source code in <code>web/bot.py</code> <pre><code>def close_page(self):\n\"\"\"Close the current active page (tab or window).\n    \"\"\"\n    try:\n        self._driver.close()\n\n        # If it was the last tab we can't switch\n        tabs = self.get_tabs()\n        if tabs:\n            self._driver.switch_to.window(tabs[-1])\n    except InvalidSessionIdException:\n        pass\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.control_a","title":"<code>control_a(self, wait=0)</code>","text":"<p>Press keys CTRL+A</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def control_a(self, wait=0):\n\"\"\"\n    Press keys CTRL+A\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    key = Keys.CONTROL\n    if platform.system() == 'Darwin':\n        key = Keys.COMMAND\n\n    action.key_down(key)\n    action.send_keys('a')\n    action.key_up(key)\n    action.perform()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.control_c","title":"<code>control_c(self, wait=0)</code>","text":"<p>Press keys CTRL+C</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def control_c(self, wait=0):\n\"\"\"\n    Press keys CTRL+C\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    # Firefox can't do window.getSelection() and return a proper value when the selected text\n    # is in an input of similar. While Firefox doesn't get its shit together we apply this\n    # ugly alternative so control+c works for \"all\" browsers tested so far.\n    cmd = \"\"\"\n        try {\n            return document.activeElement.value.substring(\n                document.activeElement.selectionStart,\n                document.activeElement.selectionEnd\n            );\n        } catch(error) {\n            return window.getSelection().toString();\n        }\n    \"\"\"\n\n    self._clipboard = self.execute_javascript(cmd)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.control_v","title":"<code>control_v(self, wait=0)</code>","text":"<p>Press keys CTRL+V</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def control_v(self, wait=0):\n\"\"\"\n    Press keys CTRL+V\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.paste()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.copy_to_clipboard","title":"<code>copy_to_clipboard(self, text, wait=0)</code>","text":"<p>Copy content to the clipboard.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to be copied.</p> required <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def copy_to_clipboard(self, text, wait=0):\n\"\"\"\n    Copy content to the clipboard.\n\n    Args:\n        text (str): The text to be copied.\n        wait (int, optional): Wait interval (ms) after task\n    \"\"\"\n    self._clipboard = text\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.create_tab","title":"<code>create_tab(self, url)</code>","text":"<p>Create a new tab and navigate to the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The desired URL.</p> required Source code in <code>web/bot.py</code> <pre><code>def create_tab(self, url):\n\"\"\"Create a new tab and navigate to the given URL.\n\n    Args:\n        url (str): The desired URL.\n    \"\"\"\n    try:\n        # Refactor this when Selenium 4 is released\n        self.execute_javascript(f\"window.open('{url}', '_blank');\")\n        self._driver.switch_to.window(self.get_tabs()[-1])\n    except InvalidSessionIdException:\n        self.navigate_to(url)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.create_window","title":"<code>create_window(self, url)</code>","text":"<p>Creates a new window with the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The desired URL.</p> required Source code in <code>web/bot.py</code> <pre><code>def create_window(self, url):\n\"\"\"Creates a new window with the given URL.\n\n    Args:\n        url (str): The desired URL.\n    \"\"\"\n    try:\n        # Refactor this when Selenium 4 is released\n        self.execute_javascript(f\"window.open('{url}', '_blank', 'location=0');\")\n        self._driver.switch_to.window(self.get_tabs()[-1])\n    except InvalidSessionIdException:\n        self.navigate_to(url)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.delete","title":"<code>delete(self, wait=0)</code>","text":"<p>Press Delete key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def delete(self, wait=0):\n\"\"\"\n    Press Delete key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.DELETE)\n    action.key_up(Keys.DELETE)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.display_size","title":"<code>display_size(self)</code>","text":"<p>Returns the display size in pixels.</p> <p>Returns:</p> Type Description <code>size (Tuple)</code> <p>The screen dimension (width and height) in pixels.</p> Source code in <code>web/bot.py</code> <pre><code>def display_size(self):\n\"\"\"\n    Returns the display size in pixels.\n\n    Returns:\n        size (Tuple): The screen dimension (width and height) in pixels.\n    \"\"\"\n    return self._get_page_size()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.double_click","title":"<code>double_click(self, wait_after=300)</code>","text":"<p>Double Click on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef double_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Double Click on the last found element.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n    \"\"\"\n    self.click(interval_between_clicks=wait_after, clicks=2)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.double_click_relative","title":"<code>double_click_relative(self, x, y, interval_between_clicks=0, wait_after=300)</code>","text":"<p>Double Click Relative on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef double_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Double Click Relative on the last found element.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        wait_after (int, optional): Interval to wait after clicking on the element.\n    \"\"\"\n    self.click_relative(x, y, wait_after=wait_after, clicks=2, interval_between_clicks=interval_between_clicks)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.enter","title":"<code>enter(self, wait=0)</code>","text":"<p>Press key Enter</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def enter(self, wait=0):\n\"\"\"\n    Press key Enter\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.ENTER)\n    action.key_up(Keys.ENTER)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.enter_iframe","title":"<code>enter_iframe(self, iframe)</code>","text":"<p>Switch the WebBot driver to the specified iframe.</p> <p>Parameters:</p> Name Type Description Default <code>iframe</code> <code>WebElement</code> <p>The desired iFrame.</p> required Source code in <code>web/bot.py</code> <pre><code>def enter_iframe(self, iframe: WebElement):\n\"\"\"Switch the WebBot driver to the specified iframe.\n\n    Args:\n        iframe (WebElement): The desired iFrame.\n    \"\"\"\n    self._driver.switch_to.frame(iframe)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.execute_javascript","title":"<code>execute_javascript(self, code)</code>","text":"<p>Execute the given javascript code.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The code to be executed.</p> required <p>Returns:</p> Type Description <code>value (object)</code> <p>Returns the code output or None if not available or if an error happens.</p> Source code in <code>web/bot.py</code> <pre><code>def execute_javascript(self, code):\n\"\"\"\n    Execute the given javascript code.\n\n    Args:\n        code (str): The code to be executed.\n\n    Returns:\n        value (object): Returns the code output or None if not available or if an error happens.\n    \"\"\"\n    return self._driver.execute_script(code)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.find","title":"<code>find(self, label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False)</code>","text":"<p>Find an element defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>best</code> <code>bool</code> <p>Whether or not to keep looking until the best matching is found. Defaults to True.</p> <code>True</code> <code>grayscale</code> <code>bool</code> <p>Whether or not to convert to grayscale before searching. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>element (NamedTuple)</code> <p>The element coordinates. None if not found.</p> Source code in <code>web/bot.py</code> <pre><code>def find(self, label, x=None, y=None, width=None, height=None, *,\n         threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n    Find an element defined by label on screen until a timeout happens.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        best (bool, optional): Whether or not to keep looking until the best matching is found.\n            Defaults to True.\n        grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n            Defaults to False.\n\n    Returns:\n        element (NamedTuple): The element coordinates. None if not found.\n    \"\"\"\n    return self.find_until(label=label, x=x, y=y, width=width, height=height, threshold=threshold,\n                           matching=matching, waiting_time=waiting_time, best=best, grayscale=grayscale)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.find_all","title":"<code>find_all(self, label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, grayscale=False, as_list=False)</code>","text":"<p>Find all elements defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>grayscale</code> <code>bool</code> <p>Whether or not to convert to grayscale before searching. Defaults to False.</p> <code>False</code> <code>as_list</code> <code>bool, Optional</code> <p>If True, returns a list of element coordinates instead of a generator. Use set_active_element() to be able to interact with the found elements. This parameter must be True if you intend to run multiple find_all() concurrently. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>elements (collections.Iterable[NamedTuple])</code> <p>A generator with all element coordinates found.     None if not found.</p> Source code in <code>web/bot.py</code> <pre><code>def find_all(self, label, x=None, y=None, width=None, height=None, *,\n             threshold=None, matching=0.9, waiting_time=10000, grayscale=False, as_list: bool = False):\n\"\"\"\n    Find all elements defined by label on screen until a timeout happens.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n            Defaults to False.\n        as_list (bool, Optional): If True, returns a list of element coordinates instead of a generator.\n            Use set_active_element() to be able to interact with the found elements.\n            This parameter must be True if you intend to run multiple find_all() concurrently.\n            Defaults to False.\n\n    Returns:\n        elements (collections.Iterable[NamedTuple]): A generator with all element coordinates found.\n            None if not found.\n    \"\"\"\n    def deduplicate(elems):\n        def find_same(item, items):\n            x_start = item.left\n            x_end = item.left + item.width\n            y_start = item.top\n            y_end = item.top + item.height\n            similars = []\n            for itm in items:\n                if itm == item:\n                    continue\n                if (itm.left &gt;= x_start and itm.left &lt; x_end)\\\n                        and (itm.top &gt;= y_start and itm.top &lt; y_end):\n                    similars.append(itm)\n                    continue\n            return similars\n\n        index = 0\n        while True:\n            try:\n                dups = find_same(elems[index], elems[index:])\n                for d in dups:\n                    elems.remove(d)\n                index += 1\n            except IndexError:\n                break\n        return elems\n\n    self.state.element = None\n    screen_w, screen_h = self._get_page_size()\n    x = x or 0\n    y = y or 0\n    w = width or screen_w\n    h = height or screen_h\n\n    region = (x, y, w, h)\n\n    element_path = self._search_image_file(label)\n    element_path = self._image_path_as_image(element_path)\n\n    if threshold:\n        # TODO: Figure out how we should do threshold\n        print('Threshold not yet supported')\n\n    start_time = time.time()\n\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; waiting_time:\n            return None\n\n        haystack = self.get_screen_image()\n        it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                       region=region, confidence=matching, grayscale=grayscale)\n\n        eles = [ele for ele in it]\n        if not eles:\n            continue\n        eles = deduplicate(list(eles))\n\n        # As List\n        if as_list:\n            return eles\n\n        # As Generator\n        for ele in eles:\n            if ele is not None:\n                self.state.element = ele\n                yield ele\n        break\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.find_element","title":"<code>find_element(self, selector, by='css selector', waiting_time=10000, ensure_visible=False, ensure_clickable=False)</code>","text":"<p>Find an element using the specified selector with selector type specified by <code>by</code>. If more than one element is found, the first instance is returned.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>str</code> <p>The selector string to be used.</p> required <code>by</code> <code>str</code> <p>Selector type. Defaults to By.CSS_SELECTOR. See more</p> <code>'css selector'</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>ensure_visible</code> <code>bool</code> <p>Whether to wait for the element to be visible. Defaults to False.</p> <code>False</code> <code>ensure_clickable</code> <code>bool</code> <p>Whether to wait for the element to be clickable. Defaults to False. If True, <code>ensure_clickable</code> takes precedence over <code>ensure_visible</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>WebElement</code> <p>The element found.</p> <p>Example: <pre><code>from botcity.web import By\n...\n# Find element by ID\nelem = self.find_element(\"my_elem\", By.ID)\n# Find element by XPath\nelem = self.find_element(\"//input[@type='submit']\", By.XPATH)\n...\n</code></pre></p> Source code in <code>web/bot.py</code> <pre><code>def find_element(self, selector: str, by: str = By.CSS_SELECTOR, waiting_time=10000,\n                 ensure_visible: bool = False, ensure_clickable: bool = False) -&gt; WebElement:\n\"\"\"Find an element using the specified selector with selector type specified by `by`.\n    If more than one element is found, the first instance is returned.\n\n    Args:\n        selector (str): The selector string to be used.\n        by (str, optional): Selector type. Defaults to By.CSS_SELECTOR.\n            [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By)\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        ensure_visible (bool, optional): Whether to wait for the element to be visible. Defaults to False.\n        ensure_clickable (bool, optional): Whether to wait for the element to be clickable. Defaults to False.\n            If True, `ensure_clickable` takes precedence over `ensure_visible`.\n\n    Returns:\n        WebElement: The element found.\n\n    **Example:**\n    ```python\n    from botcity.web import By\n    ...\n    # Find element by ID\n    elem = self.find_element(\"my_elem\", By.ID)\n    # Find element by XPath\n    elem = self.find_element(\"//input[@type='submit']\", By.XPATH)\n    ...\n    ```\n    \"\"\"\n    condition = EC.visibility_of_element_located if ensure_visible else EC.presence_of_element_located\n    condition = EC.element_to_be_clickable if ensure_clickable else condition\n\n    try:\n        element = WebDriverWait(\n            self._driver, timeout=waiting_time/1000.0\n        ).until(\n            condition((by, selector))\n        )\n        return element\n    except (TimeoutException, NoSuchElementException):\n        return None\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.find_elements","title":"<code>find_elements(self, selector, by='css selector', waiting_time=10000, ensure_visible=True)</code>","text":"<p>Find elements using the specified selector with selector type specified by <code>by</code>.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>str</code> <p>The selector string to be used.</p> required <code>by</code> <code>str</code> <p>Selector type. Defaults to By.CSS_SELECTOR. See more</p> <code>'css selector'</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>ensure_visible</code> <code>bool</code> <p>Whether to wait for the element to be visible. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[WebElement]</code> <p>List of elements found.</p> <p>Example: <pre><code>from botcity.web import By\n...\n# Find element by ID\nall_cells = self.find_elements(\"//td\", By.XPATH)\n...\n</code></pre></p> Source code in <code>web/bot.py</code> <pre><code>def find_elements(self, selector: str, by: By = By.CSS_SELECTOR,\n                  waiting_time=10000, ensure_visible: bool = True) -&gt; List[WebElement]:\n\"\"\"Find elements using the specified selector with selector type specified by `by`.\n\n    Args:\n        selector (str): The selector string to be used.\n        by (str, optional): Selector type. Defaults to By.CSS_SELECTOR.\n            [See more](https://selenium-python.readthedocs.io/api.html#selenium.webdriver.common.by.By)\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        ensure_visible (bool, optional): Whether to wait for the element to be visible. Defaults to True.\n\n    Returns:\n        List[WebElement]: List of elements found.\n\n    **Example:**\n    ```python\n    from botcity.web import By\n    ...\n    # Find element by ID\n    all_cells = self.find_elements(\"//td\", By.XPATH)\n    ...\n    ```\n    \"\"\"\n    if ensure_visible:\n        condition = EC.visibility_of_all_elements_located\n    else:\n        condition = EC.presence_of_all_elements_located\n\n    try:\n        elements = WebDriverWait(\n            self._driver, timeout=waiting_time / 1000.0\n        ).until(\n            condition((by, selector))\n        )\n        return elements\n    except (TimeoutException, NoSuchElementException) as ex:\n        print(\"Exception on find_elements\", ex)\n        return None\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.find_multiple","title":"<code>find_multiple(self, labels, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False)</code>","text":"<p>Find multiple elements defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>list</code> <p>A list of image identifiers</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>best</code> <code>bool</code> <p>Whether or not to keep looking until the best matching is found. Defaults to True.</p> <code>True</code> <code>grayscale</code> <code>bool</code> <p>Whether or not to convert to grayscale before searching. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>results (dict)</code> <p>A dictionary in which the key is the label and value are the element coordinates in a    NamedTuple.</p> Source code in <code>web/bot.py</code> <pre><code>def find_multiple(self, labels, x=None, y=None, width=None, height=None, *,\n                  threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n    Find multiple elements defined by label on screen until a timeout happens.\n\n    Args:\n        labels (list): A list of image identifiers\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        best (bool, optional): Whether or not to keep looking until the best matching is found.\n            Defaults to True.\n        grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n            Defaults to False.\n\n    Returns:\n        results (dict): A dictionary in which the key is the label and value are the element coordinates in a\n           NamedTuple.\n    \"\"\"\n\n    def _to_dict(lbs, elems):\n        return {k: v for k, v in zip(lbs, elems)}\n\n    screen_w, screen_h = self._get_page_size()\n    x = x or 0\n    y = y or 0\n    w = width or screen_w\n    h = height or screen_h\n\n    region = (x, y, w, h)\n\n    results = [None] * len(labels)\n    paths = [self._search_image_file(la) for la in labels]\n    paths = [self._image_path_as_image(la) for la in paths]\n\n    if threshold:\n        # TODO: Figure out how we should do threshold\n        print('Threshold not yet supported')\n\n    if not best:\n        # TODO: Implement best=False.\n        print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n    start_time = time.time()\n\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; waiting_time:\n            return _to_dict(labels, results)\n\n        haystack = self.screenshot()\n        helper = functools.partial(self._find_multiple_helper, haystack, region, matching, grayscale)\n\n        results = [helper(p) for p in paths]\n\n        results = [r for r in results]\n        if None in results:\n            continue\n        else:\n            return _to_dict(labels, results)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.find_text","title":"<code>find_text(self, label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, best=True)</code>","text":"<p>Find an element defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>best</code> <code>bool</code> <p>Whether or not to keep looking until the best matching is found. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>element (NamedTuple)</code> <p>The element coordinates. None if not found.</p> Source code in <code>web/bot.py</code> <pre><code>def find_text(self, label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9,\n              waiting_time=10000, best=True):\n\"\"\"\n    Find an element defined by label on screen until a timeout happens.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        best (bool, optional): Whether or not to keep looking until the best matching is found.\n            Defaults to True.\n\n    Returns:\n        element (NamedTuple): The element coordinates. None if not found.\n    \"\"\"\n    return self.find_until(label, x, y, width, height, threshold=threshold, matching=matching,\n                           waiting_time=waiting_time, best=best, grayscale=True)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.find_until","title":"<code>find_until(self, label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False)</code>","text":"<p>Find an element defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>best</code> <code>bool</code> <p>Whether or not to keep looking until the best matching is found. Defaults to True.</p> <code>True</code> <code>grayscale</code> <code>bool</code> <p>Whether or not to convert to grayscale before searching. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>element (NamedTuple)</code> <p>The element coordinates. None if not found.</p> Source code in <code>web/bot.py</code> <pre><code>def find_until(self, label, x=None, y=None, width=None, height=None, *,\n               threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n    Find an element defined by label on screen until a timeout happens.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        best (bool, optional): Whether or not to keep looking until the best matching is found.\n            Defaults to True.\n        grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n            Defaults to False.\n\n    Returns:\n        element (NamedTuple): The element coordinates. None if not found.\n    \"\"\"\n    self.state.element = None\n    screen_w, screen_h = self._get_page_size()\n    x = x or 0\n    y = y or 0\n    w = width or screen_w\n    h = height or screen_h\n\n    region = (x, y, w, h)\n\n    element_path = self._search_image_file(label)\n    element_path = self._image_path_as_image(element_path)\n\n    if threshold:\n        # TODO: Figure out how we should do threshold\n        print('Threshold not yet supported')\n\n    if not best:\n        # TODO: Implement best=False.\n        print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n    start_time = time.time()\n\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; waiting_time:\n            return None\n        haystack = self.get_screen_image()\n        it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                       region=region, confidence=matching, grayscale=grayscale)\n        try:\n            ele = next(it)\n        except StopIteration:\n            ele = None\n\n        if ele is not None:\n            self.state.element = ele\n            return ele\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.forward","title":"<code>forward(self)</code>","text":"<p>Goes one step forward in the browser history.</p> Source code in <code>web/bot.py</code> <pre><code>def forward(self):\n\"\"\"\n    Goes one step forward in the browser history.\n    \"\"\"\n    self._driver.forward()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_clipboard","title":"<code>get_clipboard(self)</code>","text":"<p>Get the current content in the clipboard.</p> <p>Returns:</p> Type Description <code>text (str)</code> <p>Current clipboard content</p> Source code in <code>web/bot.py</code> <pre><code>def get_clipboard(self):\n\"\"\"\n    Get the current content in the clipboard.\n\n    Returns:\n        text (str): Current clipboard content\n    \"\"\"\n    return self._clipboard\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_element_coords","title":"<code>get_element_coords(self, label, x=None, y=None, width=None, height=None, matching=0.9, best=True)</code>","text":"<p>Find an element defined by label on screen and returns its coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>X (Left) coordinate of the search area.</p> <code>None</code> <code>y</code> <code>int</code> <p>Y (Top) coordinate of the search area.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the search area.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the search area.</p> <code>None</code> <code>matching</code> <code>float</code> <p>Minimum score to consider a match in the element image recognition process. Defaults to 0.9.</p> <code>0.9</code> <code>best</code> <code>bool</code> <p>Whether or not to search for the best value. If False the method returns on the first find. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>coords (Tuple)</code> <p>A tuple containing the x and y coordinates for the element.</p> Source code in <code>web/bot.py</code> <pre><code>def get_element_coords(self, label, x=None, y=None, width=None, height=None, matching=0.9, best=True):\n\"\"\"\n    Find an element defined by label on screen and returns its coordinates.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): X (Left) coordinate of the search area.\n        y (int, optional): Y (Top) coordinate of the search area.\n        width (int, optional): Width of the search area.\n        height (int, optional): Height of the search area.\n        matching (float, optional): Minimum score to consider a match in the element image recognition process.\n            Defaults to 0.9.\n        best (bool, optional): Whether or not to search for the best value. If False the method returns on\n            the first find. Defaults to True.\n\n    Returns:\n        coords (Tuple): A tuple containing the x and y coordinates for the element.\n    \"\"\"\n    self.state.element = None\n    screen_size = self._get_page_size()\n    x = x or 0\n    y = y or 0\n    width = width or screen_size[0]\n    height = height or screen_size[1]\n    region = (x, y, width, height)\n\n    if not best:\n        print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n    element_path = self._search_image_file(label)\n    element_path = self._image_path_as_image(element_path)\n    haystack = self.get_screen_image()\n\n    it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                   region=region, confidence=matching)\n    try:\n        ele = next(it)\n    except StopIteration:\n        ele = None\n    self.state.element = ele\n\n    if ele:\n        return ele.left, ele.top\n    else:\n        return None, None\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_element_coords_centered","title":"<code>get_element_coords_centered(self, label, x=None, y=None, width=None, height=None, matching=0.9, best=True)</code>","text":"<p>Find an element defined by label on screen and returns its centered coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>X (Left) coordinate of the search area.</p> <code>None</code> <code>y</code> <code>int</code> <p>Y (Top) coordinate of the search area.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the search area.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the search area.</p> <code>None</code> <code>matching</code> <code>float</code> <p>Minimum score to consider a match in the element image recognition process. Defaults to 0.9.</p> <code>0.9</code> <code>best</code> <code>bool</code> <p>Whether or not to search for the best value. If False the method returns on the first find. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>coords (Tuple)</code> <p>A tuple containing the x and y coordinates for the center of the element.</p> Source code in <code>web/bot.py</code> <pre><code>def get_element_coords_centered(self, label, x=None, y=None, width=None, height=None,\n                                matching=0.9, best=True):\n\"\"\"\n    Find an element defined by label on screen and returns its centered coordinates.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): X (Left) coordinate of the search area.\n        y (int, optional): Y (Top) coordinate of the search area.\n        width (int, optional): Width of the search area.\n        height (int, optional): Height of the search area.\n        matching (float, optional): Minimum score to consider a match in the element image recognition process.\n            Defaults to 0.9.\n        best (bool, optional): Whether or not to search for the best value. If False the method returns on\n            the first find. Defaults to True.\n\n    Returns:\n        coords (Tuple): A tuple containing the x and y coordinates for the center of the element.\n    \"\"\"\n    self.get_element_coords(label, x, y, width, height, matching, best)\n    return self.state.center()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_file_count","title":"<code>get_file_count(self, path=None, file_extension='')</code>","text":"<p>Get the total number of files of the same type.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the folder where the files are saved.</p> <code>None</code> <code>file_extension</code> <code>str</code> <p>The extension of the files to be searched for (e.g., .pdf, .txt).</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>the number of files of the given type</p> Source code in <code>web/bot.py</code> <pre><code>def get_file_count(self, path=None, file_extension=\"\"):\n\"\"\"Get the total number of files of the same type.\n\n    Args:\n        path (str, optional): The path of the folder where the files are saved.\n        file_extension (str, optional): The extension of the files to be searched for (e.g., .pdf, .txt).\n\n    Returns:\n        int: the number of files of the given type\n    \"\"\"\n    if not path:\n        path = self.download_folder_path\n\n    files_path = glob.glob(os.path.expanduser(os.path.join(path, f\"*{file_extension}\")))\n    return len(files_path)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_image_from_map","title":"<code>get_image_from_map(self, label)</code>","text":"<p>Return an image from teh state image map.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <p>Returns:</p> Type Description <code>Image</code> <p>The Image object</p> Source code in <code>web/bot.py</code> <pre><code>def get_image_from_map(self, label):\n\"\"\"\n    Return an image from teh state image map.\n\n    Args:\n        label (str): The image identifier\n\n    Returns:\n        Image: The Image object\n    \"\"\"\n    path = self.state.map_images.get(label)\n    if not path:\n        raise KeyError('Invalid label for image map.')\n    img = Image.open(path)\n    return img\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_js_dialog","title":"<code>get_js_dialog(self)</code>","text":"<p>Return the last found dialog. Invoke first the <code>find_js_dialog</code> method to look up.</p> <p>Returns:</p> Type Description <code>dialog (dict)</code> <p>The dialog information or None if not available.     See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening</p> Source code in <code>web/bot.py</code> <pre><code>def get_js_dialog(self):\n\"\"\"\n    Return the last found dialog. Invoke first the `find_js_dialog` method to look up.\n\n    Returns:\n        dialog (dict): The dialog information or None if not available.\n            See https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening\n    \"\"\"\n    try:\n        dialog = self._driver.switch_to.alert\n        return dialog\n    except Exception:\n        return None\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_last_created_file","title":"<code>get_last_created_file(self, path=None, file_extension='')</code>","text":"<p>Returns the last created file in a specific folder path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the folder where the file is expected. Defaults to None.</p> <code>None</code> <code>file_extension</code> <code>str</code> <p>The extension of the file to be searched for (e.g., .pdf, .txt).</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>the path of the last created file</p> Source code in <code>web/bot.py</code> <pre><code>def get_last_created_file(self, path=None, file_extension=\"\"):\n\"\"\"Returns the last created file in a specific folder path.\n\n    Args:\n        path (str, optional): The path of the folder where the file is expected. Defaults to None.\n        file_extension (str, optional): The extension of the file to be searched for (e.g., .pdf, .txt).\n\n    Returns:\n        str: the path of the last created file\n    \"\"\"\n    if not path:\n        path = self.download_folder_path\n\n    files_path = glob.glob(os.path.expanduser(os.path.join(path, f\"*{file_extension}\")))\n    last_created_file = max(files_path, key=os.path.getctime)\n    return last_created_file\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_last_element","title":"<code>get_last_element(self)</code>","text":"<p>Return the last element found.</p> <p>Returns:</p> Type Description <code>element (NamedTuple)</code> <p>The element coordinates (left, top, width, height)</p> Source code in <code>web/bot.py</code> <pre><code>def get_last_element(self):\n\"\"\"\n    Return the last element found.\n\n    Returns:\n        element (NamedTuple): The element coordinates (left, top, width, height)\n    \"\"\"\n    return self.state.element\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_last_x","title":"<code>get_last_x(self)</code>","text":"<p>Get the last X position for the mouse.</p> <p>Returns:</p> Type Description <code>x (int)</code> <p>The last x position for the mouse.</p> Source code in <code>web/bot.py</code> <pre><code>def get_last_x(self):\n\"\"\"\n    Get the last X position for the mouse.\n\n    Returns:\n        x (int): The last x position for the mouse.\n    \"\"\"\n    return self._x\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_last_y","title":"<code>get_last_y(self)</code>","text":"<p>Get the last Y position for the mouse.</p> <p>Returns:</p> Type Description <code>y (int)</code> <p>The last y position for the mouse.</p> Source code in <code>web/bot.py</code> <pre><code>def get_last_y(self):\n\"\"\"\n    Get the last Y position for the mouse.\n\n    Returns:\n        y (int): The last y position for the mouse.\n    \"\"\"\n    return self._y\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_screen_image","title":"<code>get_screen_image(self, region=None)</code>","text":"<p>Capture and returns a screenshot from the browser.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>tuple</code> <p>A tuple containing the left, top, width and height to crop the screen image.</p> <code>None</code> <p>Returns:</p> Type Description <code>image (Image)</code> <p>The screenshot Image object.</p> Source code in <code>web/bot.py</code> <pre><code>def get_screen_image(self, region=None):\n\"\"\"\n    Capture and returns a screenshot from the browser.\n\n    Args:\n        region (tuple): A tuple containing the left, top, width and height\n            to crop the screen image.\n\n    Returns:\n        image (Image): The screenshot Image object.\n    \"\"\"\n    if not region:\n        region = (0, 0, 0, 0)\n\n    x = region[0]\n    y = region[1]\n    width = region[2] or self._get_page_size()[0]\n    height = region[3] or self._get_page_size()[1]\n\n    try:\n        data = self._driver.get_screenshot_as_base64()\n        image_data = base64.b64decode(data)\n        img = Image.open(io.BytesIO(image_data))\n    except:  # noqa: E722\n        img = Image.new(\"RGB\", (width, height))\n\n    img = img.crop((x, y, x + width, y + height))\n    return img\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_screenshot","title":"<code>get_screenshot(self, filepath=None, region=None)</code>","text":"<p>Capture a screenshot.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath in which to save the screenshot. Defaults to None.</p> <code>None</code> <code>region</code> <code>tuple</code> <p>Bounding box containing left, top, width and height to crop screenshot.</p> <code>None</code> <p>Returns:</p> Type Description <code>Image</code> <p>The screenshot Image object</p> Source code in <code>web/bot.py</code> <pre><code>def get_screenshot(self, filepath=None, region=None):\n\"\"\"\n    Capture a screenshot.\n\n    Args:\n        filepath (str, optional): The filepath in which to save the screenshot. Defaults to None.\n        region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot.\n\n    Returns:\n        Image: The screenshot Image object\n    \"\"\"\n    return self.screenshot(filepath, region)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_tabs","title":"<code>get_tabs(self)</code>","text":"<p>Get a list of tab handlers</p> <p>Returns:</p> Type Description <code>list</code> <p>List of tab handlers</p> Source code in <code>web/bot.py</code> <pre><code>def get_tabs(self):\n\"\"\"Get a list of tab handlers\n\n    Returns:\n        list: List of tab handlers\n    \"\"\"\n    try:\n        return self._driver.window_handles\n    except InvalidSessionIdException:\n        return []\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.get_viewport_size","title":"<code>get_viewport_size(self)</code>","text":"<p>Returns the browser current viewport size.</p> <p>Returns:</p> Type Description <code>width (int)</code> <p>The current viewport width. height (int): The current viewport height.</p> Source code in <code>web/bot.py</code> <pre><code>def get_viewport_size(self):\n\"\"\"\n    Returns the browser current viewport size.\n\n    Returns:\n        width (int): The current viewport width.\n        height (int): The current viewport height.\n    \"\"\"\n    # Access each dimension individually\n    width = self._driver.get_window_size().get(\"width\")\n    height = self._driver.get_window_size().get(\"height\")\n    return width, height\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.handle_js_dialog","title":"<code>handle_js_dialog(self, accept=True, prompt_text=None)</code>","text":"<p>Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). This also cleans the dialog information in the local buffer.</p> <p>Parameters:</p> Name Type Description Default <code>accept</code> <code>bool</code> <p>Whether to accept or dismiss the dialog.</p> <code>True</code> <code>prompt_text</code> <code>str</code> <p>The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.</p> <code>None</code> Source code in <code>web/bot.py</code> <pre><code>def handle_js_dialog(self, accept=True, prompt_text=None):\n\"\"\"\n    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).\n    This also cleans the dialog information in the local buffer.\n\n    Args:\n        accept (bool): Whether to accept or dismiss the dialog.\n        prompt_text (str): The text to enter into the dialog prompt before accepting.\n            Used only if this is a prompt dialog.\n    \"\"\"\n    dialog = self.get_js_dialog()\n    if not dialog:\n        # TODO: Maybe we should raise an exception here if no alert available\n        return\n    if prompt_text is not None:\n        dialog.send_keys(prompt_text)\n    if accept:\n        dialog.accept()\n    else:\n        dialog.dismiss()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.hold_shift","title":"<code>hold_shift(self, wait=0)</code>","text":"<p>Hold key Shift</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def hold_shift(self, wait=0):\n\"\"\"\n    Hold key Shift\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.SHIFT)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.install_firefox_extension","title":"<code>install_firefox_extension(self, extension)</code>","text":"<p>Install an extension in the Firefox browser. This will start the browser if it was not started yet.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The path of the .xpi extension to be loaded.</p> required Source code in <code>web/bot.py</code> <pre><code>def install_firefox_extension(self, extension):\n\"\"\"\n    Install an extension in the Firefox browser.\n    This will start the browser if it was not started yet.\n\n    Args:\n        extension (str): The path of the .xpi extension to be loaded.\n    \"\"\"\n    if self.browser != Browser.FIREFOX:\n        raise ValueError(\"install_firefox_extension only works with Firefox.\")\n    if not self._driver:\n        self.start_browser()\n    self._driver.install_addon(os.path.abspath(extension))\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.kb_type","title":"<code>kb_type(self, text, interval=0)</code>","text":"<p>Type a text char by char (individual key events).</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to be typed.</p> required <code>interval</code> <code>int</code> <p>interval (ms) between each key press. Defaults to 0</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def kb_type(self, text, interval=0):\n\"\"\"\n    Type a text char by char (individual key events).\n\n    Args:\n        text (str): text to be typed.\n        interval (int, optional): interval (ms) between each key press. Defaults to 0\n    \"\"\"\n    action = ActionChains(self._driver)\n\n    for c in text:\n        action.send_keys(c)\n        action.pause(interval / 1000.0)\n\n    action.perform()\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.key_end","title":"<code>key_end(self, wait=0)</code>","text":"<p>Press key End</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def key_end(self, wait=0):\n\"\"\"\n    Press key End\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.END)\n    action.key_up(Keys.END)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.key_enter","title":"<code>key_enter(self, wait=0)</code>","text":"<p>Press key Enter</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def key_enter(self, wait=0):\n\"\"\"\n    Press key Enter\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.enter(wait)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.key_esc","title":"<code>key_esc(self, wait=0)</code>","text":"<p>Press key Esc</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def key_esc(self, wait=0):\n\"\"\"\n    Press key Esc\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.ESCAPE)\n    action.key_up(Keys.ESCAPE)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.key_home","title":"<code>key_home(self, wait=0)</code>","text":"<p>Press key Home</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def key_home(self, wait=0):\n\"\"\"\n    Press key Home\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    # TODO: Investigate why with Firefox the key isn't working properly\n    action = ActionChains(self._driver)\n    action.key_down(Keys.HOME)\n    action.key_up(Keys.HOME)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.key_right","title":"<code>key_right(self, wait=0)</code>","text":"<p>Press key Right</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def key_right(self, wait=0):\n\"\"\"\n    Press key Right\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.ARROW_RIGHT)\n    action.key_up(Keys.ARROW_RIGHT)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.leave_iframe","title":"<code>leave_iframe(self)</code>","text":"<p>Leave the iframe and switch the WebBot driver to the default content.</p> Source code in <code>web/bot.py</code> <pre><code>def leave_iframe(self):\n\"\"\"Leave the iframe and switch the WebBot driver to the default content.\n    \"\"\"\n    self._driver.switch_to.default_content()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.maximize_window","title":"<code>maximize_window(self)</code>","text":"<p>Shortcut to maximize window on Windows OS.</p> Source code in <code>web/bot.py</code> <pre><code>def maximize_window(self):\n\"\"\"\n    Shortcut to maximize window on Windows OS.\n    \"\"\"\n    # TODO: Understand the complications associated with maximizing the browser and the resolution\n    self._driver.maximize_window()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.mouse_down","title":"<code>mouse_down(self, wait_after=300, *, button='left')</code>","text":"<p>Holds down the requested mouse button.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> <code>button</code> <code>str</code> <p>One of 'left', 'right', 'middle'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>web/bot.py</code> <pre><code>def mouse_down(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left'):\n\"\"\"\n    Holds down the requested mouse button.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n    \"\"\"\n    ActionChains(self._driver).click_and_hold().perform()\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.mouse_move","title":"<code>mouse_move(self, x, y)</code>","text":"<p>Mouse the move to the coordinate defined by x and y</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The X coordinate</p> required <code>y</code> <code>int</code> <p>The Y coordinate</p> required Source code in <code>web/bot.py</code> <pre><code>def mouse_move(self, x, y):\n\"\"\"\n    Mouse the move to the coordinate defined by x and y\n\n    Args:\n        x (int): The X coordinate\n        y (int): The Y coordinate\n\n    \"\"\"\n    if self.browser == Browser.FIREFOX:\n        # Reset coordinates if the page has gone stale. Only required for Firefox\n        if self._html_elem is None:\n            self._html_elem = self._driver.find_element(By.TAG_NAME, 'body')\n            self._x = 0\n            self._y = 0\n        else:\n            try:\n                self._html_elem.is_enabled()\n            except StaleElementReferenceException:\n                self._html_elem = self._driver.find_element(By.TAG_NAME, 'body')\n                self._x = 0\n                self._y = 0\n\n    mx = x - self._x\n    my = y - self._y\n    self._x = x\n    self._y = y\n    ActionChains(self._driver).move_by_offset(mx, my).perform()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.mouse_up","title":"<code>mouse_up(self, wait_after=300, *, button='left')</code>","text":"<p>Releases the requested mouse button.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> <code>button</code> <code>str</code> <p>One of 'left', 'right', 'middle'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>web/bot.py</code> <pre><code>def mouse_up(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left'):\n\"\"\"\n    Releases the requested mouse button.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n    \"\"\"\n    ActionChains(self._driver).release().perform()\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.move","title":"<code>move(self)</code>","text":"<p>Move to the center position of last found item.</p> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef move(self):\n\"\"\"\n    Move to the center position of last found item.\n    \"\"\"\n    x, y = self.state.center()\n    self.move_to(x, y)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.move_random","title":"<code>move_random(self, range_x, range_y)</code>","text":"<p>Move randomly along the given x, y range.</p> <p>Parameters:</p> Name Type Description Default <code>range_x</code> <code>int</code> <p>Horizontal range</p> required <code>range_y</code> <code>int</code> <p>Vertical range</p> required Source code in <code>web/bot.py</code> <pre><code>def move_random(self, range_x, range_y):\n\"\"\"\n    Move randomly along the given x, y range.\n\n    Args:\n        range_x (int): Horizontal range\n        range_y (int): Vertical range\n\n    \"\"\"\n    x = int(random.random() * range_x)\n    y = int(random.random() * range_y)\n    self.move_to(x, y)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.move_relative","title":"<code>move_relative(self, x, y)</code>","text":"<p>Move the mouse relative to its current position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required Source code in <code>web/bot.py</code> <pre><code>def move_relative(self, x, y):\n\"\"\"\n    Move the mouse relative to its current position.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n\n    \"\"\"\n    x = self.get_last_x() + x\n    y = self.get_last_y() + y\n    self.move_to(x, y)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.move_to","title":"<code>move_to(self, x, y)</code>","text":"<p>Move the mouse relative to its current position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The X coordinate</p> required <code>y</code> <code>int</code> <p>The Y coordinate</p> required Source code in <code>web/bot.py</code> <pre><code>def move_to(self, x, y):\n\"\"\"\n    Move the mouse relative to its current position.\n\n    Args:\n        x (int): The X coordinate\n        y (int): The Y coordinate\n    \"\"\"\n    self.mouse_move(x, y)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.navigate_to","title":"<code>navigate_to(self, url, is_retry=False)</code>","text":"<p>Opens the browser on the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to be visited.</p> required <code>is_retry</code> <code>bool</code> <p>Whether or not this is a retry attempt.</p> <code>False</code> Source code in <code>web/bot.py</code> <pre><code>def navigate_to(self, url, is_retry=False):\n\"\"\"\n    Opens the browser on the given URL.\n\n    Args:\n        url (str):  The URL to be visited.\n        is_retry (bool): Whether or not this is a retry attempt.\n    \"\"\"\n    self._x = 0\n    self._y = 0\n    if not self._driver:\n        self.start_browser()\n    try:\n        self._driver.get(url)\n    except InvalidSessionIdException:\n        if not is_retry:\n            self.stop_browser()\n            self.navigate_to(url, is_retry=True)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.page_down","title":"<code>page_down(self, wait=0)</code>","text":"<p>Press Page Down key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def page_down(self, wait=0):\n\"\"\"\n    Press Page Down key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    # TODO: Investigate why with Firefox the key isn't working properly\n    action = ActionChains(self._driver)\n    action.key_down(Keys.PAGE_DOWN)\n    action.key_up(Keys.PAGE_DOWN)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.page_source","title":"<code>page_source(self)</code>","text":"<p>Returns the active page source.</p> <p>Returns:</p> Type Description <code>soup (BeautifulSoup)</code> <p>BeautifulSoup object for the page source.</p> Source code in <code>web/bot.py</code> <pre><code>def page_source(self):\n\"\"\"\n    Returns the active page source.\n\n    Returns:\n        soup (BeautifulSoup): BeautifulSoup object for the page source.\n    \"\"\"\n    try:\n        soup = BeautifulSoup(self._driver.page_source, 'html.parser')\n        return soup\n    except InvalidSessionIdException:\n        return None\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.page_title","title":"<code>page_title(self)</code>","text":"<p>Returns the active page title.</p> <p>Returns:</p> Type Description <code>title (str)</code> <p>The page title.</p> Source code in <code>web/bot.py</code> <pre><code>def page_title(self):\n\"\"\"\n    Returns the active page title.\n\n    Returns:\n        title (str): The page title.\n    \"\"\"\n    try:\n        return self._driver.title\n    except InvalidSessionIdException:\n        return None\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.page_up","title":"<code>page_up(self, wait=0)</code>","text":"<p>Press Page Up key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def page_up(self, wait=0):\n\"\"\"\n    Press Page Up key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    # TODO: Investigate why with Firefox the key isn't working properly\n    action = ActionChains(self._driver)\n    action.key_down(Keys.PAGE_UP)\n    action.key_up(Keys.PAGE_UP)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.paste","title":"<code>paste(self, text=None, wait=0)</code>","text":"<p>Paste content from the clipboard.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to be pasted. Defaults to None</p> <code>None</code> <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def paste(self, text=None, wait=0):\n\"\"\"\n    Paste content from the clipboard.\n\n    Args:\n        text (str, optional): The text to be pasted. Defaults to None\n        wait (int, optional): Wait interval (ms) after task\n    \"\"\"\n    text_to_paste = self._clipboard\n    if text:\n        text_to_paste = text\n    self.kb_type(text_to_paste)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.print_pdf","title":"<code>print_pdf(self, path=None, print_options=None)</code>","text":"<p>Print the current page as a PDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path for the file to be saved. Defaults to None.</p> <code>None</code> <code>print_options</code> <code>dict</code> <p>Print options as defined at. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the saved file path</p> Source code in <code>web/bot.py</code> <pre><code>def print_pdf(self, path=None, print_options=None):\n\"\"\"Print the current page as a PDF file.\n\n    Args:\n        path (str, optional): The path for the file to be saved. Defaults to None.\n        print_options (dict, optional): Print options as defined at. Defaults to None.\n\n    Returns:\n        str: the saved file path\n    \"\"\"\n    title = self.page_title() or \"document\"\n    title = re.sub(\"[\\\\\\\\|/:\u2013]\", \"\", title)\n    timeout = 60000\n    default_path = os.path.expanduser(os.path.join(self.download_folder_path, f\"{title}.pdf\"))\n\n    if self.browser in [Browser.CHROME, Browser.EDGE] and not self.headless:\n        pdf_current_count = self.get_file_count(file_extension=\".pdf\")\n        # Chrome still does not support headless webdriver print\n        # but Firefox does.\n        self.execute_javascript(\"window.print();\")\n\n        # We need to wait for the file to be available in this case.\n        if self.page_title():\n            self.wait_for_file(default_path, timeout=timeout)\n        else:\n            # Waiting when the file don't have the page title in path\n            self.wait_for_new_file(file_extension=\".pdf\", current_count=pdf_current_count)\n\n        # Move the downloaded pdf file if the path is not None\n        if path:\n            last_downloaded_pdf = self.get_last_created_file(self.download_folder_path, \".pdf\")\n            os.rename(last_downloaded_pdf, path)\n            return path\n        self.wait(2000)\n        return default_path\n\n    if print_options is None:\n        print_options = {\n            'landscape': False,\n            'displayHeaderFooter': False,\n            'printBackground': True,\n            'preferCSSPageSize': True,\n            'marginTop': 0,\n            'marginBottom': 0\n        }\n    data = self._webdriver_command(\"print\", print_options)\n    bytes_file = base64.b64decode(data)\n    if not path:\n        path = default_path\n    with open(path, \"wb\") as f:\n        f.write(bytes_file)\n    return path\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.refresh","title":"<code>refresh(self)</code>","text":"<p>Refreshes the current page.</p> Source code in <code>web/bot.py</code> <pre><code>def refresh(self):\n\"\"\"\n    Refreshes the current page.\n    \"\"\"\n    self._driver.refresh()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.release_shift","title":"<code>release_shift(self)</code>","text":"<p>Release key Shift. This method needs to be invoked after holding Shift or similar.</p> Source code in <code>web/bot.py</code> <pre><code>def release_shift(self):\n\"\"\"\n    Release key Shift.\n    This method needs to be invoked after holding Shift or similar.\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_up(Keys.SHIFT)\n    action.perform()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.right_click","title":"<code>right_click(self, wait_after=300, *, clicks=1, interval_between_clicks=0)</code>","text":"<p>Right click on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> <code>clicks</code> <code>int</code> <p>Number of times to click. Defaults to 1.</p> <code>1</code> <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef right_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n                clicks=1, interval_between_clicks=0):\n\"\"\"\n    Right click on the last found element.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        clicks (int, optional): Number of times to click. Defaults to 1.\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n    \"\"\"\n    self.click(clicks=clicks, button='right', interval_between_clicks=interval_between_clicks)\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.right_click_at","title":"<code>right_click_at(self, x, y)</code>","text":"<p>Right click at the coordinate defined by x and y</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The X coordinate</p> required <code>y</code> <code>int</code> <p>The Y coordinate</p> required Source code in <code>web/bot.py</code> <pre><code>def right_click_at(self, x, y):\n\"\"\"\n    Right click at the coordinate defined by x and y\n\n    Args:\n        x (int): The X coordinate\n        y (int): The Y coordinate\n    \"\"\"\n    self.click_at(x, y, button='right')\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.right_click_relative","title":"<code>right_click_relative(self, x, y, interval_between_clicks=0, wait_after=300)</code>","text":"<p>Right Click Relative on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef right_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Right Click Relative on the last found element.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        wait_after (int, optional): Interval to wait after clicking on the element.\n\n    \"\"\"\n    self.click_relative(x, y, wait_after=wait_after, interval_between_clicks=interval_between_clicks,\n                        button='right')\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.save_screenshot","title":"<code>save_screenshot(self, path)</code>","text":"<p>Saves a screenshot in a given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The filepath in which to save the screenshot</p> required Source code in <code>web/bot.py</code> <pre><code>def save_screenshot(self, path):\n\"\"\"\n    Saves a screenshot in a given path.\n\n    Args:\n        path (str): The filepath in which to save the screenshot\n\n    \"\"\"\n    self.screenshot(path)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.screen_cut","title":"<code>screen_cut(self, x, y, width=None, height=None)</code>","text":"<p>Capture a screenshot from a region of the screen.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>region start position x</p> required <code>y</code> <code>int</code> <p>region start position y</p> required <code>width</code> <code>int</code> <p>region width</p> <code>None</code> <code>height</code> <code>int</code> <p>region height</p> <code>None</code> <p>Returns:</p> Type Description <code>Image</code> <p>The screenshot Image object</p> Source code in <code>web/bot.py</code> <pre><code>def screen_cut(self, x, y, width=None, height=None):\n\"\"\"\n    Capture a screenshot from a region of the screen.\n\n    Args:\n        x (int): region start position x\n        y (int): region start position y\n        width (int): region width\n        height (int): region height\n\n    Returns:\n        Image: The screenshot Image object\n    \"\"\"\n    screen_size = self._get_page_size()\n    x = x or 0\n    y = y or 0\n    width = width or screen_size[0]\n    height = height or screen_size[1]\n    img = self.screenshot(region=(x, y, width, height))\n    return img\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.screenshot","title":"<code>screenshot(self, filepath=None, region=None)</code>","text":"<p>Capture a screenshot.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath in which to save the screenshot. Defaults to None.</p> <code>None</code> <code>region</code> <code>tuple</code> <p>Bounding box containing left, top, width and height to crop screenshot.</p> <code>None</code> <p>Returns:</p> Type Description <code>Image</code> <p>The screenshot Image object</p> Source code in <code>web/bot.py</code> <pre><code>def screenshot(self, filepath=None, region=None):\n\"\"\"\n    Capture a screenshot.\n\n    Args:\n        filepath (str, optional): The filepath in which to save the screenshot. Defaults to None.\n        region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot.\n\n    Returns:\n        Image: The screenshot Image object\n    \"\"\"\n    img = self.get_screen_image(region)\n    if filepath:\n        img.save(filepath)\n    return img\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.scroll_down","title":"<code>scroll_down(self, clicks)</code>","text":"<p>Scroll Down n clicks</p> <p>Parameters:</p> Name Type Description Default <code>clicks</code> <code>int</code> <p>Number of times to scroll down.</p> required Source code in <code>web/bot.py</code> <pre><code>def scroll_down(self, clicks):\n\"\"\"\n    Scroll Down n clicks\n\n    Args:\n        clicks (int): Number of times to scroll down.\n    \"\"\"\n    for i in range(clicks):\n        self._driver.execute_script(\"window.scrollTo(0, window.scrollY + 200)\")\n        self.sleep(200)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.scroll_element","title":"<code>scroll_element(self, element, steps=100, interval=500, start=0, end=None)</code>","text":"<p>Scrolls down an element by its scroll height or a given amount defined by <code>start</code> and <code>end</code>.</p> <p>This is useful for scrolling down a page to load more content or to scroll down a dynamically loaded element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The element to scroll.</p> required <code>steps</code> <code>int</code> <p>Number of steps in which to conclude the scroll. Defaults to 100.</p> <code>100</code> <code>interval</code> <code>float</code> <p>Time interval between each step. Defaults to 500ms.</p> <code>500</code> <code>start</code> <code>int</code> <p>Start position. Defaults to 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>End position. Defaults to None.</p> <code>None</code> Source code in <code>web/bot.py</code> <pre><code>def scroll_element(self, element: WebElement, steps: int = 100, interval: float = 500,\n                   start: int = 0, end: int = None):\n\"\"\"Scrolls down an element by its scroll height or a given amount defined by `start` and `end`.\n\n    This is useful for scrolling down a page to load more content or\n    to scroll down a dynamically loaded element.\n\n    Args:\n        element (WebElement): The element to scroll.\n        steps (int, optional): Number of steps in which to conclude the scroll. Defaults to 100.\n        interval (float, optional): Time interval between each step. Defaults to 500ms.\n        start (int, optional): Start position. Defaults to 0.\n        end (int, optional): End position. Defaults to None.\n    \"\"\"\n    ele_height = self.driver.execute_script(\n        \"return arguments[0].scrollHeight;\", element\n    )\n\n    start = max(0, start)\n    end = min(ele_height, end) if end is not None else ele_height\n\n    for i in range(start, end, steps):\n        self.driver.execute_script(\n            \"arguments[0].scrollTo(0, arguments[1])\", element, i)\n        self.sleep(interval/1000.0)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.scroll_up","title":"<code>scroll_up(self, clicks)</code>","text":"<p>Scroll Up n clicks</p> <p>Parameters:</p> Name Type Description Default <code>clicks</code> <code>int</code> <p>Number of times to scroll up.</p> required Source code in <code>web/bot.py</code> <pre><code>def scroll_up(self, clicks):\n\"\"\"\n    Scroll Up n clicks\n\n    Args:\n        clicks (int): Number of times to scroll up.\n    \"\"\"\n    for i in range(clicks):\n        self._driver.execute_script(\"window.scrollTo(0, window.scrollY - 200)\")\n        self.sleep(200)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.set_current_element","title":"<code>set_current_element(self, element)</code>","text":"<p>Changes the current screen element the bot will interact when using click(), move(), and similar methods.</p> <p>This method is equivalent to self.state.element = element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Box</code> <p>A screen element from self.state.element or the find_all(as_list=True) method.</p> required Source code in <code>web/bot.py</code> <pre><code>def set_current_element(self, element: cv2find.Box):\n\"\"\"\n    Changes the current screen element the bot will interact when using click(), move(), and similar methods.\n\n    This method is equivalent to self.state.element = element.\n\n    Args:\n        element (Box): A screen element from self.state.element or the find_all(as_list=True) method.\n    \"\"\"\n    self.state.element = element\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.set_file_input_element","title":"<code>set_file_input_element(self, element, filepath)</code>","text":"<p>Configure the filepath for upload in a file element. Note: This method does not submit the form.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The file upload element.</p> required <code>filepath</code> <code>str</code> <p>The path to the file to be uploaded.</p> required <p>Example: <pre><code>...\n# Find element\nelem = self.find_element(\"body &gt; form &gt; input[type=file]\")\n# Set the filepath\nself.set_file_input_element(elem, \"./test.txt\")\n...\n</code></pre></p> Source code in <code>web/bot.py</code> <pre><code>def set_file_input_element(self, element: WebElement, filepath: str):\n\"\"\"Configure the filepath for upload in a file element.\n    Note: This method does not submit the form.\n\n    Args:\n        element (WebElement): The file upload element.\n        filepath (str): The path to the file to be uploaded.\n\n    **Example:**\n    ```python\n    ...\n    # Find element\n    elem = self.find_element(\"body &gt; form &gt; input[type=file]\")\n    # Set the filepath\n    self.set_file_input_element(elem, \"./test.txt\")\n    ...\n    ```\n    \"\"\"\n    fpath = os.path.abspath(os.path.expanduser(os.path.expandvars(filepath)))\n    element.send_keys(fpath)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.set_screen_resolution","title":"<code>set_screen_resolution(self, width=None, height=None)</code>","text":"<p>Configures the browser dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The desired width.</p> <code>None</code> <code>height</code> <code>int</code> <p>The desired height.</p> <code>None</code> Source code in <code>web/bot.py</code> <pre><code>def set_screen_resolution(self, width=None, height=None):\n\"\"\"\n    Configures the browser dimensions.\n\n    Args:\n        width (int): The desired width.\n        height (int): The desired height.\n    \"\"\"\n    dimensions = (width or self.DEFAULT_DIMENSIONS[0], height or self.DEFAULT_DIMENSIONS[1])\n\n    if self.headless:\n        # When running headless the window size is the viewport size\n        window_size = dimensions\n    else:\n        # When running non-headless we need to account for the borders and etc\n        # So the size must be bigger to have the same viewport size as before\n        window_size = self._driver.execute_script(\"\"\"\n            return [window.outerWidth - window.innerWidth + arguments[0],\n              window.outerHeight - window.innerHeight + arguments[1]];\n            \"\"\", *dimensions)\n    self._driver.set_window_size(*window_size)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.sleep","title":"<code>sleep(self, interval)</code>","text":"<p>Wait / Sleep for a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>Interval in milliseconds</p> required Source code in <code>web/bot.py</code> <pre><code>def sleep(self, interval):\n\"\"\"\n    Wait / Sleep for a given interval.\n\n    Args:\n        interval (int): Interval in milliseconds\n\n    \"\"\"\n    self.wait(interval)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.space","title":"<code>space(self, wait=0)</code>","text":"<p>Press Space key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def space(self, wait=0):\n\"\"\"\n    Press Space key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.SPACE)\n    action.key_up(Keys.SPACE)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.start_browser","title":"<code>start_browser(self)</code>","text":"<p>Starts the selected browser.</p> Source code in <code>web/bot.py</code> <pre><code>def start_browser(self):\n\"\"\"\n    Starts the selected browser.\n    \"\"\"\n    def check_driver():\n        # Look for driver\n        driver_name = BROWSER_CONFIGS.get(self.browser).get(\"driver\")\n        location = shutil.which(driver_name)\n        if not location:\n            raise RuntimeError(\n                f\"{driver_name} was not found. Please make sure to have it on your PATH or set driver_path\")\n        return location\n\n    # Specific webdriver class for a given browser\n    driver_class = BROWSER_CONFIGS.get(self.browser).get(\"class\")\n    # Specific default options method for a given browser\n    func_def_options = BROWSER_CONFIGS.get(self.browser).get(\"options\")\n    # Specific capabilities method for a given browser\n    func_def_capabilities = BROWSER_CONFIGS.get(self.browser).get(\"capabilities\")\n\n    opt = self.options or func_def_options(\n        self.headless, self._download_folder_path, None, self.page_load_strategy\n    )\n    cap = self.capabilities or func_def_capabilities()\n    self.options = opt\n    self.capabilities = cap\n    driver_path = self.driver_path or check_driver()\n    self.driver_path = driver_path\n    if compat.version_selenium_is_larger_than_four():\n        service = BROWSER_CONFIGS.get(self.browser).get(\"service\")\n        service = service(executable_path=self.driver_path)\n        service.desired_capabilities = cap\n\n        self._driver = driver_class(options=opt, service=service)\n    else:\n        self._driver = driver_class(options=opt, desired_capabilities=cap, executable_path=driver_path)\n    self.set_screen_resolution()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.stop_browser","title":"<code>stop_browser(self)</code>","text":"<p>Stops the Chrome browser and clean up the User Data Directory.</p> <p>Warning</p> <p>After invoking this method, you will need to reassign your custom options and capabilities.</p> Source code in <code>web/bot.py</code> <pre><code>def stop_browser(self):\n\"\"\"\n    Stops the Chrome browser and clean up the User Data Directory.\n\n    Warning:\n        After invoking this method, you will need to reassign your custom options and capabilities.\n    \"\"\"\n    if not self._driver:\n        return\n    self._driver.close()\n    self._driver.quit()\n    self.options = None\n    self.capabilities = None\n    self._driver = None\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.tab","title":"<code>tab(self, wait=0)</code>","text":"<p>Press key Tab</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def tab(self, wait=0):\n\"\"\"\n    Press key Tab\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.TAB)\n    action.key_up(Keys.TAB)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.triple_click","title":"<code>triple_click(self, wait_after=300)</code>","text":"<p>Triple Click on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef triple_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Triple Click on the last found element.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n    \"\"\"\n    self.click(wait_after=wait_after, clicks=3)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.triple_click_relative","title":"<code>triple_click_relative(self, x, y, interval_between_clicks=0, wait_after=300)</code>","text":"<p>Triple Click Relative on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>300</code> Source code in <code>web/bot.py</code> <pre><code>@only_if_element\ndef triple_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Triple Click Relative on the last found element.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        wait_after (int, optional): Interval to wait after clicking on the element.\n    \"\"\"\n    self.click_relative(x, y, wait_after=wait_after, clicks=3, interval_between_clicks=interval_between_clicks)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.type_down","title":"<code>type_down(self, wait=0)</code>","text":"<p>Press Down key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def type_down(self, wait=0):\n\"\"\"\n    Press Down key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.ARROW_DOWN)\n    action.key_up(Keys.ARROW_DOWN)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.type_keys","title":"<code>type_keys(self, keys)</code>","text":"<p>Press a sequence of keys. Hold the keys in the specific order and releases them.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list</code> <p>List of keys to be pressed</p> required Source code in <code>web/bot.py</code> <pre><code>def type_keys(self, keys):\n\"\"\"\n    Press a sequence of keys. Hold the keys in the specific order and releases them.\n\n    Args:\n        keys (list): List of keys to be pressed\n    \"\"\"\n    self.type_keys_with_interval(100, keys)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.type_keys_with_interval","title":"<code>type_keys_with_interval(self, interval, keys)</code>","text":"<p>Press a sequence of keys. Hold the keys in the specific order and releases them.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>Interval (ms) in which to press and release keys</p> required <code>keys</code> <code>list</code> <p>List of Keys to be pressed</p> required Source code in <code>web/bot.py</code> <pre><code>def type_keys_with_interval(self, interval, keys):\n\"\"\"\n    Press a sequence of keys. Hold the keys in the specific order and releases them.\n\n    Args:\n        interval (int): Interval (ms) in which to press and release keys\n        keys (list): List of Keys to be pressed\n    \"\"\"\n    action = ActionChains(self._driver)\n\n    for k in keys:\n        action.key_down(k)\n        action.pause(interval / 1000.0)\n    for k in reversed(keys):\n        action.key_up(k)\n        action.pause(interval / 1000.0)\n    action.perform()\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.type_left","title":"<code>type_left(self, wait=0)</code>","text":"<p>Press Left key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def type_left(self, wait=0):\n\"\"\"\n    Press Left key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.ARROW_LEFT)\n    action.key_up(Keys.ARROW_LEFT)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.type_right","title":"<code>type_right(self, wait=0)</code>","text":"<p>Press Right key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def type_right(self, wait=0):\n\"\"\"\n    Press Right key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.key_right(wait=wait)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.type_up","title":"<code>type_up(self, wait=0)</code>","text":"<p>Press Up key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>web/bot.py</code> <pre><code>def type_up(self, wait=0):\n\"\"\"\n    Press Up key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    action = ActionChains(self._driver)\n    action.key_down(Keys.ARROW_UP)\n    action.key_up(Keys.ARROW_UP)\n    action.perform()\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.wait","title":"<code>wait(self, interval)</code>","text":"<p>Wait / Sleep for a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>Interval in milliseconds</p> required Source code in <code>web/bot.py</code> <pre><code>def wait(self, interval):\n\"\"\"\n    Wait / Sleep for a given interval.\n\n    Args:\n        interval (int): Interval in milliseconds\n\n    \"\"\"\n    time.sleep(interval / 1000.0)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.wait_for_downloads","title":"<code>wait_for_downloads(self, timeout=120000)</code>","text":"<p>Wait for all downloads to be finished. Beware that this method replaces the current page with the downloads window.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout in millis. Defaults to 120000.</p> <code>120000</code> Source code in <code>web/bot.py</code> <pre><code>def wait_for_downloads(self, timeout: int = 120000):\n\"\"\"\n    Wait for all downloads to be finished.\n    Beware that this method replaces the current page with the downloads window.\n\n    Args:\n        timeout (int, optional): Timeout in millis. Defaults to 120000.\n    \"\"\"\n    if self.browser in [Browser.CHROME, Browser.EDGE] and self.headless:\n        start_time = time.time()\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; timeout:\n                return False\n            downloads_count = self.get_file_count(self.download_folder_path, \".crdownload\")\n            if downloads_count == 0:\n                return True\n            self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    wait_method = BROWSER_CONFIGS.get(self.browser).get(\"wait_for_downloads\")\n    # waits for all the files to be completed\n    WebDriverWait(self._driver, timeout/1000.0, 1).until(wait_method)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.wait_for_element_visibility","title":"<code>wait_for_element_visibility(self, element, visible=True, waiting_time=10000)</code>","text":"<p>Wait for the element to be visible or hidden.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The element to wait for.</p> required <code>visible</code> <code>bool</code> <p>Whether to wait for the element to be visible. Defaults to True.</p> <code>True</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> Source code in <code>web/bot.py</code> <pre><code>def wait_for_element_visibility(self, element: WebElement, visible: bool = True, waiting_time=10000):\n\"\"\"Wait for the element to be visible or hidden.\n\n    Args:\n        element (WebElement): The element to wait for.\n        visible (bool, optional): Whether to wait for the element to be visible. Defaults to True.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n    \"\"\"\n    if visible:\n        wait_method = EC.visibility_of\n    else:\n        wait_method = EC.invisibility_of_element\n\n    WebDriverWait(self._driver, timeout=waiting_time/1000.0).until(wait_method(element))\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.wait_for_file","title":"<code>wait_for_file(self, path, timeout=60000)</code>","text":"<p>Wait for a file to be available on disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path for the file to be executed</p> required <code>timeout</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 60000ms (60s).</p> <code>60000</code> <p>Returns:</p> Type Description <code>status (bool)</code> <p>Whether or not the file was available before the timeout</p> Source code in <code>web/bot.py</code> <pre><code>def wait_for_file(self, path, timeout=60000):\n\"\"\"\n    Wait for a file to be available on disk.\n\n    Args:\n        path (str): The path for the file to be executed\n        timeout (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 60000ms (60s).\n\n    Returns:\n        status (bool): Whether or not the file was available before the timeout\n\n    \"\"\"\n    path = os.path.abspath(os.path.expanduser(os.path.expandvars(path)))\n    start_time = time.time()\n\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; timeout:\n            return False\n        if os.path.isfile(path) and os.access(path, os.R_OK):\n            if self.browser == Browser.FIREFOX and os.path.getsize(path) == 0:\n                # if file is empty, the download is not completed.\n                continue\n            self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n            return True\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.wait_for_new_file","title":"<code>wait_for_new_file(self, path=None, file_extension='', current_count=0, timeout=60000)</code>","text":"<p>Wait for a new file to be available on disk without the file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the folder where the file is expected. Defaults to None.</p> <code>None</code> <code>file_extension</code> <code>str</code> <p>The extension of the file to be searched for (e.g., .pdf, .txt).</p> <code>''</code> <code>current_count</code> <code>int</code> <p>The current number of files in the folder of the given type. Defaults to 0 files</p> <code>0</code> <code>timeout</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 60000ms (60s).</p> <code>60000</code> <p>Returns:</p> Type Description <code>str</code> <p>the path of the last created file of the given type</p> Source code in <code>web/bot.py</code> <pre><code>def wait_for_new_file(self, path=None, file_extension=\"\", current_count=0, timeout=60000):\n\"\"\"\n    Wait for a new file to be available on disk without the file path.\n\n    Args:\n        path (str, optional): The path of the folder where the file is expected. Defaults to None.\n        file_extension (str, optional): The extension of the file to be searched for (e.g., .pdf, .txt).\n        current_count (int): The current number of files in the folder of the given type. Defaults to 0 files\n        timeout (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 60000ms (60s).\n\n    Returns:\n        str: the path of the last created file of the given type\n    \"\"\"\n    if not path:\n        path = self.download_folder_path\n\n    start_time = time.time()\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; timeout:\n            return None\n        file_count = self.get_file_count(path, f\"*{file_extension}\")\n        if file_count == current_count + 1:\n            self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n            return self.get_last_created_file(path, f\"*{file_extension}\")\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.wait_for_new_page","title":"<code>wait_for_new_page(self, waiting_time=10000, activate=True)</code>","text":"<p>Context manager to wait for a new page to load and activate it.</p> <p>Parameters:</p> Name Type Description Default <code>waiting_time</code> <code>int</code> <p>The maximum waiting time. Defaults to 10000.</p> <code>10000</code> <code>activate</code> <code>bool</code> <p>Whether or not to activate the new page. Defaults to True.</p> <code>True</code> Source code in <code>web/bot.py</code> <pre><code>@contextmanager\ndef wait_for_new_page(self, waiting_time=10000, activate=True):\n\"\"\"Context manager to wait for a new page to load and activate it.\n\n    Args:\n        waiting_time (int, optional): The maximum waiting time. Defaults to 10000.\n        activate (bool, optional): Whether or not to activate the new page. Defaults to True.\n\n    \"\"\"\n    tabs = self.get_tabs()\n    yield\n    start_time = time.time()\n    while tabs == self.get_tabs():\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; waiting_time:\n            return None\n        time.sleep(0.1)\n    if activate:\n        self.activate_tab(self.get_tabs()[-1])\n</code></pre>"},{"location":"bot/#botcity.web.bot.WebBot.wait_for_stale_element","title":"<code>wait_for_stale_element(self, element, timeout=10000)</code>","text":"<p>Wait until the WebElement element becomes stale (outdated).</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The element to monitor for staleness.</p> required <code>timeout</code> <code>int</code> <p>Timeout in millis. Defaults to 120000.</p> <code>10000</code> Source code in <code>web/bot.py</code> <pre><code>def wait_for_stale_element(self, element: WebElement, timeout: int = 10000):\n\"\"\"\n    Wait until the WebElement element becomes stale (outdated).\n\n    Args:\n        element (WebElement): The element to monitor for staleness.\n        timeout (int, optional): Timeout in millis. Defaults to 120000.\n    \"\"\"\n    try:\n        WebDriverWait(self._driver, timeout=timeout/1000.0).until(EC.staleness_of(element))\n    except (TimeoutException, NoSuchElementException):\n        pass\n</code></pre>"},{"location":"browsers/","title":"Browsers","text":"<p>Every supported browser has a default set of options and capabilities curated for you that are used by default.</p> <p>In case you need to customize the options or capabilities you can do so via the <code>default_options</code> and <code>default_capabilities</code> methods available within each browser module.</p> <p>Here is an example on how to do that:</p> <pre><code>from botcity.web import WebBot, Browser\n\n# Page Load Strategy\nfrom botcity.web import PageLoadStrategy\n\n# For Chrome\nfrom botcity.web.browsers.chrome import default_options, default_capabilities\n# For Firefox\n#from botcity.web.browsers.firefox import default_options, default_capabilities\n# For Edge\n#from botcity.web.browsers.edge import default_options, default_capabilities\n# For IE\n#from botcity.web.browsers.ie import default_options, default_capabilities\n\n\nclass Bot(WebBot):\n    def action(self, execution=None):\n        # Configure whether or not to run on headless mode\n        self.headless = False\n\n        self.page_load_strategy = PageLoadStrategy.NORMAL\n\n        # Fetch the default options for my preferred browser\n        # Pass in the headless, download_folder_path and user_data_dir\n        # to be used when building the default_options\n        def_options = default_options(\n            headless=self.headless,\n            download_folder_path=self.download_folder_path,\n            user_data_dir=None,  # Informing None here will generate a temporary directory\n            page_load_strategy=self.page_load_strategy\n        )\n\n        # Add your customized argument\n        def_options.add_argument(\"&lt;My Special Argument&gt;\")\n\n        # Update the options to use the customized Options.\n        self.options = def_options\n\n        # Fetch the default options for my preferred browser\n        def_capabilities = default_capabilities()\n\n        # Set of modify the key and value for my desired capability\n        def_capabilities[\"&lt;My Special Parameter&gt;\"] = \"special value\"\n\n        # Update the capabilities to use the customized configurations.\n        self.capabilities = def_capabilities\n\n        ...\n</code></pre>"},{"location":"browsers/#page-load-strategy","title":"Page Load Strategy","text":"<p>Page Load Strategy is a browser option that determines how the browser will load the page.</p>"},{"location":"browsers/#botcity.web.browsers.PageLoadStrategy","title":"<code> botcity.web.browsers.PageLoadStrategy            (str, Enum)         </code>","text":"<p>Page Load Strategy.</p> <p>Attributes:</p> Name Type Description <code>NORMAL</code> <code>str</code> <p>Wait for the entire page is loaded. When set to normal, waits until the load event fire is returned.</p> <code>EAGER</code> <code>str</code> <p>Wait until the initial HTML document has been completely loaded and parsed, and discards loading of stylesheets, images and subframes.</p> <code>NONE</code> <code>str</code> <p>Only waits until the initial page is downloaded</p> Source code in <code>web/browsers/__init__.py</code> <pre><code>class PageLoadStrategy(str, enum.Enum):\n\"\"\"\n    Page Load Strategy.\n\n    Attributes:\n        NORMAL (str): Wait for the entire page is loaded. When set to normal,\n            waits until the load event fire is returned.\n        EAGER (str): Wait until the initial HTML document has been completely\n            loaded and parsed, and discards loading of stylesheets, images and subframes.\n        NONE (str): Only waits until the initial page is downloaded\n    \"\"\"\n    NORMAL = \"normal\"\n    EAGER = \"eager\"\n    NONE = \"none\"\n</code></pre>"},{"location":"browsers/#specific-browser-modules","title":"Specific Browser Modules","text":"<p>Here are the documentation for the methods mentioned above for each of the supported browsers.</p>"},{"location":"browsers/#chrome","title":"Chrome","text":""},{"location":"browsers/#botcity.web.browsers.chrome.default_options","title":"<code>botcity.web.browsers.chrome.default_options(headless=False, download_folder_path=None, user_data_dir=None, page_load_strategy='normal')</code>","text":"<p>Retrieve the default options for this browser curated by BotCity.</p> <p>Parameters:</p> Name Type Description Default <code>headless</code> <code>bool</code> <p>Whether or not to use the headless mode. Defaults to False.</p> <code>False</code> <code>download_folder_path</code> <code>str</code> <p>The default path in which to save files. If None, the current directory is used. Defaults to None.</p> <code>None</code> <code>user_data_dir</code> <code>[type]</code> <p>The directory to use as user profile. If None, a new temporary directory is used. Defaults to None.</p> <code>None</code> <code>page_load_strategy</code> <code>str</code> <p>The page load strategy. Defaults to \"normal\".</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>ChromeOptions</code> <p>The Chrome options.</p> Source code in <code>web/browsers/chrome.py</code> <pre><code>def default_options(headless=False, download_folder_path=None, user_data_dir=None,\n                    page_load_strategy=\"normal\") -&gt; ChromeOptions:\n\"\"\"Retrieve the default options for this browser curated by BotCity.\n\n    Args:\n        headless (bool, optional): Whether or not to use the headless mode. Defaults to False.\n        download_folder_path (str, optional): The default path in which to save files.\n            If None, the current directory is used. Defaults to None.\n        user_data_dir ([type], optional): The directory to use as user profile.\n            If None, a new temporary directory is used. Defaults to None.\n        page_load_strategy (str, optional): The page load strategy. Defaults to \"normal\".\n\n    Returns:\n        ChromeOptions: The Chrome options.\n    \"\"\"\n    chrome_options = ChromeOptions()\n    try:\n        page_load_strategy = page_load_strategy.value\n    except AttributeError:\n        page_load_strategy = page_load_strategy\n    chrome_options.page_load_strategy = page_load_strategy\n    chrome_options.add_argument(\"--remote-debugging-port=0\")\n    chrome_options.add_argument(\"--no-first-run\")\n    chrome_options.add_argument(\"--no-default-browser-check\")\n    chrome_options.add_argument(\"--disable-background-networking\")\n    chrome_options.add_argument(\"--disable-background-timer-throttling\")\n    chrome_options.add_argument(\"--disable-client-side-phishing-detection\")\n    chrome_options.add_argument(\"--disable-default-apps\")\n    chrome_options.add_argument(\"--disable-hang-monitor\")\n    chrome_options.add_argument(\"--disable-popup-blocking\")\n    chrome_options.add_argument(\"--disable-prompt-on-repost\")\n    chrome_options.add_argument(\"--disable-syncdisable-translate\")\n    chrome_options.add_argument(\"--metrics-recording-only\")\n    chrome_options.add_argument(\"--safebrowsing-disable-auto-update\")\n\n    # Disable What's New banner for new chrome installs\n    chrome_options.add_argument(\"--disable-features=ChromeWhatsNewUI\")\n\n    chrome_options.add_argument(\"--disable-blink-features=AutomationControlled\")\n\n    # Disable banner for Browser being remote-controlled\n    chrome_options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"])\n    chrome_options.add_experimental_option('useAutomationExtension', False)\n\n    if headless:\n        chrome_options.add_argument(\"--headless\")\n        chrome_options.add_argument(\"--disable-gpu\")\n        chrome_options.add_argument(\"--hide-scrollbars\")\n        chrome_options.add_argument(\"--mute-audio\")\n\n    # Check if user is root\n    try:\n        # This is only valid with Unix\n        if os.geteuid() == 0:\n            chrome_options.add_argument(\"--no-sandbox\")\n    except AttributeError:\n        pass\n\n    if not user_data_dir:\n        temp_dir = tempfile.TemporaryDirectory(prefix=\"botcity_\")\n        user_data_dir = temp_dir.name\n        atexit.register(cleanup_temp_dir, temp_dir)\n\n    chrome_options.add_argument(f\"--user-data-dir={user_data_dir}\")\n\n    if not download_folder_path:\n        download_folder_path = os.getcwd()\n\n    app_state = {\n        'recentDestinations': [{\n            'id': 'Save as PDF',\n            'origin': 'local',\n            'account': ''\n        }],\n        'selectedDestinationId': 'Save as PDF',\n        'version': 2\n    }\n\n    # Set the Downloads default folder\n    prefs = {\n        \"printing.print_preview_sticky_settings.appState\": json.dumps(app_state),\n        \"download.default_directory\": download_folder_path,\n        \"savefile.default_directory\": download_folder_path,\n        \"printing.default_destination_selection_rules\": {\n            \"kind\": \"local\",\n            \"namePattern\": \"Save as PDF\",\n        },\n        \"safebrowsing.enabled\": True,\n        \"credentials_enable_service\": False,\n        \"profile.password_manager_enabled\": False,\n        \"plugins.always_open_pdf_externally\": True\n    }\n\n    chrome_options.add_experimental_option(\"prefs\", prefs)\n    chrome_options.add_argument(\n        \"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n        \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\"\n    )\n\n    chrome_options.add_argument(\"--kiosk-printing\")\n\n    return chrome_options\n</code></pre>"},{"location":"browsers/#botcity.web.browsers.chrome.default_capabilities","title":"<code>botcity.web.browsers.chrome.default_capabilities()</code>","text":"<p>Fetch the default capabilities for this browser.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with the default capabilities defined.</p> Source code in <code>web/browsers/chrome.py</code> <pre><code>def default_capabilities() -&gt; Dict:\n\"\"\"Fetch the default capabilities for this browser.\n\n    Returns:\n        Dict: Dictionary with the default capabilities defined.\n    \"\"\"\n    return DesiredCapabilities.CHROME.copy()\n</code></pre>"},{"location":"browsers/#firefox","title":"Firefox","text":""},{"location":"browsers/#botcity.web.browsers.firefox.default_options","title":"<code>botcity.web.browsers.firefox.default_options(headless=False, download_folder_path=None, user_data_dir=None, page_load_strategy='normal')</code>","text":"<p>Retrieve the default options for this browser curated by BotCity.</p> <p>Parameters:</p> Name Type Description Default <code>headless</code> <code>bool</code> <p>Whether or not to use the headless mode. Defaults to False.</p> <code>False</code> <code>download_folder_path</code> <code>str</code> <p>The default path in which to save files. If None, the current directory is used. Defaults to None.</p> <code>None</code> <code>user_data_dir</code> <code>[type]</code> <p>The directory to use as user profile. If None, a new temporary directory is used. Defaults to None.</p> <code>None</code> <code>page_load_strategy</code> <code>str</code> <p>The page load strategy to use.</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>FirefoxOptions</code> <p>The Firefox options.</p> Source code in <code>web/browsers/firefox.py</code> <pre><code>def default_options(headless=False, download_folder_path=None, user_data_dir=None,\n                    page_load_strategy=\"normal\") -&gt; FirefoxOptions:\n\"\"\"Retrieve the default options for this browser curated by BotCity.\n\n    Args:\n        headless (bool, optional): Whether or not to use the headless mode. Defaults to False.\n        download_folder_path (str, optional): The default path in which to save files.\n            If None, the current directory is used. Defaults to None.\n        user_data_dir ([type], optional): The directory to use as user profile.\n            If None, a new temporary directory is used. Defaults to None.\n        page_load_strategy (str, optional): The page load strategy to use.\n\n    Returns:\n        FirefoxOptions: The Firefox options.\n    \"\"\"\n    firefox_options = FirefoxOptions()\n    try:\n        page_load_strategy = page_load_strategy.value\n    except AttributeError:\n        page_load_strategy = page_load_strategy\n    firefox_options.page_load_strategy = page_load_strategy\n    firefox_options.headless = headless\n    if not user_data_dir:\n        temp_dir = tempfile.TemporaryDirectory(prefix=\"botcity_\")\n        user_data_dir = temp_dir.name\n        atexit.register(cleanup_temp_dir, temp_dir)\n    firefox_options.set_preference(\"profile\", user_data_dir)\n    firefox_options.set_preference(\"security.default_personal_cert\", \"Select Automatically\")\n    firefox_options.set_preference('browser.download.folderList', 2)\n    firefox_options.set_preference('browser.download.manager.showWhenStarting', False)\n    if not download_folder_path:\n        download_folder_path = os.getcwd()\n    firefox_options.set_preference('browser.download.dir', download_folder_path)\n    firefox_options.set_preference('general.warnOnAboutConfig', False)\n\n    mimetypes_to_download = \",\".join(FIREFOX_MIMETYPES_TO_DOWNLOAD)\n    firefox_options.set_preference(\"pdfjs.disabled\", True)\n    firefox_options.set_preference(\"plugin.disable_full_page_plugin_for_types\", mimetypes_to_download)\n    firefox_options.set_preference('browser.helperApps.neverAsk.saveToDisk', mimetypes_to_download)\n    return firefox_options\n</code></pre>"},{"location":"browsers/#botcity.web.browsers.firefox.default_capabilities","title":"<code>botcity.web.browsers.firefox.default_capabilities()</code>","text":"<p>Fetch the default capabilities for this browser.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with the default capabilities defined.</p> Source code in <code>web/browsers/firefox.py</code> <pre><code>def default_capabilities() -&gt; Dict:\n\"\"\"Fetch the default capabilities for this browser.\n\n    Returns:\n        Dict: Dictionary with the default capabilities defined.\n    \"\"\"\n    return DesiredCapabilities.FIREFOX.copy()\n</code></pre>"},{"location":"browsers/#edge","title":"Edge","text":""},{"location":"browsers/#botcity.web.browsers.edge.default_options","title":"<code>botcity.web.browsers.edge.default_options(headless=False, download_folder_path=None, user_data_dir=None, page_load_strategy='normal')</code>","text":"<p>Retrieve the default options for this browser curated by BotCity.</p> <p>Parameters:</p> Name Type Description Default <code>headless</code> <code>bool</code> <p>Whether or not to use the headless mode. Defaults to False.</p> <code>False</code> <code>download_folder_path</code> <code>str</code> <p>The default path in which to save files. If None, the current directory is used. Defaults to None.</p> <code>None</code> <code>user_data_dir</code> <code>[type]</code> <p>The directory to use as user profile. If None, a new temporary directory is used. Defaults to None.</p> <code>None</code> <code>page_load_strategy</code> <code>str</code> <p>The page load strategy. Defaults to \"normal\".</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>EdgeOptions</code> <p>The Edge options.</p> Source code in <code>web/browsers/edge.py</code> <pre><code>def default_options(headless=False, download_folder_path=None, user_data_dir=None,\n                    page_load_strategy=\"normal\") -&gt; EdgeOptions:\n\"\"\"Retrieve the default options for this browser curated by BotCity.\n    Args:\n        headless (bool, optional): Whether or not to use the headless mode. Defaults to False.\n        download_folder_path (str, optional): The default path in which to save files.\n            If None, the current directory is used. Defaults to None.\n        user_data_dir ([type], optional): The directory to use as user profile.\n            If None, a new temporary directory is used. Defaults to None.\n        page_load_strategy (str, optional): The page load strategy. Defaults to \"normal\".\n    Returns:\n        EdgeOptions: The Edge options.\n    \"\"\"\n    edge_options = EdgeOptions()\n    try:\n        page_load_strategy = page_load_strategy.value\n    except AttributeError:\n        page_load_strategy = page_load_strategy\n    edge_options.page_load_strategy = page_load_strategy\n    edge_options.use_chromium = True\n    edge_options.add_argument(\"--remote-debugging-port=0\")\n    edge_options.add_argument(\"--no-first-run\")\n    edge_options.add_argument(\"--no-default-browser-check\")\n    edge_options.add_argument(\"--disable-background-networking\")\n    edge_options.add_argument(\"--disable-background-timer-throttling\")\n    edge_options.add_argument(\"--disable-client-side-phishing-detection\")\n    edge_options.add_argument(\"--disable-default-apps\")\n    edge_options.add_argument(\"--disable-hang-monitor\")\n    edge_options.add_argument(\"--disable-popup-blocking\")\n    edge_options.add_argument(\"--disable-prompt-on-repost\")\n    edge_options.add_argument(\"--disable-syncdisable-translate\")\n    edge_options.add_argument(\"--metrics-recording-only\")\n    edge_options.add_argument(\"--safebrowsing-disable-auto-update\")\n\n    edge_options.add_argument(\"--disable-blink-features=AutomationControlled\")\n\n    # Disable banner for Browser being remote-controlled\n    edge_options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"])\n    edge_options.add_experimental_option('useAutomationExtension', False)\n\n    if headless:\n        edge_options.add_argument(\"--headless\")\n        edge_options.add_argument(\"--disable-gpu\")\n        edge_options.add_argument(\"--hide-scrollbars\")\n        edge_options.add_argument(\"--mute-audio\")\n\n    # Check if user is root\n    try:\n        # This is only valid with Unix\n        if os.geteuid() == 0:\n            edge_options.add_argument(\"--no-sandbox\")\n    except AttributeError:\n        pass\n\n    if not user_data_dir:\n        temp_dir = tempfile.TemporaryDirectory(prefix=\"botcity_\")\n        user_data_dir = temp_dir.name\n        atexit.register(cleanup_temp_dir, temp_dir)\n\n    edge_options.add_argument(f\"--user-data-dir={user_data_dir}\")\n\n    if not download_folder_path:\n        download_folder_path = os.getcwd()\n\n    app_state = {\n        \"recentDestinations\": [{\n            \"id\": \"Save as PDF\",\n            \"origin\": \"local\",\n            \"account\": \"\"\n        }],\n        \"selectedDestinationId\": \"Save as PDF\",\n        \"version\": 2,\n        \"isHeaderFooterEnabled\": False,\n        \"marginsType\": 2,\n        \"isCssBackgroundEnabled\": True\n    }\n\n    # Set the Downloads default folder\n    prefs = {\n        \"printing.print_preview_sticky_settings.appState\": json.dumps(app_state),\n        \"download.default_directory\": download_folder_path,\n        \"savefile.default_directory\": download_folder_path,\n        \"printing.default_destination_selection_rules\": {\n            \"kind\": \"local\",\n            \"namePattern\": \"Save as PDF\",\n        },\n        \"safebrowsing.enabled\": True,\n        \"credentials_enable_service\": False,\n        \"profile.password_manager_enabled\": False,\n        \"plugins.always_open_pdf_externally\": True\n    }\n\n    edge_options.add_experimental_option(\"prefs\", prefs)\n\n    edge_options.add_argument(\n        \"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n        \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\"\n    )\n\n    edge_options.add_argument(\"--kiosk-printing\")\n\n    return edge_options\n</code></pre>"},{"location":"browsers/#botcity.web.browsers.edge.default_capabilities","title":"<code>botcity.web.browsers.edge.default_capabilities()</code>","text":"<p>Fetch the default capabilities for this browser.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with the default capabilities defined.</p> Source code in <code>web/browsers/edge.py</code> <pre><code>def default_capabilities() -&gt; Dict:\n\"\"\"Fetch the default capabilities for this browser.\n    Returns:\n        Dict: Dictionary with the default capabilities defined.\n    \"\"\"\n    return DesiredCapabilities.EDGE.copy()\n</code></pre>"},{"location":"browsers/#ie","title":"IE","text":""},{"location":"browsers/#botcity.web.browsers.ie.default_options","title":"<code>botcity.web.browsers.ie.default_options(headless=False, download_folder_path=None, user_data_dir=None, page_load_strategy='normal')</code>","text":"<p>Retrieve the default options for this browser curated by BotCity.</p> <p>Returns:</p> Type Description <code>Options</code> <p>The Internet Explorer options.</p> Source code in <code>web/browsers/ie.py</code> <pre><code>def default_options(headless=False, download_folder_path=None, user_data_dir=None,\n                    page_load_strategy=\"normal\") -&gt; Options:\n\"\"\"Retrieve the default options for this browser curated by BotCity.\n\n    Returns:\n        Options: The Internet Explorer options.\n    \"\"\"\n    ie_options = Options()\n    ie_options.add_argument(\"-embedding\")\n    ie_options.add_argument(\"-extoff\")\n    ie_options.add_argument(\"-k\")\n    return ie_options\n</code></pre>"},{"location":"browsers/#botcity.web.browsers.ie.default_capabilities","title":"<code>botcity.web.browsers.ie.default_capabilities()</code>","text":"<p>Fetch the default capabilities for this browser.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with the default capabilities defined.</p> Source code in <code>web/browsers/ie.py</code> <pre><code>def default_capabilities() -&gt; Dict:\n\"\"\"Fetch the default capabilities for this browser.\n\n    Returns:\n        Dict: Dictionary with the default capabilities defined.\n    \"\"\"\n    return DesiredCapabilities.INTERNETEXPLORER.copy()\n</code></pre>"},{"location":"browsers/#important","title":"Important","text":"<p>If you have any questions about the driver see IE Driver Server Documentation.</p> <p>See the list of supported arguments in IE.</p> <p>During execution some errors may occur, see the list of common errors.</p>"},{"location":"forms/","title":"Interacting with Forms","text":"<p>When dealing with forms, we often need to fill in the form and submit it.</p> <p>While most of the operations are trivial, there are some things that are not such as selecting a select element or dealing with file uploads.</p> <p>For that we developed some utilitary functions that you can use.</p>"},{"location":"forms/#select-element","title":"Select Element","text":"<p>After grabing the element via the <code>find_element</code> or <code>find_elements</code> functions, we can use the <code>element_as_select</code> to convert it into a <code>Select</code> object.</p>"},{"location":"forms/#botcity.web.util.element_as_select","title":"<code>botcity.web.util.element_as_select(element)</code>","text":"<p>Wraps a WebElement in a Select object.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The element to wrap.</p> required <p>Returns:</p> Type Description <code>Select</code> <p>The Select object.</p> Source code in <code>web/util.py</code> <pre><code>def element_as_select(element: WebElement) -&gt; Select:\n\"\"\"Wraps a WebElement in a Select object.\n\n    Args:\n        element (WebElement): The element to wrap.\n\n    Returns:\n        Select: The Select object.\n    \"\"\"\n    return Select(element)\n</code></pre>"},{"location":"forms/#example-usage","title":"Example usage","text":"<pre><code># Import the function\nfrom botcity.web.util import element_as_select\n...\n# Fetch the select element\nelement = self.find_element(\"select\", By.TAG_NAME)\n# Convert the element into a Select object\nselect_element = element_as_select(element)\n# Select the option based on visible text\nselect_element.select_by_visible_text(\"Option 1\")\n...\n</code></pre>"},{"location":"forms/#file-upload","title":"File Upload","text":"<p>After grabing the element via the <code>find_element</code> or <code>find_elements</code> functions, we can use the <code>set_file_input_element</code> to assign the file path to the element.</p>"},{"location":"forms/#example-usage_1","title":"Example usage","text":"<pre><code>from botcity.web import By\n...\n# Find the input element of type `file` using CSS_SELECTOR.\nelem = self.find_element(\"body &gt; form &gt; input[type=file]\", By.CSS_SELECTOR)\n# Configure the file to be used when processing the upload\nself.set_file_input_element(elem, \"./test.txt\")\n...\n</code></pre>"},{"location":"intro/","title":"Getting Started","text":""},{"location":"intro/#supported-browsers","title":"Supported Browsers","text":"<p>This framework leverages the WebDriver API in order to communicate with browsers for Automation.</p> <p>In doing so, it requires that the WebDriver for the chosen browser to be installed and available preferrably in your <code>PATH</code>. If you can't add the necessary WebDriver to your <code>PATH</code> you will be able to inform the <code>driver path</code> via code in your bot.</p> <p>Here is a list of supported browsers along with links for you to download the proper WebDriver:</p> Browser WebDriver Download Chrome ChromeDriver Firefox GeckoDriver Edge MSDriverEdge IE IEDriverServer <p>Please follow the instructions on the WebDriver website for installation and setup.</p> <p>Once the desired WebDriver for the Web Browser to be used is installed we can proceed to the next steps.</p>"},{"location":"intro/#webbot","title":"WebBot","text":"<p>After you installed this package, the next step is to  import the package into your code and start using the WebBot class to build your RPA pipeline.</p> <pre><code>from botcity.web import *\n</code></pre>"},{"location":"intro/#template-project","title":"Template Project","text":"<p>We created a template project using Cookiecutter to help you create new bots using BotCity's Python Framework.</p> <p>Take a look into the template project website for more information on how to use it and get started.</p>"},{"location":"intro/#customizing-the-browser","title":"Customizing the Browser","text":"<p>To provide flexibility we have properties to allow you to configure which browser to use, the WebDriver location as well as the options used when launching the browser.</p> <p>Over the next steps we will over the possible customizations in detail.</p>"},{"location":"intro/#selecting-the-browser","title":"Selecting the Browser","text":"<p>The <code>WebBot</code> class by default comes configured to run with <code>Google Chrome</code>. You can select any other available browser by setting the <code>browser</code> property to one of the <code>Browser</code> enum available values.</p> <p>Here is an example on how to change the default browser to be used:</p> <pre><code>from botcity.web import WebBot, Browser\n\n\nclass Bot(WebBot):\n    def action(self, execution=None):\n        # Configure whether or not to run on headless mode\n        self.headless = False\n\n        # Changes the Browser to Firefox\n        self.browser = Browser.FIREFOX\n\n        # For Chrome\n        # self.browser = Browser.CHROME\n\n        ...\n</code></pre> <p>From the snippet above the key takeaway is the <code>self.browser</code> piece in which we set it to one of the values from the <code>Browser</code> enum as mentioned before.</p>"},{"location":"intro/#defining-the-webdriver-path","title":"Defining the WebDriver Path","text":"<p>If your WebDriver for the selected browser is not available on the system <code>PATH</code> you can inform the location via the <code>driver_path</code> property.</p> <p>Here is how that can be done: <pre><code>from botcity.web import WebBot, Browser\n\n\nclass Bot(WebBot):\n    def action(self, execution=None):\n        # Configure whether or not to run on headless mode\n        self.headless = False\n\n        # Inform the WebDriver path for Google Chrome's chromedriver\n        self.driver_path = \"/home/username/drivers/chromedriver\"\n\n        ...\n</code></pre></p>"},{"location":"intro/#customizing-browser-options","title":"Customizing Browser Options","text":"<p>By default the browsers are launched with a set of curated options which we picked as essential.</p> <p>Before getting into how to customize those details let's walk through some of the assumptions and details which are covered by the <code>default options</code>.</p> <ul> <li> <p>Headless Execution: Depending on the <code>headless</code> property set on your Bot class we pick the proper configuration to launch the browser in the desired mode.</p> </li> <li> <p>Downloads Folder Path: By default we save all downloaded files on the Desktop folder.</p> </li> <li> <p>User Profile: By default we generate a temporary directory (which is later erased) to be used   as the profile directory. This procedure ensure that every execution starts with a clean browser session   and things such as cookies and stored passwords or certificates from one execution won't interfere with   the others.</p> </li> <li> <p>Page Load Strategy: By default we use the <code>NORMAL</code> strategy which waits for the page to load completely.</p> </li> </ul> <p>A handful of other options are also set and they can be inspected on the source code for each browser on the <code>botcity.web.browsers</code> module.</p> <p>If you really need to customize the options you can do so via the <code>options</code> property. You can fetch the <code>default options</code> curated by BotCity and make your changes or start your options from scratch.</p> <p>In the following snippet we will cover how to build on top of the existing options.</p> <pre><code>from botcity.web import WebBot, Browser, PageLoadStrategy\n\n# For Chrome\nfrom botcity.web.browsers.chrome import default_options\n# For Firefox\n#from botcity.web.browsers.firefox import default_options\n\nclass Bot(WebBot):\n    def action(self, execution=None):\n        # Configure whether or not to run on headless mode\n        self.headless = False\n\n        # Fetch the default options for my preferred browser\n        # Pass in the headless, download_folder_path and user_data_dir\n        # to be used when building the default_options\n        def_options = default_options(\n            headless=self.headless,\n            download_folder_path=self.download_folder_path,\n            user_data_dir=None,  # Informing None here will generate a temporary directory\n            page_load_strategy=PageLoadStrategy.NORMAL\n        )\n\n        # Add your customized argument\n        def_options.add_argument(\"&lt;My Special Argument&gt;\")\n\n        # Update the options to use the customized Options.\n        self.options = def_options\n\n        ...\n</code></pre> <p>Every supported browser will have an exclusive module with curated default options accessible via the module's <code>default_options</code> function.</p> <p>This function takes in arguments to define the mode of execution (headless or not), default download folder path and user data/profile directory.</p>"},{"location":"intro/#parsing-data","title":"Parsing Data","text":"<p>When extracting data from websites we often need to read information from tables and other common sources. The <code>Handling Data</code> section highlights how we can do that and which functions are available to be used.</p>"},{"location":"intro/#forms","title":"Forms","text":"<p>It is common while navigating websites to have to fill up forms and submit them. To facilitate this we have a <code>Interacting with Forms</code> section which highlights the available functions to be used.</p>"},{"location":"intro/#next-steps","title":"Next Steps","text":"<p>Check our examples and experiment with the API. Let us know where it can be improved.</p> <p>Have fun automating!</p>"},{"location":"parsers/","title":"Handling Data","text":""},{"location":"parsers/#tables","title":"Tables","text":"<p>To extract data from tables we offer an utility function which parses the table and returns a list of dictionaries.</p>"},{"location":"parsers/#botcity.web.parsers.table_to_dict","title":"<code>botcity.web.parsers.table_to_dict(table, has_header=True, skip_rows=0, header_tag='th', cell_xpath=None)</code>","text":"<p>Convert a table WebElement to a dict of lists.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>WebElement</code> <p>The table element.</p> required <code>has_header</code> <code>bool</code> <p>Whether or not to parse a header. Defaults to True.</p> <code>True</code> <code>skip_rows</code> <code>int</code> <p>Number of rows to skip from the top. Defaults to 0.</p> <code>0</code> <code>header_tag</code> <code>str</code> <p>The HTML tag associated with the header cell. Defaults to \"th\".</p> <code>'th'</code> <code>cell_xpath</code> <code>str</code> <p>Optional cell XPath selector for complex row constructions. If <code>cell_xpath</code> is not informed, the row data will come from <code>&lt;td&gt;</code> elements.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>List with dict for each row.</p> Source code in <code>web/parsers.py</code> <pre><code>def table_to_dict(table: WebElement, has_header: bool = True,\n                  skip_rows: int = 0, header_tag: str = \"th\",\n                  cell_xpath: Optional[str] = None) -&gt; List[Dict]:\n\"\"\"Convert a table WebElement to a dict of lists.\n\n    Args:\n        table (WebElement): The table element.\n        has_header (bool, optional): Whether or not to parse a header. Defaults to True.\n        skip_rows (int, optional): Number of rows to skip from the top. Defaults to 0.\n        header_tag (str, optional): The HTML tag associated with the header cell. Defaults to \"th\".\n        cell_xpath (str, optional): Optional cell XPath selector for complex row constructions.\n            If `cell_xpath` is not informed, the row data will come from `&lt;td&gt;` elements.\n\n    Returns:\n        list: List with dict for each row.\n    \"\"\"\n\n    # Collect all rows from table\n    rows = table.find_elements_by_tag_name(\"tr\")\n\n    # Skip rows if informed\n    if skip_rows:\n        rows = rows[skip_rows:]\n\n    if cell_xpath and not cell_xpath.startswith('.'):\n        # Convert into relative xpath\n        cell_xpath = f'.{cell_xpath}'\n\n    # Parse header labels\n    if has_header:\n        # Read header labels\n        labels = data_from_row(rows[0], cell_tag=header_tag)\n        # Sanitize headers\n        labels = sanitize_header(labels)\n        # Skip the header\n        rows = rows[1:]\n    else:\n        # Make up header labels\n        if cell_xpath:\n            cols = rows[0].find_elements_by_xpath(cell_xpath)\n        else:\n            cols = rows[0].find_elements_by_tag_name(\"td\")\n\n        num_cols = len(cols)\n        labels = [f\"col_{i}\" for i in range(num_cols)]\n\n    # Assemble output dictionary\n    out_list = []\n    for row in rows:\n        row_data = data_from_row(row, cell_xpath=cell_xpath)\n        out_list.append(dict(zip(labels, row_data)))\n\n    return out_list\n</code></pre>"},{"location":"parsers/#usage-example","title":"Usage Example","text":"<p>Let's fetch data from the example table available at the W3Schools website.</p> <pre><code>class Bot(WebBot):\n    def action(self, execution=None):\n        self.browse(\"https://www.w3schools.com/html/html_tables.asp\")\n\n        # Fetch the table\n        table = self.find_element(\"table\", By.TAG_NAME)\n\n        # Parse the table\n        parsed_table = table_to_dict(table)\n\n        # Print the parsed table\n        print(parsed_table)\n\n        # Close the browser and free resources\n        self.stop_browser()\n</code></pre> <p>The output should look like this:</p> <pre><code>[\n    {\n        'company': 'Alfreds Futterkiste',\n        'contact': 'Maria Anders',\n        'country': 'Germany'\n    },\n    {\n        'company': 'Centro comercial Moctezuma',\n        'contact': 'Francisco Chang',\n        'country': 'Mexico'\n    },\n    {\n        'company': 'Ernst Handel',\n        'contact': 'Roland Mendel',\n        'country': 'Austria'\n    },\n    {\n        'company': 'Island Trading',\n        'contact': 'Helen Bennett',\n        'country': 'UK'\n    },\n    {\n        'company': 'Laughing Bacchus Winecellars',\n        'contact': 'Yoshi Tannamuri',\n        'country': 'Canada'\n    },\n    {\n        'company': 'Magazzini Alimentari Riuniti',\n        'contact': 'Giovanni Rovelli',\n        'country': 'Italy'\n    }\n]\n</code></pre>"}]}